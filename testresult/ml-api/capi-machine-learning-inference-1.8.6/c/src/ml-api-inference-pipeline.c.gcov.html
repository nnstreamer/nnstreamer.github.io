<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - ML API 1.8.6-0 nnstreamer/api#7f8530c294f86ec880b29347a861499239d358a1 - capi-machine-learning-inference-1.8.6/c/src/ml-api-inference-pipeline.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">capi-machine-learning-inference-1.8.6/c/src</a> - ml-api-inference-pipeline.c<span style="font-size: 80%;"> (source / <a href="ml-api-inference-pipeline.c.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">ML API 1.8.6-0 nnstreamer/api#7f8530c294f86ec880b29347a861499239d358a1</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryMed">82.5&nbsp;%</td>
            <td class="headerCovTableEntry">1380</td>
            <td class="headerCovTableEntry">1139</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-07-04 05:26:45</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">94.0&nbsp;%</td>
            <td class="headerCovTableEntry">84</td>
            <td class="headerCovTableEntry">79</td>
          </tr>
                  <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /* SPDX-License-Identifier: Apache-2.0 */</span>
<span id="L2"><span class="lineNum">       2</span>              : /**</span>
<span id="L3"><span class="lineNum">       3</span>              :  * Copyright (c) 2019 Samsung Electronics Co., Ltd. All Rights Reserved.</span>
<span id="L4"><span class="lineNum">       4</span>              :  *</span>
<span id="L5"><span class="lineNum">       5</span>              :  * @file ml-api-inference-pipeline.c</span>
<span id="L6"><span class="lineNum">       6</span>              :  * @date 11 March 2019</span>
<span id="L7"><span class="lineNum">       7</span>              :  * @brief NNStreamer/Pipeline(main) C-API Wrapper.</span>
<span id="L8"><span class="lineNum">       8</span>              :  *        This allows to construct and control NNStreamer pipelines.</span>
<span id="L9"><span class="lineNum">       9</span>              :  * @see https://github.com/nnstreamer/nnstreamer</span>
<span id="L10"><span class="lineNum">      10</span>              :  * @author MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;</span>
<span id="L11"><span class="lineNum">      11</span>              :  * @bug Thread safety for ml_tensors_data should be addressed.</span>
<span id="L12"><span class="lineNum">      12</span>              :  */</span>
<span id="L13"><span class="lineNum">      13</span>              : </span>
<span id="L14"><span class="lineNum">      14</span>              : #include &lt;string.h&gt;</span>
<span id="L15"><span class="lineNum">      15</span>              : #include &lt;glib.h&gt;</span>
<span id="L16"><span class="lineNum">      16</span>              : #include &lt;gst/gstbuffer.h&gt;</span>
<span id="L17"><span class="lineNum">      17</span>              : #include &lt;gst/app/app.h&gt;        /* To push data to pipeline */</span>
<span id="L18"><span class="lineNum">      18</span>              : #include &lt;nnstreamer_plugin_api.h&gt;</span>
<span id="L19"><span class="lineNum">      19</span>              : #include &lt;tensor_if.h&gt;</span>
<span id="L20"><span class="lineNum">      20</span>              : #include &lt;tensor_typedef.h&gt;</span>
<span id="L21"><span class="lineNum">      21</span>              : #include &lt;tensor_filter_custom_easy.h&gt;</span>
<span id="L22"><span class="lineNum">      22</span>              : </span>
<span id="L23"><span class="lineNum">      23</span>              : #include &lt;nnstreamer.h&gt;</span>
<span id="L24"><span class="lineNum">      24</span>              : #include &lt;nnstreamer-tizen-internal.h&gt;</span>
<span id="L25"><span class="lineNum">      25</span>              : </span>
<span id="L26"><span class="lineNum">      26</span>              : #include &quot;ml-api-internal.h&quot;</span>
<span id="L27"><span class="lineNum">      27</span>              : #include &quot;ml-api-inference-internal.h&quot;</span>
<span id="L28"><span class="lineNum">      28</span>              : #include &quot;ml-api-inference-pipeline-internal.h&quot;</span>
<span id="L29"><span class="lineNum">      29</span>              : </span>
<span id="L30"><span class="lineNum">      30</span>              : </span>
<span id="L31"><span class="lineNum">      31</span>              : #define handle_init(name, h) \</span>
<span id="L32"><span class="lineNum">      32</span>              :   ml_pipeline_common_elem *name= (h); \</span>
<span id="L33"><span class="lineNum">      33</span>              :   ml_pipeline *p; \</span>
<span id="L34"><span class="lineNum">      34</span>              :   ml_pipeline_element *elem; \</span>
<span id="L35"><span class="lineNum">      35</span>              :   int ret = ML_ERROR_NONE; \</span>
<span id="L36"><span class="lineNum">      36</span>              :   check_feature_state (ML_FEATURE_INFERENCE); \</span>
<span id="L37"><span class="lineNum">      37</span>              :   if ((h) == NULL) { \</span>
<span id="L38"><span class="lineNum">      38</span>              :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER, \</span>
<span id="L39"><span class="lineNum">      39</span>              :         &quot;The parameter, %s, (handle) is invalid (NULL). Please provide a valid handle.&quot;, \</span>
<span id="L40"><span class="lineNum">      40</span>              :         #h); \</span>
<span id="L41"><span class="lineNum">      41</span>              :   } \</span>
<span id="L42"><span class="lineNum">      42</span>              :   p = name-&gt;pipe; \</span>
<span id="L43"><span class="lineNum">      43</span>              :   elem = name-&gt;element; \</span>
<span id="L44"><span class="lineNum">      44</span>              :   if (p == NULL) \</span>
<span id="L45"><span class="lineNum">      45</span>              :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER, \</span>
<span id="L46"><span class="lineNum">      46</span>              :         &quot;Internal error. The contents of parameter, %s, (handle), is invalid. The pipeline entry (%s-&gt;pipe) is NULL. The handle (%s) is either not properly created or application threads may have touched its contents.&quot;, \</span>
<span id="L47"><span class="lineNum">      47</span>              :         #h, #h, #h); \</span>
<span id="L48"><span class="lineNum">      48</span>              :   if (elem == NULL) \</span>
<span id="L49"><span class="lineNum">      49</span>              :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER, \</span>
<span id="L50"><span class="lineNum">      50</span>              :         &quot;Internal error. The contents of parameter, %s, (handle), is invalid. The element entry (%s-&gt;element) is NULL. The handle (%s) is either not properly created or application threads may have touched its contents.&quot;, \</span>
<span id="L51"><span class="lineNum">      51</span>              :         #h, #h, #h); \</span>
<span id="L52"><span class="lineNum">      52</span>              :   if (elem-&gt;pipe == NULL) \</span>
<span id="L53"><span class="lineNum">      53</span>              :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER, \</span>
<span id="L54"><span class="lineNum">      54</span>              :         &quot;Internal error. The contents of parameter, %s, (handle), is invalid. The pipeline entry of the element entry (%s-&gt;element-&gt;pipe) is NULL. The handle (%s) is either not properly created or application threads may have touched its contents.&quot;, \</span>
<span id="L55"><span class="lineNum">      55</span>              :         #h, #h, #h); \</span>
<span id="L56"><span class="lineNum">      56</span>              :   g_mutex_lock (&amp;p-&gt;lock); \</span>
<span id="L57"><span class="lineNum">      57</span>              :   g_mutex_lock (&amp;elem-&gt;lock); \</span>
<span id="L58"><span class="lineNum">      58</span>              :   if (NULL == g_list_find (elem-&gt;handles, name)) { \</span>
<span id="L59"><span class="lineNum">      59</span>              :     _ml_error_report \</span>
<span id="L60"><span class="lineNum">      60</span>              :         (&quot;Internal error. The handle name, %s, does not exists in the list of %s-&gt;element-&gt;handles.&quot;, \</span>
<span id="L61"><span class="lineNum">      61</span>              :         #h, #h); \</span>
<span id="L62"><span class="lineNum">      62</span>              :     ret = ML_ERROR_INVALID_PARAMETER; \</span>
<span id="L63"><span class="lineNum">      63</span>              :     goto unlock_return; \</span>
<span id="L64"><span class="lineNum">      64</span>              :   }</span>
<span id="L65"><span class="lineNum">      65</span>              : </span>
<span id="L66"><span class="lineNum">      66</span>              : #define handle_exit(h) \</span>
<span id="L67"><span class="lineNum">      67</span>              : unlock_return: \</span>
<span id="L68"><span class="lineNum">      68</span>              :   g_mutex_unlock (&amp;elem-&gt;lock); \</span>
<span id="L69"><span class="lineNum">      69</span>              :   g_mutex_unlock (&amp;p-&gt;lock); \</span>
<span id="L70"><span class="lineNum">      70</span>              :   return ret;</span>
<span id="L71"><span class="lineNum">      71</span>              : </span>
<span id="L72"><span class="lineNum">      72</span>              : /**</span>
<span id="L73"><span class="lineNum">      73</span>              :  * @brief The enumeration for custom data type.</span>
<span id="L74"><span class="lineNum">      74</span>              :  */</span>
<span id="L75"><span class="lineNum">      75</span>              : typedef enum</span>
<span id="L76"><span class="lineNum">      76</span>              : {</span>
<span id="L77"><span class="lineNum">      77</span>              :   PIPE_CUSTOM_TYPE_NONE,</span>
<span id="L78"><span class="lineNum">      78</span>              :   PIPE_CUSTOM_TYPE_IF,</span>
<span id="L79"><span class="lineNum">      79</span>              :   PIPE_CUSTOM_TYPE_FILTER,</span>
<span id="L80"><span class="lineNum">      80</span>              : </span>
<span id="L81"><span class="lineNum">      81</span>              :   PIPE_CUSTOM_TYPE_MAX</span>
<span id="L82"><span class="lineNum">      82</span>              : } pipe_custom_type_e;</span>
<span id="L83"><span class="lineNum">      83</span>              : </span>
<span id="L84"><span class="lineNum">      84</span>              : /**</span>
<span id="L85"><span class="lineNum">      85</span>              :  * @brief The struct for custom data.</span>
<span id="L86"><span class="lineNum">      86</span>              :  */</span>
<span id="L87"><span class="lineNum">      87</span>              : typedef struct</span>
<span id="L88"><span class="lineNum">      88</span>              : {</span>
<span id="L89"><span class="lineNum">      89</span>              :   pipe_custom_type_e type;</span>
<span id="L90"><span class="lineNum">      90</span>              :   gchar *name;</span>
<span id="L91"><span class="lineNum">      91</span>              :   gpointer handle;</span>
<span id="L92"><span class="lineNum">      92</span>              : } pipe_custom_data_s;</span>
<span id="L93"><span class="lineNum">      93</span>              : </span>
<span id="L94"><span class="lineNum">      94</span>              : static void ml_pipeline_custom_filter_ref (ml_custom_easy_filter_h custom);</span>
<span id="L95"><span class="lineNum">      95</span>              : static void ml_pipeline_custom_filter_unref (ml_custom_easy_filter_h custom);</span>
<span id="L96"><span class="lineNum">      96</span>              : static void ml_pipeline_if_custom_ref (ml_pipeline_if_h custom);</span>
<span id="L97"><span class="lineNum">      97</span>              : static void ml_pipeline_if_custom_unref (ml_pipeline_if_h custom);</span>
<span id="L98"><span class="lineNum">      98</span>              : </span>
<span id="L99"><span class="lineNum">      99</span>              : /**</span>
<span id="L100"><span class="lineNum">     100</span>              :  * @brief Global lock for pipeline functions.</span>
<span id="L101"><span class="lineNum">     101</span>              :  */</span>
<span id="L102"><span class="lineNum">     102</span>              : G_LOCK_DEFINE_STATIC (g_ml_pipe_lock);</span>
<span id="L103"><span class="lineNum">     103</span>              : </span>
<span id="L104"><span class="lineNum">     104</span>              : /**</span>
<span id="L105"><span class="lineNum">     105</span>              :  * @brief The list of custom data. This should be managed with lock.</span>
<span id="L106"><span class="lineNum">     106</span>              :  */</span>
<span id="L107"><span class="lineNum">     107</span>              : static GList *g_ml_custom_data = NULL;</span>
<span id="L108"><span class="lineNum">     108</span>              : </span>
<span id="L109"><span class="lineNum">     109</span>              : /**</span>
<span id="L110"><span class="lineNum">     110</span>              :  * @brief Finds a position of custom data in the list.</span>
<span id="L111"><span class="lineNum">     111</span>              :  * @note This function should be called with lock.</span>
<span id="L112"><span class="lineNum">     112</span>              :  */</span>
<span id="L113"><span class="lineNum">     113</span>              : static GList *</span>
<span id="L114"><span class="lineNum">     114</span> <span class="tlaGNC tlaBgGNC">          12 : pipe_custom_find_link (const pipe_custom_type_e type, const gchar * name)</span></span>
<span id="L115"><span class="lineNum">     115</span>              : {</span>
<span id="L116"><span class="lineNum">     116</span>              :   pipe_custom_data_s *data;</span>
<span id="L117"><span class="lineNum">     117</span>              :   GList *link;</span>
<span id="L118"><span class="lineNum">     118</span>              : </span>
<span id="L119"><span class="lineNum">     119</span> <span class="tlaGNC">          12 :   g_return_val_if_fail (name != NULL, NULL);</span></span>
<span id="L120"><span class="lineNum">     120</span>              : </span>
<span id="L121"><span class="lineNum">     121</span> <span class="tlaGNC">          12 :   link = g_ml_custom_data;</span></span>
<span id="L122"><span class="lineNum">     122</span> <span class="tlaGNC">          12 :   while (link) {</span></span>
<span id="L123"><span class="lineNum">     123</span> <span class="tlaGNC">          12 :     data = (pipe_custom_data_s *) link-&gt;data;</span></span>
<span id="L124"><span class="lineNum">     124</span>              : </span>
<span id="L125"><span class="lineNum">     125</span> <span class="tlaGNC">          12 :     if (data-&gt;type == type &amp;&amp; g_str_equal (data-&gt;name, name))</span></span>
<span id="L126"><span class="lineNum">     126</span> <span class="tlaGNC">          12 :       break;</span></span>
<span id="L127"><span class="lineNum">     127</span>              : </span>
<span id="L128"><span class="lineNum">     128</span> <span class="tlaUNC tlaBgUNC">           0 :     link = link-&gt;next;</span></span>
<span id="L129"><span class="lineNum">     129</span>              :   }</span>
<span id="L130"><span class="lineNum">     130</span>              : </span>
<span id="L131"><span class="lineNum">     131</span> <span class="tlaGNC tlaBgGNC">          12 :   return link;</span></span>
<span id="L132"><span class="lineNum">     132</span>              : }</span>
<span id="L133"><span class="lineNum">     133</span>              : </span>
<span id="L134"><span class="lineNum">     134</span>              : /**</span>
<span id="L135"><span class="lineNum">     135</span>              :  * @brief Finds custom data matched with data type and name.</span>
<span id="L136"><span class="lineNum">     136</span>              :  */</span>
<span id="L137"><span class="lineNum">     137</span>              : static pipe_custom_data_s *</span>
<span id="L138"><span class="lineNum">     138</span> <span class="tlaGNC">           6 : pipe_custom_find_data (const pipe_custom_type_e type, const gchar * name)</span></span>
<span id="L139"><span class="lineNum">     139</span>              : {</span>
<span id="L140"><span class="lineNum">     140</span>              :   pipe_custom_data_s *data;</span>
<span id="L141"><span class="lineNum">     141</span>              :   GList *link;</span>
<span id="L142"><span class="lineNum">     142</span>              : </span>
<span id="L143"><span class="lineNum">     143</span> <span class="tlaGNC">           6 :   G_LOCK (g_ml_pipe_lock);</span></span>
<span id="L144"><span class="lineNum">     144</span>              : </span>
<span id="L145"><span class="lineNum">     145</span> <span class="tlaGNC">           6 :   link = pipe_custom_find_link (type, name);</span></span>
<span id="L146"><span class="lineNum">     146</span> <span class="tlaGNC">           6 :   data = (link != NULL) ? (pipe_custom_data_s *) link-&gt;data : NULL;</span></span>
<span id="L147"><span class="lineNum">     147</span>              : </span>
<span id="L148"><span class="lineNum">     148</span> <span class="tlaGNC">           6 :   G_UNLOCK (g_ml_pipe_lock);</span></span>
<span id="L149"><span class="lineNum">     149</span> <span class="tlaGNC">           6 :   return data;</span></span>
<span id="L150"><span class="lineNum">     150</span>              : }</span>
<span id="L151"><span class="lineNum">     151</span>              : </span>
<span id="L152"><span class="lineNum">     152</span>              : /**</span>
<span id="L153"><span class="lineNum">     153</span>              :  * @brief Adds new custom data into the list.</span>
<span id="L154"><span class="lineNum">     154</span>              :  */</span>
<span id="L155"><span class="lineNum">     155</span>              : static void</span>
<span id="L156"><span class="lineNum">     156</span> <span class="tlaGNC">           6 : pipe_custom_add_data (const pipe_custom_type_e type, const gchar * name,</span></span>
<span id="L157"><span class="lineNum">     157</span>              :     gpointer handle)</span>
<span id="L158"><span class="lineNum">     158</span>              : {</span>
<span id="L159"><span class="lineNum">     159</span>              :   pipe_custom_data_s *data;</span>
<span id="L160"><span class="lineNum">     160</span>              : </span>
<span id="L161"><span class="lineNum">     161</span> <span class="tlaGNC">           6 :   data = g_new0 (pipe_custom_data_s, 1);</span></span>
<span id="L162"><span class="lineNum">     162</span> <span class="tlaGNC">           6 :   data-&gt;type = type;</span></span>
<span id="L163"><span class="lineNum">     163</span> <span class="tlaGNC">           6 :   data-&gt;name = g_strdup (name);</span></span>
<span id="L164"><span class="lineNum">     164</span> <span class="tlaGNC">           6 :   data-&gt;handle = handle;</span></span>
<span id="L165"><span class="lineNum">     165</span>              : </span>
<span id="L166"><span class="lineNum">     166</span> <span class="tlaGNC">           6 :   G_LOCK (g_ml_pipe_lock);</span></span>
<span id="L167"><span class="lineNum">     167</span> <span class="tlaGNC">           6 :   g_ml_custom_data = g_list_prepend (g_ml_custom_data, data);</span></span>
<span id="L168"><span class="lineNum">     168</span> <span class="tlaGNC">           6 :   G_UNLOCK (g_ml_pipe_lock);</span></span>
<span id="L169"><span class="lineNum">     169</span> <span class="tlaGNC">           6 : }</span></span>
<span id="L170"><span class="lineNum">     170</span>              : </span>
<span id="L171"><span class="lineNum">     171</span>              : /**</span>
<span id="L172"><span class="lineNum">     172</span>              :  * @brief Removes custom data from the list.</span>
<span id="L173"><span class="lineNum">     173</span>              :  */</span>
<span id="L174"><span class="lineNum">     174</span>              : static void</span>
<span id="L175"><span class="lineNum">     175</span> <span class="tlaGNC">           6 : pipe_custom_remove_data (const pipe_custom_type_e type, const gchar * name)</span></span>
<span id="L176"><span class="lineNum">     176</span>              : {</span>
<span id="L177"><span class="lineNum">     177</span>              :   pipe_custom_data_s *data;</span>
<span id="L178"><span class="lineNum">     178</span>              :   GList *link;</span>
<span id="L179"><span class="lineNum">     179</span>              : </span>
<span id="L180"><span class="lineNum">     180</span> <span class="tlaGNC">           6 :   G_LOCK (g_ml_pipe_lock);</span></span>
<span id="L181"><span class="lineNum">     181</span>              : </span>
<span id="L182"><span class="lineNum">     182</span> <span class="tlaGNC">           6 :   link = pipe_custom_find_link (type, name);</span></span>
<span id="L183"><span class="lineNum">     183</span> <span class="tlaGNC">           6 :   if (link) {</span></span>
<span id="L184"><span class="lineNum">     184</span> <span class="tlaGNC">           6 :     data = (pipe_custom_data_s *) link-&gt;data;</span></span>
<span id="L185"><span class="lineNum">     185</span>              : </span>
<span id="L186"><span class="lineNum">     186</span> <span class="tlaGNC">           6 :     g_ml_custom_data = g_list_delete_link (g_ml_custom_data, link);</span></span>
<span id="L187"><span class="lineNum">     187</span>              : </span>
<span id="L188"><span class="lineNum">     188</span> <span class="tlaGNC">           6 :     g_free (data-&gt;name);</span></span>
<span id="L189"><span class="lineNum">     189</span> <span class="tlaGNC">           6 :     g_free (data);</span></span>
<span id="L190"><span class="lineNum">     190</span>              :   }</span>
<span id="L191"><span class="lineNum">     191</span>              : </span>
<span id="L192"><span class="lineNum">     192</span> <span class="tlaGNC">           6 :   G_UNLOCK (g_ml_pipe_lock);</span></span>
<span id="L193"><span class="lineNum">     193</span> <span class="tlaGNC">           6 : }</span></span>
<span id="L194"><span class="lineNum">     194</span>              : </span>
<span id="L195"><span class="lineNum">     195</span>              : /**</span>
<span id="L196"><span class="lineNum">     196</span>              :  * @brief The callback function called when the element node with custom data is released.</span>
<span id="L197"><span class="lineNum">     197</span>              :  */</span>
<span id="L198"><span class="lineNum">     198</span>              : static int</span>
<span id="L199"><span class="lineNum">     199</span> <span class="tlaGNC">           6 : pipe_custom_destroy_cb (void *handle, void *user_data)</span></span>
<span id="L200"><span class="lineNum">     200</span>              : {</span>
<span id="L201"><span class="lineNum">     201</span>              :   pipe_custom_data_s *custom_data;</span>
<span id="L202"><span class="lineNum">     202</span>              : </span>
<span id="L203"><span class="lineNum">     203</span> <span class="tlaGNC">           6 :   custom_data = (pipe_custom_data_s *) handle;</span></span>
<span id="L204"><span class="lineNum">     204</span> <span class="tlaGNC">           6 :   if (custom_data == NULL)</span></span>
<span id="L205"><span class="lineNum">     205</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L206"><span class="lineNum">     206</span>              :         &quot;The parameter, handle, is NULL. It should be a valid internal object. This is possibly a bug in ml-api-inference-pipeline.c along with tensor-if or tensor-filter/custom function. Please report to https://github.com/nnstreamer/nnstreamer/issues&quot;);</span>
<span id="L207"><span class="lineNum">     207</span>              : </span>
<span id="L208"><span class="lineNum">     208</span> <span class="tlaGNC tlaBgGNC">           6 :   switch (custom_data-&gt;type) {</span></span>
<span id="L209"><span class="lineNum">     209</span> <span class="tlaGNC">           3 :     case PIPE_CUSTOM_TYPE_IF:</span></span>
<span id="L210"><span class="lineNum">     210</span> <span class="tlaGNC">           3 :       ml_pipeline_if_custom_unref (custom_data-&gt;handle);</span></span>
<span id="L211"><span class="lineNum">     211</span> <span class="tlaGNC">           3 :       break;</span></span>
<span id="L212"><span class="lineNum">     212</span> <span class="tlaGNC">           3 :     case PIPE_CUSTOM_TYPE_FILTER:</span></span>
<span id="L213"><span class="lineNum">     213</span> <span class="tlaGNC">           3 :       ml_pipeline_custom_filter_unref (custom_data-&gt;handle);</span></span>
<span id="L214"><span class="lineNum">     214</span> <span class="tlaGNC">           3 :       break;</span></span>
<span id="L215"><span class="lineNum">     215</span> <span class="tlaUNC tlaBgUNC">           0 :     default:</span></span>
<span id="L216"><span class="lineNum">     216</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L217"><span class="lineNum">     217</span>              :   }</span>
<span id="L218"><span class="lineNum">     218</span>              : </span>
<span id="L219"><span class="lineNum">     219</span> <span class="tlaGNC tlaBgGNC">           6 :   return ML_ERROR_NONE;</span></span>
<span id="L220"><span class="lineNum">     220</span>              : }</span>
<span id="L221"><span class="lineNum">     221</span>              : </span>
<span id="L222"><span class="lineNum">     222</span>              : /**</span>
<span id="L223"><span class="lineNum">     223</span>              :  * @brief Internal function to create a referable element in a pipeline</span>
<span id="L224"><span class="lineNum">     224</span>              :  */</span>
<span id="L225"><span class="lineNum">     225</span>              : static ml_pipeline_element *</span>
<span id="L226"><span class="lineNum">     226</span> <span class="tlaGNC">         404 : construct_element (GstElement * e, ml_pipeline * p, const char *name,</span></span>
<span id="L227"><span class="lineNum">     227</span>              :     ml_pipeline_element_e t)</span>
<span id="L228"><span class="lineNum">     228</span>              : {</span>
<span id="L229"><span class="lineNum">     229</span> <span class="tlaGNC">         404 :   ml_pipeline_element *ret = g_new0 (ml_pipeline_element, 1);</span></span>
<span id="L230"><span class="lineNum">     230</span>              : </span>
<span id="L231"><span class="lineNum">     231</span> <span class="tlaGNC">         404 :   if (ret == NULL)</span></span>
<span id="L232"><span class="lineNum">     232</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (NULL,</span></span>
<span id="L233"><span class="lineNum">     233</span>              :         &quot;Failed to allocate memory for the pipeline.&quot;);</span>
<span id="L234"><span class="lineNum">     234</span>              : </span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC tlaBgGNC">         404 :   ret-&gt;element = e;</span></span>
<span id="L236"><span class="lineNum">     236</span> <span class="tlaGNC">         404 :   ret-&gt;pipe = p;</span></span>
<span id="L237"><span class="lineNum">     237</span> <span class="tlaGNC">         404 :   ret-&gt;name = g_strdup (name);</span></span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">         404 :   ret-&gt;type = t;</span></span>
<span id="L239"><span class="lineNum">     239</span> <span class="tlaGNC">         404 :   ret-&gt;handles = NULL;</span></span>
<span id="L240"><span class="lineNum">     240</span> <span class="tlaGNC">         404 :   ret-&gt;src = NULL;</span></span>
<span id="L241"><span class="lineNum">     241</span> <span class="tlaGNC">         404 :   ret-&gt;sink = NULL;</span></span>
<span id="L242"><span class="lineNum">     242</span> <span class="tlaGNC">         404 :   ret-&gt;maxid = 0;</span></span>
<span id="L243"><span class="lineNum">     243</span> <span class="tlaGNC">         404 :   ret-&gt;handle_id = 0;</span></span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaGNC">         404 :   ret-&gt;is_media_stream = FALSE;</span></span>
<span id="L245"><span class="lineNum">     245</span> <span class="tlaGNC">         404 :   ret-&gt;is_flexible_tensor = FALSE;</span></span>
<span id="L246"><span class="lineNum">     246</span> <span class="tlaGNC">         404 :   g_mutex_init (&amp;ret-&gt;lock);</span></span>
<span id="L247"><span class="lineNum">     247</span> <span class="tlaGNC">         404 :   gst_tensors_info_init (&amp;ret-&gt;tensors_info);</span></span>
<span id="L248"><span class="lineNum">     248</span>              : </span>
<span id="L249"><span class="lineNum">     249</span> <span class="tlaGNC">         404 :   return ret;</span></span>
<span id="L250"><span class="lineNum">     250</span>              : }</span>
<span id="L251"><span class="lineNum">     251</span>              : </span>
<span id="L252"><span class="lineNum">     252</span>              : /**</span>
<span id="L253"><span class="lineNum">     253</span>              :  * @brief Internal function to get the tensors info from the element caps.</span>
<span id="L254"><span class="lineNum">     254</span>              :  */</span>
<span id="L255"><span class="lineNum">     255</span>              : static gboolean</span>
<span id="L256"><span class="lineNum">     256</span> <span class="tlaGNC">       12514 : get_tensors_info_from_caps (GstCaps * caps, GstTensorsInfo * info,</span></span>
<span id="L257"><span class="lineNum">     257</span>              :     gboolean * is_flexible)</span>
<span id="L258"><span class="lineNum">     258</span>              : {</span>
<span id="L259"><span class="lineNum">     259</span>              :   GstStructure *s;</span>
<span id="L260"><span class="lineNum">     260</span>              :   GstTensorsConfig config;</span>
<span id="L261"><span class="lineNum">     261</span>              :   guint i, n_caps;</span>
<span id="L262"><span class="lineNum">     262</span> <span class="tlaGNC">       12514 :   gboolean found = FALSE;</span></span>
<span id="L263"><span class="lineNum">     263</span>              : </span>
<span id="L264"><span class="lineNum">     264</span> <span class="tlaGNC">       12514 :   n_caps = gst_caps_get_size (caps);</span></span>
<span id="L265"><span class="lineNum">     265</span>              : </span>
<span id="L266"><span class="lineNum">     266</span> <span class="tlaGNC">       12521 :   for (i = 0; i &lt; n_caps; i++) {</span></span>
<span id="L267"><span class="lineNum">     267</span> <span class="tlaGNC">       12515 :     s = gst_caps_get_structure (caps, i);</span></span>
<span id="L268"><span class="lineNum">     268</span> <span class="tlaGNC">       12515 :     found = gst_tensors_config_from_structure (&amp;config, s);</span></span>
<span id="L269"><span class="lineNum">     269</span>              : </span>
<span id="L270"><span class="lineNum">     270</span> <span class="tlaGNC">       12515 :     if (found) {</span></span>
<span id="L271"><span class="lineNum">     271</span> <span class="tlaGNC">       12508 :       gst_tensors_info_free (info);</span></span>
<span id="L272"><span class="lineNum">     272</span> <span class="tlaGNC">       12508 :       gst_tensors_info_copy (info, &amp;config.info);</span></span>
<span id="L273"><span class="lineNum">     273</span> <span class="tlaGNC">       12508 :       *is_flexible = gst_tensors_config_is_flexible (&amp;config);</span></span>
<span id="L274"><span class="lineNum">     274</span>              :     }</span>
<span id="L275"><span class="lineNum">     275</span>              : </span>
<span id="L276"><span class="lineNum">     276</span> <span class="tlaGNC">       12515 :     gst_tensors_config_free (&amp;config);</span></span>
<span id="L277"><span class="lineNum">     277</span> <span class="tlaGNC">       12515 :     if (found)</span></span>
<span id="L278"><span class="lineNum">     278</span> <span class="tlaGNC">       12508 :       break;</span></span>
<span id="L279"><span class="lineNum">     279</span>              :   }</span>
<span id="L280"><span class="lineNum">     280</span>              : </span>
<span id="L281"><span class="lineNum">     281</span> <span class="tlaGNC">       12514 :   return found;</span></span>
<span id="L282"><span class="lineNum">     282</span>              : }</span>
<span id="L283"><span class="lineNum">     283</span>              : </span>
<span id="L284"><span class="lineNum">     284</span>              : /**</span>
<span id="L285"><span class="lineNum">     285</span>              :  * @brief Handle a sink element for registered ml_pipeline_sink_cb</span>
<span id="L286"><span class="lineNum">     286</span>              :  */</span>
<span id="L287"><span class="lineNum">     287</span>              : static void</span>
<span id="L288"><span class="lineNum">     288</span> <span class="tlaGNC">        6289 : cb_sink_event (GstElement * e, GstBuffer * b, gpointer user_data)</span></span>
<span id="L289"><span class="lineNum">     289</span>              : {</span>
<span id="L290"><span class="lineNum">     290</span> <span class="tlaGNC">        6289 :   ml_pipeline_element *elem = user_data;</span></span>
<span id="L291"><span class="lineNum">     291</span>              : </span>
<span id="L292"><span class="lineNum">     292</span>              :   /** @todo CRITICAL if the pipeline is being killed, don't proceed! */</span>
<span id="L293"><span class="lineNum">     293</span>              :   GstMemory *mem[ML_TENSOR_SIZE_LIMIT];</span>
<span id="L294"><span class="lineNum">     294</span>              :   GstMapInfo map[ML_TENSOR_SIZE_LIMIT];</span>
<span id="L295"><span class="lineNum">     295</span>              :   guint i, num_tensors;</span>
<span id="L296"><span class="lineNum">     296</span>              :   GList *l;</span>
<span id="L297"><span class="lineNum">     297</span> <span class="tlaGNC">        6289 :   ml_tensors_data_s *_data = NULL;</span></span>
<span id="L298"><span class="lineNum">     298</span>              :   GstTensorsInfo gst_info;</span>
<span id="L299"><span class="lineNum">     299</span>              :   int status;</span>
<span id="L300"><span class="lineNum">     300</span>              : </span>
<span id="L301"><span class="lineNum">     301</span> <span class="tlaGNC">        6289 :   gst_tensors_info_init (&amp;gst_info);</span></span>
<span id="L302"><span class="lineNum">     302</span> <span class="tlaGNC">        6289 :   gst_info.num_tensors = num_tensors = gst_tensor_buffer_get_count (b);</span></span>
<span id="L303"><span class="lineNum">     303</span>              : </span>
<span id="L304"><span class="lineNum">     304</span>              :   /* Set tensor data. The handle for tensors-info in data should be added. */</span>
<span id="L305"><span class="lineNum">     305</span>              :   status =</span>
<span id="L306"><span class="lineNum">     306</span> <span class="tlaGNC">        6289 :       _ml_tensors_data_create_no_alloc (NULL, (ml_tensors_data_h *) &amp; _data);</span></span>
<span id="L307"><span class="lineNum">     307</span> <span class="tlaGNC">        6289 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L308"><span class="lineNum">     308</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_loge (_ml_detail</span></span>
<span id="L309"><span class="lineNum">     309</span>              :         (&quot;Failed to allocate memory for tensors data in sink callback, which is registered by ml_pipeline_sink_register ().&quot;));</span>
<span id="L310"><span class="lineNum">     310</span> <span class="tlaGNC tlaBgGNC">        6289 :     return;</span></span>
<span id="L311"><span class="lineNum">     311</span>              :   }</span>
<span id="L312"><span class="lineNum">     312</span>              : </span>
<span id="L313"><span class="lineNum">     313</span> <span class="tlaGNC">        6289 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L314"><span class="lineNum">     314</span>              : </span>
<span id="L315"><span class="lineNum">     315</span> <span class="tlaGNC">        6289 :   _data-&gt;num_tensors = num_tensors;</span></span>
<span id="L316"><span class="lineNum">     316</span> <span class="tlaGNC">       13055 :   for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L317"><span class="lineNum">     317</span> <span class="tlaGNC">        6766 :     mem[i] = gst_tensor_buffer_get_nth_memory (b, i);</span></span>
<span id="L318"><span class="lineNum">     318</span> <span class="tlaGNC">        6766 :     if (!gst_memory_map (mem[i], &amp;map[i], GST_MAP_READ)) {</span></span>
<span id="L319"><span class="lineNum">     319</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_loge (_ml_detail</span></span>
<span id="L320"><span class="lineNum">     320</span>              :           (&quot;Failed to map the output in sink '%s' callback, which is registered by ml_pipeline_sink_register ()&quot;,</span>
<span id="L321"><span class="lineNum">     321</span>              :               elem-&gt;name));</span>
<span id="L322"><span class="lineNum">     322</span> <span class="tlaUNC">           0 :       gst_memory_unref (mem[i]);</span></span>
<span id="L323"><span class="lineNum">     323</span> <span class="tlaUNC">           0 :       num_tensors = i;</span></span>
<span id="L324"><span class="lineNum">     324</span> <span class="tlaUNC">           0 :       goto error;</span></span>
<span id="L325"><span class="lineNum">     325</span>              :     }</span>
<span id="L326"><span class="lineNum">     326</span>              : </span>
<span id="L327"><span class="lineNum">     327</span> <span class="tlaGNC tlaBgGNC">        6766 :     _data-&gt;tensors[i].data = map[i].data;</span></span>
<span id="L328"><span class="lineNum">     328</span> <span class="tlaGNC">        6766 :     _data-&gt;tensors[i].size = map[i].size;</span></span>
<span id="L329"><span class="lineNum">     329</span>              :   }</span>
<span id="L330"><span class="lineNum">     330</span>              : </span>
<span id="L331"><span class="lineNum">     331</span>              :   /** @todo This assumes that padcap is static */</span>
<span id="L332"><span class="lineNum">     332</span> <span class="tlaGNC">        6289 :   if (elem-&gt;sink == NULL) {</span></span>
<span id="L333"><span class="lineNum">     333</span> <span class="tlaGNC">          28 :     gboolean found = FALSE;</span></span>
<span id="L334"><span class="lineNum">     334</span> <span class="tlaGNC">          28 :     gboolean flexible = FALSE;</span></span>
<span id="L335"><span class="lineNum">     335</span>              : </span>
<span id="L336"><span class="lineNum">     336</span>              :     /* Get the sink-pad-cap */</span>
<span id="L337"><span class="lineNum">     337</span> <span class="tlaGNC">          28 :     elem-&gt;sink = gst_element_get_static_pad (elem-&gt;element, &quot;sink&quot;);</span></span>
<span id="L338"><span class="lineNum">     338</span>              : </span>
<span id="L339"><span class="lineNum">     339</span> <span class="tlaGNC">          28 :     if (elem-&gt;sink) {</span></span>
<span id="L340"><span class="lineNum">     340</span>              :       /* sinkpadcap available (negotiated) */</span>
<span id="L341"><span class="lineNum">     341</span> <span class="tlaGNC">          28 :       GstCaps *caps = gst_pad_get_current_caps (elem-&gt;sink);</span></span>
<span id="L342"><span class="lineNum">     342</span>              : </span>
<span id="L343"><span class="lineNum">     343</span> <span class="tlaGNC">          28 :       if (caps) {</span></span>
<span id="L344"><span class="lineNum">     344</span> <span class="tlaGNC">          28 :         found = get_tensors_info_from_caps (caps, &amp;elem-&gt;tensors_info,</span></span>
<span id="L345"><span class="lineNum">     345</span>              :             &amp;flexible);</span>
<span id="L346"><span class="lineNum">     346</span> <span class="tlaGNC">          28 :         gst_caps_unref (caps);</span></span>
<span id="L347"><span class="lineNum">     347</span>              :       }</span>
<span id="L348"><span class="lineNum">     348</span>              :     }</span>
<span id="L349"><span class="lineNum">     349</span>              : </span>
<span id="L350"><span class="lineNum">     350</span> <span class="tlaGNC">          28 :     if (found) {</span></span>
<span id="L351"><span class="lineNum">     351</span> <span class="tlaGNC">          28 :       elem-&gt;is_flexible_tensor = flexible;</span></span>
<span id="L352"><span class="lineNum">     352</span>              :     } else {</span>
<span id="L353"><span class="lineNum">     353</span>              :       /* It is not valid */</span>
<span id="L354"><span class="lineNum">     354</span> <span class="tlaUNC tlaBgUNC">           0 :       if (elem-&gt;sink) {</span></span>
<span id="L355"><span class="lineNum">     355</span> <span class="tlaUNC">           0 :         gst_object_unref (elem-&gt;sink);</span></span>
<span id="L356"><span class="lineNum">     356</span> <span class="tlaUNC">           0 :         elem-&gt;sink = NULL;</span></span>
<span id="L357"><span class="lineNum">     357</span>              :       }</span>
<span id="L358"><span class="lineNum">     358</span>              : </span>
<span id="L359"><span class="lineNum">     359</span> <span class="tlaUNC">           0 :       goto error;</span></span>
<span id="L360"><span class="lineNum">     360</span>              :     }</span>
<span id="L361"><span class="lineNum">     361</span>              :   }</span>
<span id="L362"><span class="lineNum">     362</span>              : </span>
<span id="L363"><span class="lineNum">     363</span>              :   /* Prepare output and set data. */</span>
<span id="L364"><span class="lineNum">     364</span> <span class="tlaGNC tlaBgGNC">        6289 :   if (elem-&gt;is_flexible_tensor) {</span></span>
<span id="L365"><span class="lineNum">     365</span>              :     GstTensorMetaInfo meta;</span>
<span id="L366"><span class="lineNum">     366</span>              :     gsize hsize;</span>
<span id="L367"><span class="lineNum">     367</span>              : </span>
<span id="L368"><span class="lineNum">     368</span>              :     /* handle header for flex tensor */</span>
<span id="L369"><span class="lineNum">     369</span> <span class="tlaGNC">          12 :     for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L370"><span class="lineNum">     370</span> <span class="tlaGNC">           9 :       gst_tensor_meta_info_parse_header (&amp;meta, map[i].data);</span></span>
<span id="L371"><span class="lineNum">     371</span> <span class="tlaGNC">           9 :       hsize = gst_tensor_meta_info_get_header_size (&amp;meta);</span></span>
<span id="L372"><span class="lineNum">     372</span>              : </span>
<span id="L373"><span class="lineNum">     373</span> <span class="tlaGNC">           9 :       gst_tensor_meta_info_convert (&amp;meta,</span></span>
<span id="L374"><span class="lineNum">     374</span>              :           gst_tensors_info_get_nth_info (&amp;gst_info, i));</span>
<span id="L375"><span class="lineNum">     375</span>              : </span>
<span id="L376"><span class="lineNum">     376</span> <span class="tlaGNC">           9 :       _data-&gt;tensors[i].data = map[i].data + hsize;</span></span>
<span id="L377"><span class="lineNum">     377</span> <span class="tlaGNC">           9 :       _data-&gt;tensors[i].size = map[i].size - hsize;</span></span>
<span id="L378"><span class="lineNum">     378</span>              :     }</span>
<span id="L379"><span class="lineNum">     379</span>              :   } else {</span>
<span id="L380"><span class="lineNum">     380</span> <span class="tlaGNC">        6286 :     gst_tensors_info_copy (&amp;gst_info, &amp;elem-&gt;tensors_info);</span></span>
<span id="L381"><span class="lineNum">     381</span>              : </span>
<span id="L382"><span class="lineNum">     382</span>              :     /* Compare output info and buffer if gst-buffer is not flexible. */</span>
<span id="L383"><span class="lineNum">     383</span> <span class="tlaGNC">        6286 :     if (gst_info.num_tensors != num_tensors) {</span></span>
<span id="L384"><span class="lineNum">     384</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_loge (_ml_detail</span></span>
<span id="L385"><span class="lineNum">     385</span>              :           (&quot;The sink event of [%s] cannot be handled because the number of tensors mismatches.&quot;,</span>
<span id="L386"><span class="lineNum">     386</span>              :               elem-&gt;name));</span>
<span id="L387"><span class="lineNum">     387</span>              : </span>
<span id="L388"><span class="lineNum">     388</span> <span class="tlaUNC">           0 :       gst_object_unref (elem-&gt;sink);</span></span>
<span id="L389"><span class="lineNum">     389</span> <span class="tlaUNC">           0 :       elem-&gt;sink = NULL;</span></span>
<span id="L390"><span class="lineNum">     390</span> <span class="tlaUNC">           0 :       goto error;</span></span>
<span id="L391"><span class="lineNum">     391</span>              :     }</span>
<span id="L392"><span class="lineNum">     392</span>              : </span>
<span id="L393"><span class="lineNum">     393</span> <span class="tlaGNC tlaBgGNC">       13043 :     for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L394"><span class="lineNum">     394</span> <span class="tlaGNC">        6757 :       size_t sz = gst_tensors_info_get_size (&amp;gst_info, i);</span></span>
<span id="L395"><span class="lineNum">     395</span>              : </span>
<span id="L396"><span class="lineNum">     396</span>              :       /* Not configured, yet. */</span>
<span id="L397"><span class="lineNum">     397</span> <span class="tlaGNC">        6757 :       if (sz == 0)</span></span>
<span id="L398"><span class="lineNum">     398</span> <span class="tlaUNC tlaBgUNC">           0 :         _ml_loge (_ml_detail</span></span>
<span id="L399"><span class="lineNum">     399</span>              :             (&quot;The caps for sink(%s) is not configured.&quot;, elem-&gt;name));</span>
<span id="L400"><span class="lineNum">     400</span>              : </span>
<span id="L401"><span class="lineNum">     401</span> <span class="tlaGNC tlaBgGNC">        6757 :       if (sz != map[i].size) {</span></span>
<span id="L402"><span class="lineNum">     402</span> <span class="tlaUNC tlaBgUNC">           0 :         _ml_loge (_ml_detail</span></span>
<span id="L403"><span class="lineNum">     403</span>              :             (&quot;The sink event of [%s] cannot be handled because the tensor dimension mismatches.&quot;,</span>
<span id="L404"><span class="lineNum">     404</span>              :                 elem-&gt;name));</span>
<span id="L405"><span class="lineNum">     405</span>              : </span>
<span id="L406"><span class="lineNum">     406</span> <span class="tlaUNC">           0 :         gst_object_unref (elem-&gt;sink);</span></span>
<span id="L407"><span class="lineNum">     407</span> <span class="tlaUNC">           0 :         elem-&gt;sink = NULL;</span></span>
<span id="L408"><span class="lineNum">     408</span> <span class="tlaUNC">           0 :         goto error;</span></span>
<span id="L409"><span class="lineNum">     409</span>              :       }</span>
<span id="L410"><span class="lineNum">     410</span>              :     }</span>
<span id="L411"><span class="lineNum">     411</span>              :   }</span>
<span id="L412"><span class="lineNum">     412</span>              : </span>
<span id="L413"><span class="lineNum">     413</span>              :   /* Create new output info, data handle should be updated here. */</span>
<span id="L414"><span class="lineNum">     414</span> <span class="tlaGNC tlaBgGNC">        6289 :   _ml_tensors_info_create_from_gst (&amp;_data-&gt;info, &amp;gst_info);</span></span>
<span id="L415"><span class="lineNum">     415</span>              : </span>
<span id="L416"><span class="lineNum">     416</span>              :   /* Iterate e-&gt;handles, pass the data to them */</span>
<span id="L417"><span class="lineNum">     417</span> <span class="tlaGNC">       12584 :   for (l = elem-&gt;handles; l != NULL; l = l-&gt;next) {</span></span>
<span id="L418"><span class="lineNum">     418</span>              :     ml_pipeline_sink_cb callback;</span>
<span id="L419"><span class="lineNum">     419</span> <span class="tlaGNC">        6295 :     ml_pipeline_common_elem *sink = l-&gt;data;</span></span>
<span id="L420"><span class="lineNum">     420</span> <span class="tlaGNC">        6295 :     if (sink-&gt;callback_info == NULL)</span></span>
<span id="L421"><span class="lineNum">     421</span> <span class="tlaGNC">           3 :       continue;</span></span>
<span id="L422"><span class="lineNum">     422</span>              : </span>
<span id="L423"><span class="lineNum">     423</span> <span class="tlaGNC">        6292 :     callback = sink-&gt;callback_info-&gt;sink_cb;</span></span>
<span id="L424"><span class="lineNum">     424</span> <span class="tlaGNC">        6292 :     if (callback)</span></span>
<span id="L425"><span class="lineNum">     425</span> <span class="tlaGNC">        6292 :       callback (_data, _data-&gt;info, sink-&gt;callback_info-&gt;sink_pdata);</span></span>
<span id="L426"><span class="lineNum">     426</span>              : </span>
<span id="L427"><span class="lineNum">     427</span>              :     /** @todo Measure time. Warn if it takes long. Kill if it takes too long. */</span>
<span id="L428"><span class="lineNum">     428</span>              :   }</span>
<span id="L429"><span class="lineNum">     429</span>              : </span>
<span id="L430"><span class="lineNum">     430</span> <span class="tlaGNC">        6289 : error:</span></span>
<span id="L431"><span class="lineNum">     431</span> <span class="tlaGNC">        6289 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L432"><span class="lineNum">     432</span>              : </span>
<span id="L433"><span class="lineNum">     433</span> <span class="tlaGNC">       13055 :   for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L434"><span class="lineNum">     434</span> <span class="tlaGNC">        6766 :     gst_memory_unmap (mem[i], &amp;map[i]);</span></span>
<span id="L435"><span class="lineNum">     435</span> <span class="tlaGNC">        6766 :     gst_memory_unref (mem[i]);</span></span>
<span id="L436"><span class="lineNum">     436</span>              :   }</span>
<span id="L437"><span class="lineNum">     437</span>              : </span>
<span id="L438"><span class="lineNum">     438</span> <span class="tlaGNC">        6289 :   _ml_tensors_data_destroy_internal (_data, FALSE);</span></span>
<span id="L439"><span class="lineNum">     439</span> <span class="tlaGNC">        6289 :   _data = NULL;</span></span>
<span id="L440"><span class="lineNum">     440</span>              : </span>
<span id="L441"><span class="lineNum">     441</span> <span class="tlaGNC">        6289 :   gst_tensors_info_free (&amp;gst_info);</span></span>
<span id="L442"><span class="lineNum">     442</span> <span class="tlaGNC">        6289 :   return;</span></span>
<span id="L443"><span class="lineNum">     443</span>              : }</span>
<span id="L444"><span class="lineNum">     444</span>              : </span>
<span id="L445"><span class="lineNum">     445</span>              : /**</span>
<span id="L446"><span class="lineNum">     446</span>              :  * @brief Handle a appsink element for registered ml_pipeline_sink_cb</span>
<span id="L447"><span class="lineNum">     447</span>              :  */</span>
<span id="L448"><span class="lineNum">     448</span>              : static GstFlowReturn</span>
<span id="L449"><span class="lineNum">     449</span> <span class="tlaGNC">           9 : cb_appsink_new_sample (GstElement * e, gpointer user_data)</span></span>
<span id="L450"><span class="lineNum">     450</span>              : {</span>
<span id="L451"><span class="lineNum">     451</span>              :   GstSample *sample;</span>
<span id="L452"><span class="lineNum">     452</span>              :   GstBuffer *buffer;</span>
<span id="L453"><span class="lineNum">     453</span>              : </span>
<span id="L454"><span class="lineNum">     454</span>              :   /* get the sample from appsink */</span>
<span id="L455"><span class="lineNum">     455</span> <span class="tlaGNC">           9 :   sample = gst_app_sink_pull_sample (GST_APP_SINK (e));</span></span>
<span id="L456"><span class="lineNum">     456</span> <span class="tlaGNC">           9 :   buffer = gst_sample_get_buffer (sample);</span></span>
<span id="L457"><span class="lineNum">     457</span>              : </span>
<span id="L458"><span class="lineNum">     458</span> <span class="tlaGNC">           9 :   cb_sink_event (e, buffer, user_data);</span></span>
<span id="L459"><span class="lineNum">     459</span>              : </span>
<span id="L460"><span class="lineNum">     460</span> <span class="tlaGNC">           9 :   gst_sample_unref (sample);</span></span>
<span id="L461"><span class="lineNum">     461</span> <span class="tlaGNC">           9 :   return GST_FLOW_OK;</span></span>
<span id="L462"><span class="lineNum">     462</span>              : }</span>
<span id="L463"><span class="lineNum">     463</span>              : </span>
<span id="L464"><span class="lineNum">     464</span>              : /**</span>
<span id="L465"><span class="lineNum">     465</span>              :  * @brief Callback for bus message.</span>
<span id="L466"><span class="lineNum">     466</span>              :  */</span>
<span id="L467"><span class="lineNum">     467</span>              : static void</span>
<span id="L468"><span class="lineNum">     468</span> <span class="tlaGNC">        5402 : cb_bus_sync_message (GstBus * bus, GstMessage * message, gpointer user_data)</span></span>
<span id="L469"><span class="lineNum">     469</span>              : {</span>
<span id="L470"><span class="lineNum">     470</span>              :   ml_pipeline *pipe_h;</span>
<span id="L471"><span class="lineNum">     471</span>              : </span>
<span id="L472"><span class="lineNum">     472</span> <span class="tlaGNC">        5402 :   pipe_h = (ml_pipeline *) user_data;</span></span>
<span id="L473"><span class="lineNum">     473</span>              : </span>
<span id="L474"><span class="lineNum">     474</span> <span class="tlaGNC">        5402 :   if (pipe_h == NULL)</span></span>
<span id="L475"><span class="lineNum">     475</span> <span class="tlaUNC tlaBgUNC">           0 :     return;</span></span>
<span id="L476"><span class="lineNum">     476</span>              : </span>
<span id="L477"><span class="lineNum">     477</span> <span class="tlaGNC tlaBgGNC">        5402 :   switch (GST_MESSAGE_TYPE (message)) {</span></span>
<span id="L478"><span class="lineNum">     478</span> <span class="tlaGNC">           7 :     case GST_MESSAGE_EOS:</span></span>
<span id="L479"><span class="lineNum">     479</span> <span class="tlaGNC">           7 :       pipe_h-&gt;isEOS = TRUE;</span></span>
<span id="L480"><span class="lineNum">     480</span> <span class="tlaGNC">           7 :       break;</span></span>
<span id="L481"><span class="lineNum">     481</span> <span class="tlaGNC">        4391 :     case GST_MESSAGE_STATE_CHANGED:</span></span>
<span id="L482"><span class="lineNum">     482</span> <span class="tlaGNC">        4391 :       if (GST_MESSAGE_SRC (message) == GST_OBJECT_CAST (pipe_h-&gt;element)) {</span></span>
<span id="L483"><span class="lineNum">     483</span>              :         GstState old_state, new_state;</span>
<span id="L484"><span class="lineNum">     484</span>              : </span>
<span id="L485"><span class="lineNum">     485</span> <span class="tlaGNC">         507 :         gst_message_parse_state_changed (message, &amp;old_state, &amp;new_state, NULL);</span></span>
<span id="L486"><span class="lineNum">     486</span> <span class="tlaGNC">         507 :         pipe_h-&gt;pipe_state = (ml_pipeline_state_e) new_state;</span></span>
<span id="L487"><span class="lineNum">     487</span>              : </span>
<span id="L488"><span class="lineNum">     488</span> <span class="tlaGNC">         507 :         _ml_logd (_ml_detail (&quot;The pipeline state changed from %s to %s.&quot;,</span></span>
<span id="L489"><span class="lineNum">     489</span>              :                 gst_element_state_get_name (old_state),</span>
<span id="L490"><span class="lineNum">     490</span>              :                 gst_element_state_get_name (new_state)));</span>
<span id="L491"><span class="lineNum">     491</span>              : </span>
<span id="L492"><span class="lineNum">     492</span> <span class="tlaGNC">         507 :         if (pipe_h-&gt;state_cb.cb) {</span></span>
<span id="L493"><span class="lineNum">     493</span> <span class="tlaGNC">          11 :           pipe_h-&gt;state_cb.cb (pipe_h-&gt;pipe_state, pipe_h-&gt;state_cb.user_data);</span></span>
<span id="L494"><span class="lineNum">     494</span>              :         }</span>
<span id="L495"><span class="lineNum">     495</span>              :       }</span>
<span id="L496"><span class="lineNum">     496</span> <span class="tlaGNC">        4391 :       break;</span></span>
<span id="L497"><span class="lineNum">     497</span> <span class="tlaGNC">        1004 :     default:</span></span>
<span id="L498"><span class="lineNum">     498</span> <span class="tlaGNC">        1004 :       break;</span></span>
<span id="L499"><span class="lineNum">     499</span>              :   }</span>
<span id="L500"><span class="lineNum">     500</span>              : }</span>
<span id="L501"><span class="lineNum">     501</span>              : </span>
<span id="L502"><span class="lineNum">     502</span>              : /**</span>
<span id="L503"><span class="lineNum">     503</span>              :  * @brief Clean up each element of the pipeline.</span>
<span id="L504"><span class="lineNum">     504</span>              :  */</span>
<span id="L505"><span class="lineNum">     505</span>              : static void</span>
<span id="L506"><span class="lineNum">     506</span> <span class="tlaGNC">         151 : free_element_handle (gpointer data)</span></span>
<span id="L507"><span class="lineNum">     507</span>              : {</span>
<span id="L508"><span class="lineNum">     508</span> <span class="tlaGNC">         151 :   ml_pipeline_common_elem *item = (ml_pipeline_common_elem *) data;</span></span>
<span id="L509"><span class="lineNum">     509</span>              :   ml_pipeline_element *elem;</span>
<span id="L510"><span class="lineNum">     510</span>              : </span>
<span id="L511"><span class="lineNum">     511</span> <span class="tlaGNC">         151 :   if (!(item &amp;&amp; item-&gt;callback_info)) {</span></span>
<span id="L512"><span class="lineNum">     512</span> <span class="tlaGNC">         109 :     g_free (item);</span></span>
<span id="L513"><span class="lineNum">     513</span> <span class="tlaGNC">         109 :     return;</span></span>
<span id="L514"><span class="lineNum">     514</span>              :   }</span>
<span id="L515"><span class="lineNum">     515</span>              : </span>
<span id="L516"><span class="lineNum">     516</span>              :   /* clear callbacks */</span>
<span id="L517"><span class="lineNum">     517</span> <span class="tlaGNC">          42 :   item-&gt;callback_info-&gt;sink_cb = NULL;</span></span>
<span id="L518"><span class="lineNum">     518</span> <span class="tlaGNC">          42 :   elem = item-&gt;element;</span></span>
<span id="L519"><span class="lineNum">     519</span> <span class="tlaGNC">          42 :   if (elem-&gt;type == ML_PIPELINE_ELEMENT_APP_SRC) {</span></span>
<span id="L520"><span class="lineNum">     520</span> <span class="tlaGNC">           2 :     GstAppSrcCallbacks appsrc_cb = { 0, };</span></span>
<span id="L521"><span class="lineNum">     521</span> <span class="tlaGNC">           2 :     gst_app_src_set_callbacks (GST_APP_SRC (elem-&gt;element), &amp;appsrc_cb,</span></span>
<span id="L522"><span class="lineNum">     522</span>              :         NULL, NULL);</span>
<span id="L523"><span class="lineNum">     523</span>              :   }</span>
<span id="L524"><span class="lineNum">     524</span>              : </span>
<span id="L525"><span class="lineNum">     525</span> <span class="tlaGNC">          42 :   g_free (item-&gt;callback_info);</span></span>
<span id="L526"><span class="lineNum">     526</span> <span class="tlaGNC">          42 :   item-&gt;callback_info = NULL;</span></span>
<span id="L527"><span class="lineNum">     527</span> <span class="tlaGNC">          42 :   g_free (item);</span></span>
<span id="L528"><span class="lineNum">     528</span>              : }</span>
<span id="L529"><span class="lineNum">     529</span>              : </span>
<span id="L530"><span class="lineNum">     530</span>              : /**</span>
<span id="L531"><span class="lineNum">     531</span>              :  * @brief Private function for ml_pipeline_destroy, cleaning up nodes in namednodes</span>
<span id="L532"><span class="lineNum">     532</span>              :  */</span>
<span id="L533"><span class="lineNum">     533</span>              : static void</span>
<span id="L534"><span class="lineNum">     534</span> <span class="tlaGNC">         394 : cleanup_node (gpointer data)</span></span>
<span id="L535"><span class="lineNum">     535</span>              : {</span>
<span id="L536"><span class="lineNum">     536</span> <span class="tlaGNC">         394 :   ml_pipeline_element *e = data;</span></span>
<span id="L537"><span class="lineNum">     537</span>              : </span>
<span id="L538"><span class="lineNum">     538</span> <span class="tlaGNC">         394 :   g_mutex_lock (&amp;e-&gt;lock);</span></span>
<span id="L539"><span class="lineNum">     539</span>              :   /** @todo CRITICAL. Stop the handle callbacks if they are running/ready */</span>
<span id="L540"><span class="lineNum">     540</span> <span class="tlaGNC">         394 :   if (e-&gt;handle_id &gt; 0) {</span></span>
<span id="L541"><span class="lineNum">     541</span> <span class="tlaGNC">          27 :     g_signal_handler_disconnect (e-&gt;element, e-&gt;handle_id);</span></span>
<span id="L542"><span class="lineNum">     542</span> <span class="tlaGNC">          27 :     e-&gt;handle_id = 0;</span></span>
<span id="L543"><span class="lineNum">     543</span>              :   }</span>
<span id="L544"><span class="lineNum">     544</span>              : </span>
<span id="L545"><span class="lineNum">     545</span>              :   /* clear all handles first */</span>
<span id="L546"><span class="lineNum">     546</span> <span class="tlaGNC">         394 :   if (e-&gt;handles)</span></span>
<span id="L547"><span class="lineNum">     547</span> <span class="tlaGNC">          63 :     g_list_free_full (e-&gt;handles, free_element_handle);</span></span>
<span id="L548"><span class="lineNum">     548</span> <span class="tlaGNC">         394 :   e-&gt;handles = NULL;</span></span>
<span id="L549"><span class="lineNum">     549</span>              : </span>
<span id="L550"><span class="lineNum">     550</span> <span class="tlaGNC">         394 :   if (e-&gt;type == ML_PIPELINE_ELEMENT_APP_SRC &amp;&amp; !e-&gt;pipe-&gt;isEOS) {</span></span>
<span id="L551"><span class="lineNum">     551</span> <span class="tlaGNC">          55 :     int eos_check_cnt = 0;</span></span>
<span id="L552"><span class="lineNum">     552</span>              : </span>
<span id="L553"><span class="lineNum">     553</span>              :     /** to push EOS event, the pipeline should be in PAUSED state */</span>
<span id="L554"><span class="lineNum">     554</span> <span class="tlaGNC">          55 :     gst_element_set_state (e-&gt;pipe-&gt;element, GST_STATE_PAUSED);</span></span>
<span id="L555"><span class="lineNum">     555</span>              : </span>
<span id="L556"><span class="lineNum">     556</span> <span class="tlaGNC">          55 :     if (gst_app_src_end_of_stream (GST_APP_SRC (e-&gt;element)) != GST_FLOW_OK) {</span></span>
<span id="L557"><span class="lineNum">     557</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_logw (_ml_detail</span></span>
<span id="L558"><span class="lineNum">     558</span>              :           (&quot;Cleaning up a pipeline has failed to set End-Of-Stream for the pipeline element of %s&quot;,</span>
<span id="L559"><span class="lineNum">     559</span>              :               e-&gt;name));</span>
<span id="L560"><span class="lineNum">     560</span>              :     }</span>
<span id="L561"><span class="lineNum">     561</span> <span class="tlaGNC tlaBgGNC">          55 :     g_mutex_unlock (&amp;e-&gt;lock);</span></span>
<span id="L562"><span class="lineNum">     562</span> <span class="tlaGNC">        5500 :     while (!e-&gt;pipe-&gt;isEOS) {</span></span>
<span id="L563"><span class="lineNum">     563</span> <span class="tlaGNC">        5500 :       eos_check_cnt++;</span></span>
<span id="L564"><span class="lineNum">     564</span>              :       /** check EOS every 1ms */</span>
<span id="L565"><span class="lineNum">     565</span> <span class="tlaGNC">        5500 :       g_usleep (1000);</span></span>
<span id="L566"><span class="lineNum">     566</span> <span class="tlaGNC">        5500 :       if (eos_check_cnt &gt;= EOS_MESSAGE_TIME_LIMIT) {</span></span>
<span id="L567"><span class="lineNum">     567</span> <span class="tlaGNC">          55 :         _ml_loge (_ml_detail</span></span>
<span id="L568"><span class="lineNum">     568</span>              :             (&quot;Cleaning up a pipeline has requested to set End-Of-Stream. However, the pipeline has not become EOS after the timeout. It has failed to become EOS with the element of %s.&quot;,</span>
<span id="L569"><span class="lineNum">     569</span>              :                 e-&gt;name));</span>
<span id="L570"><span class="lineNum">     570</span> <span class="tlaGNC">          55 :         break;</span></span>
<span id="L571"><span class="lineNum">     571</span>              :       }</span>
<span id="L572"><span class="lineNum">     572</span>              :     }</span>
<span id="L573"><span class="lineNum">     573</span> <span class="tlaGNC">          55 :     g_mutex_lock (&amp;e-&gt;lock);</span></span>
<span id="L574"><span class="lineNum">     574</span>              :   }</span>
<span id="L575"><span class="lineNum">     575</span>              : </span>
<span id="L576"><span class="lineNum">     576</span> <span class="tlaGNC">         394 :   if (e-&gt;custom_destroy) {</span></span>
<span id="L577"><span class="lineNum">     577</span> <span class="tlaGNC">           6 :     e-&gt;custom_destroy (e-&gt;custom_data, e);</span></span>
<span id="L578"><span class="lineNum">     578</span>              :   }</span>
<span id="L579"><span class="lineNum">     579</span>              : </span>
<span id="L580"><span class="lineNum">     580</span> <span class="tlaGNC">         394 :   g_free (e-&gt;name);</span></span>
<span id="L581"><span class="lineNum">     581</span> <span class="tlaGNC">         394 :   if (e-&gt;src)</span></span>
<span id="L582"><span class="lineNum">     582</span> <span class="tlaGNC">          41 :     gst_object_unref (e-&gt;src);</span></span>
<span id="L583"><span class="lineNum">     583</span> <span class="tlaGNC">         394 :   if (e-&gt;sink)</span></span>
<span id="L584"><span class="lineNum">     584</span> <span class="tlaGNC">          28 :     gst_object_unref (e-&gt;sink);</span></span>
<span id="L585"><span class="lineNum">     585</span>              : </span>
<span id="L586"><span class="lineNum">     586</span> <span class="tlaGNC">         394 :   gst_object_unref (e-&gt;element);</span></span>
<span id="L587"><span class="lineNum">     587</span>              : </span>
<span id="L588"><span class="lineNum">     588</span> <span class="tlaGNC">         394 :   gst_tensors_info_free (&amp;e-&gt;tensors_info);</span></span>
<span id="L589"><span class="lineNum">     589</span>              : </span>
<span id="L590"><span class="lineNum">     590</span> <span class="tlaGNC">         394 :   g_mutex_unlock (&amp;e-&gt;lock);</span></span>
<span id="L591"><span class="lineNum">     591</span> <span class="tlaGNC">         394 :   g_mutex_clear (&amp;e-&gt;lock);</span></span>
<span id="L592"><span class="lineNum">     592</span>              : </span>
<span id="L593"><span class="lineNum">     593</span> <span class="tlaGNC">         394 :   g_free (e);</span></span>
<span id="L594"><span class="lineNum">     594</span> <span class="tlaGNC">         394 : }</span></span>
<span id="L595"><span class="lineNum">     595</span>              : </span>
<span id="L596"><span class="lineNum">     596</span>              : /**</span>
<span id="L597"><span class="lineNum">     597</span>              :  * @brief Private function to release the pipeline resources</span>
<span id="L598"><span class="lineNum">     598</span>              :  */</span>
<span id="L599"><span class="lineNum">     599</span>              : static void</span>
<span id="L600"><span class="lineNum">     600</span> <span class="tlaUNC tlaBgUNC">           0 : cleanup_resource (gpointer data)</span></span>
<span id="L601"><span class="lineNum">     601</span>              : {</span>
<span id="L602"><span class="lineNum">     602</span> <span class="tlaUNC">           0 :   pipeline_resource_s *res = data;</span></span>
<span id="L603"><span class="lineNum">     603</span>              : </span>
<span id="L604"><span class="lineNum">     604</span>              :   /* check resource type and free data */</span>
<span id="L605"><span class="lineNum">     605</span> <span class="tlaUNC">           0 :   if (g_str_has_prefix (res-&gt;type, &quot;tizen&quot;)) {</span></span>
<span id="L606"><span class="lineNum">     606</span> <span class="tlaUNC">           0 :     release_tizen_resource (res-&gt;handle, res-&gt;type);</span></span>
<span id="L607"><span class="lineNum">     607</span>              :   }</span>
<span id="L608"><span class="lineNum">     608</span>              : </span>
<span id="L609"><span class="lineNum">     609</span> <span class="tlaUNC">           0 :   g_free (res-&gt;type);</span></span>
<span id="L610"><span class="lineNum">     610</span> <span class="tlaUNC">           0 :   g_free (res);</span></span>
<span id="L611"><span class="lineNum">     611</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L612"><span class="lineNum">     612</span>              : </span>
<span id="L613"><span class="lineNum">     613</span>              : /**</span>
<span id="L614"><span class="lineNum">     614</span>              :  * @brief Converts predefined element in pipeline description.</span>
<span id="L615"><span class="lineNum">     615</span>              :  */</span>
<span id="L616"><span class="lineNum">     616</span>              : static int</span>
<span id="L617"><span class="lineNum">     617</span> <span class="tlaGNC tlaBgGNC">         148 : convert_description (ml_pipeline_h pipe, const gchar * description,</span></span>
<span id="L618"><span class="lineNum">     618</span>              :     gchar ** result, gboolean is_internal)</span>
<span id="L619"><span class="lineNum">     619</span>              : {</span>
<span id="L620"><span class="lineNum">     620</span>              :   gchar *converted;</span>
<span id="L621"><span class="lineNum">     621</span> <span class="tlaGNC">         148 :   int status = ML_ERROR_NONE;</span></span>
<span id="L622"><span class="lineNum">     622</span>              : </span>
<span id="L623"><span class="lineNum">     623</span> <span class="tlaGNC">         296 :   g_return_val_if_fail (pipe, ML_ERROR_INVALID_PARAMETER);</span></span>
<span id="L624"><span class="lineNum">     624</span> <span class="tlaGNC">         148 :   g_return_val_if_fail (description &amp;&amp; result, ML_ERROR_INVALID_PARAMETER);</span></span>
<span id="L625"><span class="lineNum">     625</span>              : </span>
<span id="L626"><span class="lineNum">     626</span>              :   /* init null */</span>
<span id="L627"><span class="lineNum">     627</span> <span class="tlaGNC">         148 :   *result = NULL;</span></span>
<span id="L628"><span class="lineNum">     628</span>              : </span>
<span id="L629"><span class="lineNum">     629</span> <span class="tlaGNC">         148 :   converted = _ml_convert_predefined_entity (description);</span></span>
<span id="L630"><span class="lineNum">     630</span>              : </span>
<span id="L631"><span class="lineNum">     631</span>              :   /* convert pre-defined element for Tizen */</span>
<span id="L632"><span class="lineNum">     632</span> <span class="tlaGNC">         148 :   status = convert_tizen_element (pipe, &amp;converted, is_internal);</span></span>
<span id="L633"><span class="lineNum">     633</span>              : </span>
<span id="L634"><span class="lineNum">     634</span> <span class="tlaGNC">         148 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L635"><span class="lineNum">     635</span> <span class="tlaGNC">         148 :     _ml_logd (_ml_detail</span></span>
<span id="L636"><span class="lineNum">     636</span>              :         (&quot;Pipeline element converted with aliases for gstreamer (Tizen element aliases): %s&quot;,</span>
<span id="L637"><span class="lineNum">     637</span>              :             converted));</span>
<span id="L638"><span class="lineNum">     638</span> <span class="tlaGNC">         148 :     *result = converted;</span></span>
<span id="L639"><span class="lineNum">     639</span>              :   } else {</span>
<span id="L640"><span class="lineNum">     640</span> <span class="tlaUNC tlaBgUNC">           0 :     g_free (converted);</span></span>
<span id="L641"><span class="lineNum">     641</span> <span class="tlaUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L642"><span class="lineNum">     642</span>              :         (&quot;Failed to convert element: convert_tizen_element() returned %d&quot;,</span>
<span id="L643"><span class="lineNum">     643</span>              :         status);</span>
<span id="L644"><span class="lineNum">     644</span>              :   }</span>
<span id="L645"><span class="lineNum">     645</span>              : </span>
<span id="L646"><span class="lineNum">     646</span> <span class="tlaGNC tlaBgGNC">         148 :   return status;</span></span>
<span id="L647"><span class="lineNum">     647</span>              : }</span>
<span id="L648"><span class="lineNum">     648</span>              : </span>
<span id="L649"><span class="lineNum">     649</span>              : /**</span>
<span id="L650"><span class="lineNum">     650</span>              :  * @brief Handle tensor-filter options.</span>
<span id="L651"><span class="lineNum">     651</span>              :  */</span>
<span id="L652"><span class="lineNum">     652</span>              : static void</span>
<span id="L653"><span class="lineNum">     653</span> <span class="tlaGNC">          39 : process_tensor_filter_option (ml_pipeline_element * e)</span></span>
<span id="L654"><span class="lineNum">     654</span>              : {</span>
<span id="L655"><span class="lineNum">     655</span> <span class="tlaGNC">          39 :   gchar *fw = NULL;</span></span>
<span id="L656"><span class="lineNum">     656</span> <span class="tlaGNC">          39 :   gchar *model = NULL;</span></span>
<span id="L657"><span class="lineNum">     657</span>              :   pipe_custom_data_s *custom_data;</span>
<span id="L658"><span class="lineNum">     658</span>              : </span>
<span id="L659"><span class="lineNum">     659</span> <span class="tlaGNC">          39 :   g_object_get (G_OBJECT (e-&gt;element), &quot;framework&quot;, &amp;fw, &quot;model&quot;, &amp;model, NULL);</span></span>
<span id="L660"><span class="lineNum">     660</span>              : </span>
<span id="L661"><span class="lineNum">     661</span> <span class="tlaGNC">          39 :   if (fw &amp;&amp; g_ascii_strcasecmp (fw, &quot;custom-easy&quot;) == 0) {</span></span>
<span id="L662"><span class="lineNum">     662</span>              :     /* ref to tensor-filter custom-easy handle. */</span>
<span id="L663"><span class="lineNum">     663</span> <span class="tlaGNC">           3 :     custom_data = pipe_custom_find_data (PIPE_CUSTOM_TYPE_FILTER, model);</span></span>
<span id="L664"><span class="lineNum">     664</span> <span class="tlaGNC">           3 :     if (custom_data) {</span></span>
<span id="L665"><span class="lineNum">     665</span> <span class="tlaGNC">           3 :       ml_pipeline_custom_filter_ref (custom_data-&gt;handle);</span></span>
<span id="L666"><span class="lineNum">     666</span>              : </span>
<span id="L667"><span class="lineNum">     667</span> <span class="tlaGNC">           3 :       e-&gt;custom_destroy = pipe_custom_destroy_cb;</span></span>
<span id="L668"><span class="lineNum">     668</span> <span class="tlaGNC">           3 :       e-&gt;custom_data = custom_data;</span></span>
<span id="L669"><span class="lineNum">     669</span>              :     }</span>
<span id="L670"><span class="lineNum">     670</span>              :   }</span>
<span id="L671"><span class="lineNum">     671</span>              : </span>
<span id="L672"><span class="lineNum">     672</span> <span class="tlaGNC">          39 :   g_free (fw);</span></span>
<span id="L673"><span class="lineNum">     673</span> <span class="tlaGNC">          39 :   g_free (model);</span></span>
<span id="L674"><span class="lineNum">     674</span> <span class="tlaGNC">          39 : }</span></span>
<span id="L675"><span class="lineNum">     675</span>              : </span>
<span id="L676"><span class="lineNum">     676</span>              : /**</span>
<span id="L677"><span class="lineNum">     677</span>              :  * @brief Handle tensor-if options.</span>
<span id="L678"><span class="lineNum">     678</span>              :  */</span>
<span id="L679"><span class="lineNum">     679</span>              : static void</span>
<span id="L680"><span class="lineNum">     680</span> <span class="tlaGNC">           3 : process_tensor_if_option (ml_pipeline_element * e)</span></span>
<span id="L681"><span class="lineNum">     681</span>              : {</span>
<span id="L682"><span class="lineNum">     682</span> <span class="tlaGNC">           3 :   gint cv = 0;</span></span>
<span id="L683"><span class="lineNum">     683</span> <span class="tlaGNC">           3 :   gchar *cv_option = NULL;</span></span>
<span id="L684"><span class="lineNum">     684</span>              :   pipe_custom_data_s *custom_data;</span>
<span id="L685"><span class="lineNum">     685</span>              : </span>
<span id="L686"><span class="lineNum">     686</span> <span class="tlaGNC">           3 :   g_object_get (G_OBJECT (e-&gt;element), &quot;compared-value&quot;, &amp;cv,</span></span>
<span id="L687"><span class="lineNum">     687</span>              :       &quot;compared-value-option&quot;, &amp;cv_option, NULL);</span>
<span id="L688"><span class="lineNum">     688</span>              : </span>
<span id="L689"><span class="lineNum">     689</span> <span class="tlaGNC">           3 :   if (cv == 5) {</span></span>
<span id="L690"><span class="lineNum">     690</span>              :     /* cv is TIFCV_CUSTOM, ref to tensor-if custom handle. */</span>
<span id="L691"><span class="lineNum">     691</span> <span class="tlaGNC">           3 :     custom_data = pipe_custom_find_data (PIPE_CUSTOM_TYPE_IF, cv_option);</span></span>
<span id="L692"><span class="lineNum">     692</span> <span class="tlaGNC">           3 :     if (custom_data) {</span></span>
<span id="L693"><span class="lineNum">     693</span> <span class="tlaGNC">           3 :       ml_pipeline_if_custom_ref (custom_data-&gt;handle);</span></span>
<span id="L694"><span class="lineNum">     694</span>              : </span>
<span id="L695"><span class="lineNum">     695</span> <span class="tlaGNC">           3 :       e-&gt;custom_destroy = pipe_custom_destroy_cb;</span></span>
<span id="L696"><span class="lineNum">     696</span> <span class="tlaGNC">           3 :       e-&gt;custom_data = custom_data;</span></span>
<span id="L697"><span class="lineNum">     697</span>              :     }</span>
<span id="L698"><span class="lineNum">     698</span>              :   }</span>
<span id="L699"><span class="lineNum">     699</span>              : </span>
<span id="L700"><span class="lineNum">     700</span> <span class="tlaGNC">           3 :   g_free (cv_option);</span></span>
<span id="L701"><span class="lineNum">     701</span> <span class="tlaGNC">           3 : }</span></span>
<span id="L702"><span class="lineNum">     702</span>              : </span>
<span id="L703"><span class="lineNum">     703</span>              : /**</span>
<span id="L704"><span class="lineNum">     704</span>              :  * @brief Initializes the GStreamer library. This is internal function.</span>
<span id="L705"><span class="lineNum">     705</span>              :  */</span>
<span id="L706"><span class="lineNum">     706</span>              : int</span>
<span id="L707"><span class="lineNum">     707</span> <span class="tlaGNC">         233 : _ml_initialize_gstreamer (void)</span></span>
<span id="L708"><span class="lineNum">     708</span>              : {</span>
<span id="L709"><span class="lineNum">     709</span> <span class="tlaGNC">         233 :   GError *err = NULL;</span></span>
<span id="L710"><span class="lineNum">     710</span>              : </span>
<span id="L711"><span class="lineNum">     711</span> <span class="tlaGNC">         233 :   if (!gst_init_check (NULL, NULL, &amp;err)) {</span></span>
<span id="L712"><span class="lineNum">     712</span> <span class="tlaUNC tlaBgUNC">           0 :     if (err) {</span></span>
<span id="L713"><span class="lineNum">     713</span> <span class="tlaUNC">           0 :       _ml_error_report</span></span>
<span id="L714"><span class="lineNum">     714</span>              :           (&quot;Initrializing ML-API failed: GStreamer has the following error from gst_init_check(): %s&quot;,</span>
<span id="L715"><span class="lineNum">     715</span>              :           err-&gt;message);</span>
<span id="L716"><span class="lineNum">     716</span> <span class="tlaUNC">           0 :       g_clear_error (&amp;err);</span></span>
<span id="L717"><span class="lineNum">     717</span>              :     } else {</span>
<span id="L718"><span class="lineNum">     718</span> <span class="tlaUNC">           0 :       _ml_error_report (&quot;Cannot initialize GStreamer. Unknown reason.&quot;);</span></span>
<span id="L719"><span class="lineNum">     719</span>              :     }</span>
<span id="L720"><span class="lineNum">     720</span>              : </span>
<span id="L721"><span class="lineNum">     721</span> <span class="tlaGNC tlaBgGNC">         233 :     return ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L722"><span class="lineNum">     722</span>              :   }</span>
<span id="L723"><span class="lineNum">     723</span>              : </span>
<span id="L724"><span class="lineNum">     724</span> <span class="tlaGNC">         233 :   return ML_ERROR_NONE;</span></span>
<span id="L725"><span class="lineNum">     725</span>              : }</span>
<span id="L726"><span class="lineNum">     726</span>              : </span>
<span id="L727"><span class="lineNum">     727</span>              : /**</span>
<span id="L728"><span class="lineNum">     728</span>              :  * @brief Checks the element is registered and available on the pipeline.</span>
<span id="L729"><span class="lineNum">     729</span>              :  */</span>
<span id="L730"><span class="lineNum">     730</span>              : int</span>
<span id="L731"><span class="lineNum">     731</span> <span class="tlaGNC">          79 : ml_check_element_availability (const char *element_name, bool *available)</span></span>
<span id="L732"><span class="lineNum">     732</span>              : {</span>
<span id="L733"><span class="lineNum">     733</span>              :   GstElementFactory *factory;</span>
<span id="L734"><span class="lineNum">     734</span>              :   int status;</span>
<span id="L735"><span class="lineNum">     735</span>              : </span>
<span id="L736"><span class="lineNum">     736</span> <span class="tlaGNC">          79 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L737"><span class="lineNum">     737</span>              : </span>
<span id="L738"><span class="lineNum">     738</span> <span class="tlaGNC">          79 :   if (!element_name)</span></span>
<span id="L739"><span class="lineNum">     739</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L740"><span class="lineNum">     740</span>              :         &quot;The parameter, element_name, is NULL. It should be a name (string) to be queried if it exists as a GStreamer/NNStreamer element.&quot;);</span>
<span id="L741"><span class="lineNum">     741</span>              : </span>
<span id="L742"><span class="lineNum">     742</span> <span class="tlaGNC">          78 :   if (!available)</span></span>
<span id="L743"><span class="lineNum">     743</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L744"><span class="lineNum">     744</span>              :         &quot;The parameter, available, is NULL. It should be a valid pointer to a bool entry so that the API (ml_check_element_availability) may return the queried result via \&quot;available\&quot; parameter. E.g., bool available; ml_check_element_availability (\&quot;tensor_converter\&quot;, &amp;available);&quot;);</span>
<span id="L745"><span class="lineNum">     745</span>              : </span>
<span id="L746"><span class="lineNum">     746</span> <span class="tlaGNC">          77 :   _ml_error_report_return_continue_iferr (_ml_initialize_gstreamer (),</span></span>
<span id="L747"><span class="lineNum">     747</span>              :       &quot;Internal error of _ml_initialize_gstreamer(). Check the availability of gstreamer libraries in your system.&quot;);</span>
<span id="L748"><span class="lineNum">     748</span>              : </span>
<span id="L749"><span class="lineNum">     749</span>              :   /* init false */</span>
<span id="L750"><span class="lineNum">     750</span> <span class="tlaGNC">          77 :   *available = false;</span></span>
<span id="L751"><span class="lineNum">     751</span>              : </span>
<span id="L752"><span class="lineNum">     752</span> <span class="tlaGNC">          77 :   factory = gst_element_factory_find (element_name);</span></span>
<span id="L753"><span class="lineNum">     753</span> <span class="tlaGNC">          77 :   if (factory) {</span></span>
<span id="L754"><span class="lineNum">     754</span> <span class="tlaGNC">          76 :     GstPluginFeature *feature = GST_PLUGIN_FEATURE (factory);</span></span>
<span id="L755"><span class="lineNum">     755</span> <span class="tlaGNC">          76 :     const gchar *plugin_name = gst_plugin_feature_get_plugin_name (feature);</span></span>
<span id="L756"><span class="lineNum">     756</span>              : </span>
<span id="L757"><span class="lineNum">     757</span>              :     /* check restricted element */</span>
<span id="L758"><span class="lineNum">     758</span> <span class="tlaGNC">          76 :     status = _ml_check_plugin_availability (plugin_name, element_name);</span></span>
<span id="L759"><span class="lineNum">     759</span> <span class="tlaGNC">          76 :     if (status == ML_ERROR_NONE)</span></span>
<span id="L760"><span class="lineNum">     760</span> <span class="tlaGNC">          63 :       *available = true;</span></span>
<span id="L761"><span class="lineNum">     761</span>              : </span>
<span id="L762"><span class="lineNum">     762</span> <span class="tlaGNC">          76 :     gst_object_unref (factory);</span></span>
<span id="L763"><span class="lineNum">     763</span>              :   }</span>
<span id="L764"><span class="lineNum">     764</span>              : </span>
<span id="L765"><span class="lineNum">     765</span> <span class="tlaGNC">          77 :   return ML_ERROR_NONE;</span></span>
<span id="L766"><span class="lineNum">     766</span>              : }</span>
<span id="L767"><span class="lineNum">     767</span>              : </span>
<span id="L768"><span class="lineNum">     768</span>              : /**</span>
<span id="L769"><span class="lineNum">     769</span>              :  * @brief Checks the availability of the plugin.</span>
<span id="L770"><span class="lineNum">     770</span>              :  */</span>
<span id="L771"><span class="lineNum">     771</span>              : int</span>
<span id="L772"><span class="lineNum">     772</span> <span class="tlaGNC">         927 : _ml_check_plugin_availability (const char *plugin_name,</span></span>
<span id="L773"><span class="lineNum">     773</span>              :     const char *element_name)</span>
<span id="L774"><span class="lineNum">     774</span>              : {</span>
<span id="L775"><span class="lineNum">     775</span>              :   static gboolean list_loaded = FALSE;</span>
<span id="L776"><span class="lineNum">     776</span>              :   static gchar **allowed_elements = NULL;</span>
<span id="L777"><span class="lineNum">     777</span>              : </span>
<span id="L778"><span class="lineNum">     778</span> <span class="tlaGNC">         927 :   if (!plugin_name)</span></span>
<span id="L779"><span class="lineNum">     779</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L780"><span class="lineNum">     780</span>              :         &quot;The parameter, plugin_name, is NULL. It should be a valid string.&quot;);</span>
<span id="L781"><span class="lineNum">     781</span>              : </span>
<span id="L782"><span class="lineNum">     782</span> <span class="tlaGNC">         926 :   if (!element_name)</span></span>
<span id="L783"><span class="lineNum">     783</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L784"><span class="lineNum">     784</span>              :         &quot;The parameter, element_name, is NULL. It should be a valid string.&quot;);</span>
<span id="L785"><span class="lineNum">     785</span>              : </span>
<span id="L786"><span class="lineNum">     786</span> <span class="tlaGNC">         925 :   if (!list_loaded) {</span></span>
<span id="L787"><span class="lineNum">     787</span>              :     gboolean restricted;</span>
<span id="L788"><span class="lineNum">     788</span>              : </span>
<span id="L789"><span class="lineNum">     789</span>              :     restricted =</span>
<span id="L790"><span class="lineNum">     790</span> <span class="tlaGNC">           7 :         nnsconf_get_custom_value_bool (&quot;element-restriction&quot;,</span></span>
<span id="L791"><span class="lineNum">     791</span>              :         &quot;enable_element_restriction&quot;, FALSE);</span>
<span id="L792"><span class="lineNum">     792</span> <span class="tlaGNC">           7 :     if (restricted) {</span></span>
<span id="L793"><span class="lineNum">     793</span>              :       gchar *elements;</span>
<span id="L794"><span class="lineNum">     794</span>              : </span>
<span id="L795"><span class="lineNum">     795</span>              :       /* check white-list of available plugins */</span>
<span id="L796"><span class="lineNum">     796</span>              :       elements =</span>
<span id="L797"><span class="lineNum">     797</span> <span class="tlaGNC">           7 :           nnsconf_get_custom_value_string (&quot;element-restriction&quot;,</span></span>
<span id="L798"><span class="lineNum">     798</span>              :           &quot;allowed_elements&quot;);</span>
<span id="L799"><span class="lineNum">     799</span> <span class="tlaGNC">           7 :       if (elements) {</span></span>
<span id="L800"><span class="lineNum">     800</span> <span class="tlaGNC">           7 :         allowed_elements = g_strsplit_set (elements, &quot; ,;&quot;, -1);</span></span>
<span id="L801"><span class="lineNum">     801</span> <span class="tlaGNC">           7 :         g_free (elements);</span></span>
<span id="L802"><span class="lineNum">     802</span>              :       }</span>
<span id="L803"><span class="lineNum">     803</span>              :     }</span>
<span id="L804"><span class="lineNum">     804</span>              : </span>
<span id="L805"><span class="lineNum">     805</span> <span class="tlaGNC">           7 :     list_loaded = TRUE;</span></span>
<span id="L806"><span class="lineNum">     806</span>              :   }</span>
<span id="L807"><span class="lineNum">     807</span>              : </span>
<span id="L808"><span class="lineNum">     808</span>              :   /* nnstreamer elements */</span>
<span id="L809"><span class="lineNum">     809</span> <span class="tlaGNC">         925 :   if (g_str_has_prefix (plugin_name, &quot;nnstreamer&quot;) &amp;&amp;</span></span>
<span id="L810"><span class="lineNum">     810</span> <span class="tlaGNC">         272 :       g_str_has_prefix (element_name, &quot;tensor_&quot;)) {</span></span>
<span id="L811"><span class="lineNum">     811</span> <span class="tlaGNC">         272 :     return ML_ERROR_NONE;</span></span>
<span id="L812"><span class="lineNum">     812</span>              :   }</span>
<span id="L813"><span class="lineNum">     813</span>              : </span>
<span id="L814"><span class="lineNum">     814</span> <span class="tlaGNC">         653 :   if (allowed_elements &amp;&amp;</span></span>
<span id="L815"><span class="lineNum">     815</span> <span class="tlaGNC">         653 :       find_key_strv ((const gchar **) allowed_elements, element_name) &lt; 0) {</span></span>
<span id="L816"><span class="lineNum">     816</span> <span class="tlaGNC">          13 :     _ml_error_report_return (ML_ERROR_NOT_SUPPORTED,</span></span>
<span id="L817"><span class="lineNum">     817</span>              :         &quot;The element %s is restricted.&quot;, element_name);</span>
<span id="L818"><span class="lineNum">     818</span>              :   }</span>
<span id="L819"><span class="lineNum">     819</span>              : </span>
<span id="L820"><span class="lineNum">     820</span> <span class="tlaGNC">         640 :   return ML_ERROR_NONE;</span></span>
<span id="L821"><span class="lineNum">     821</span>              : }</span>
<span id="L822"><span class="lineNum">     822</span>              : </span>
<span id="L823"><span class="lineNum">     823</span>              : /**</span>
<span id="L824"><span class="lineNum">     824</span>              :  * @brief Get the ml_pipeline_element_e type from its element name</span>
<span id="L825"><span class="lineNum">     825</span>              :  */</span>
<span id="L826"><span class="lineNum">     826</span>              : static ml_pipeline_element_e</span>
<span id="L827"><span class="lineNum">     827</span> <span class="tlaGNC">         860 : get_elem_type_from_name (GHashTable * table, const gchar * name)</span></span>
<span id="L828"><span class="lineNum">     828</span>              : {</span>
<span id="L829"><span class="lineNum">     829</span> <span class="tlaGNC">         860 :   gpointer value = g_hash_table_lookup (table, name);</span></span>
<span id="L830"><span class="lineNum">     830</span> <span class="tlaGNC">         860 :   if (!value)</span></span>
<span id="L831"><span class="lineNum">     831</span> <span class="tlaGNC">         504 :     return ML_PIPELINE_ELEMENT_UNKNOWN;</span></span>
<span id="L832"><span class="lineNum">     832</span>              : </span>
<span id="L833"><span class="lineNum">     833</span> <span class="tlaGNC">         356 :   return GPOINTER_TO_INT (value);</span></span>
<span id="L834"><span class="lineNum">     834</span>              : }</span>
<span id="L835"><span class="lineNum">     835</span>              : </span>
<span id="L836"><span class="lineNum">     836</span>              : /**</span>
<span id="L837"><span class="lineNum">     837</span>              :  * @brief Iterate elements and prepare element handle.</span>
<span id="L838"><span class="lineNum">     838</span>              :  */</span>
<span id="L839"><span class="lineNum">     839</span>              : static int</span>
<span id="L840"><span class="lineNum">     840</span> <span class="tlaGNC">         145 : iterate_element (ml_pipeline * pipe_h, GstElement * pipeline,</span></span>
<span id="L841"><span class="lineNum">     841</span>              :     gboolean is_internal)</span>
<span id="L842"><span class="lineNum">     842</span>              : {</span>
<span id="L843"><span class="lineNum">     843</span> <span class="tlaGNC">         145 :   GstIterator *it = NULL;</span></span>
<span id="L844"><span class="lineNum">     844</span> <span class="tlaGNC">         145 :   int status = ML_ERROR_NONE;</span></span>
<span id="L845"><span class="lineNum">     845</span>              : </span>
<span id="L846"><span class="lineNum">     846</span> <span class="tlaGNC">         145 :   g_return_val_if_fail (pipe_h &amp;&amp; pipeline, ML_ERROR_INVALID_PARAMETER);</span></span>
<span id="L847"><span class="lineNum">     847</span>              : </span>
<span id="L848"><span class="lineNum">     848</span> <span class="tlaGNC">         145 :   g_mutex_lock (&amp;pipe_h-&gt;lock);</span></span>
<span id="L849"><span class="lineNum">     849</span>              : </span>
<span id="L850"><span class="lineNum">     850</span> <span class="tlaGNC">         145 :   it = gst_bin_iterate_elements (GST_BIN (pipeline));</span></span>
<span id="L851"><span class="lineNum">     851</span> <span class="tlaGNC">         145 :   if (it != NULL) {</span></span>
<span id="L852"><span class="lineNum">     852</span> <span class="tlaGNC">         145 :     gboolean done = FALSE;</span></span>
<span id="L853"><span class="lineNum">     853</span> <span class="tlaGNC">         145 :     GValue item = G_VALUE_INIT;</span></span>
<span id="L854"><span class="lineNum">     854</span>              :     GObject *obj;</span>
<span id="L855"><span class="lineNum">     855</span>              :     gchar *name;</span>
<span id="L856"><span class="lineNum">     856</span>              : </span>
<span id="L857"><span class="lineNum">     857</span>              :     /* Fill in the hashtable, &quot;namednodes&quot; with named Elements */</span>
<span id="L858"><span class="lineNum">     858</span> <span class="tlaGNC">        1295 :     while (!done) {</span></span>
<span id="L859"><span class="lineNum">     859</span> <span class="tlaGNC">        1005 :       switch (gst_iterator_next (it, &amp;item)) {</span></span>
<span id="L860"><span class="lineNum">     860</span> <span class="tlaGNC">         860 :         case GST_ITERATOR_OK:</span></span>
<span id="L861"><span class="lineNum">     861</span> <span class="tlaGNC">         860 :           obj = g_value_get_object (&amp;item);</span></span>
<span id="L862"><span class="lineNum">     862</span>              : </span>
<span id="L863"><span class="lineNum">     863</span> <span class="tlaGNC">         860 :           if (GST_IS_ELEMENT (obj)) {</span></span>
<span id="L864"><span class="lineNum">     864</span> <span class="tlaGNC">         860 :             GstElement *elem = GST_ELEMENT (obj);</span></span>
<span id="L865"><span class="lineNum">     865</span>              :             GstPluginFeature *feature =</span>
<span id="L866"><span class="lineNum">     866</span> <span class="tlaGNC">         860 :                 GST_PLUGIN_FEATURE (gst_element_get_factory (elem));</span></span>
<span id="L867"><span class="lineNum">     867</span>              :             const gchar *plugin_name =</span>
<span id="L868"><span class="lineNum">     868</span> <span class="tlaGNC">         860 :                 gst_plugin_feature_get_plugin_name (feature);</span></span>
<span id="L869"><span class="lineNum">     869</span> <span class="tlaGNC">         860 :             const gchar *element_name = gst_plugin_feature_get_name (feature);</span></span>
<span id="L870"><span class="lineNum">     870</span>              : </span>
<span id="L871"><span class="lineNum">     871</span>              :             /* validate the availability of the plugin */</span>
<span id="L872"><span class="lineNum">     872</span> <span class="tlaGNC">         860 :             if (!is_internal &amp;&amp; _ml_check_plugin_availability (plugin_name,</span></span>
<span id="L873"><span class="lineNum">     873</span>              :                     element_name) != ML_ERROR_NONE) {</span>
<span id="L874"><span class="lineNum">     874</span> <span class="tlaUNC tlaBgUNC">           0 :               _ml_error_report_continue</span></span>
<span id="L875"><span class="lineNum">     875</span>              :                   (&quot;There is a pipeline element (filter) that is not allowed for applications via ML-API (privilege not granted) or now available: '%s'/'%s'.&quot;,</span>
<span id="L876"><span class="lineNum">     876</span>              :                   plugin_name, element_name);</span>
<span id="L877"><span class="lineNum">     877</span> <span class="tlaUNC">           0 :               status = ML_ERROR_NOT_SUPPORTED;</span></span>
<span id="L878"><span class="lineNum">     878</span> <span class="tlaUNC">           0 :               done = TRUE;</span></span>
<span id="L879"><span class="lineNum">     879</span> <span class="tlaUNC">           0 :               break;</span></span>
<span id="L880"><span class="lineNum">     880</span>              :             }</span>
<span id="L881"><span class="lineNum">     881</span>              : </span>
<span id="L882"><span class="lineNum">     882</span> <span class="tlaGNC tlaBgGNC">         860 :             name = gst_element_get_name (elem);</span></span>
<span id="L883"><span class="lineNum">     883</span> <span class="tlaGNC">         860 :             if (name != NULL) {</span></span>
<span id="L884"><span class="lineNum">     884</span>              :               ml_pipeline_element_e element_type =</span>
<span id="L885"><span class="lineNum">     885</span> <span class="tlaGNC">         860 :                   get_elem_type_from_name (pipe_h-&gt;pipe_elm_type, element_name);</span></span>
<span id="L886"><span class="lineNum">     886</span>              : </span>
<span id="L887"><span class="lineNum">     887</span>              :               /* check 'sync' property in sink element */</span>
<span id="L888"><span class="lineNum">     888</span> <span class="tlaGNC">         860 :               if (element_type == ML_PIPELINE_ELEMENT_SINK ||</span></span>
<span id="L889"><span class="lineNum">     889</span>              :                   element_type == ML_PIPELINE_ELEMENT_APP_SINK) {</span>
<span id="L890"><span class="lineNum">     890</span> <span class="tlaGNC">         137 :                 gboolean sync = FALSE;</span></span>
<span id="L891"><span class="lineNum">     891</span>              : </span>
<span id="L892"><span class="lineNum">     892</span> <span class="tlaGNC">         137 :                 g_object_get (G_OBJECT (elem), &quot;sync&quot;, &amp;sync, NULL);</span></span>
<span id="L893"><span class="lineNum">     893</span> <span class="tlaGNC">         137 :                 if (sync) {</span></span>
<span id="L894"><span class="lineNum">     894</span> <span class="tlaGNC">           1 :                   _ml_logw (_ml_detail</span></span>
<span id="L895"><span class="lineNum">     895</span>              :                       (&quot;It is recommended to apply 'sync=false' property to a sink element in most AI applications. Otherwise, inference results of large neural networks will be frequently dropped by the synchronization mechanism at the sink element.&quot;));</span>
<span id="L896"><span class="lineNum">     896</span>              :                 }</span>
<span id="L897"><span class="lineNum">     897</span>              :               }</span>
<span id="L898"><span class="lineNum">     898</span>              : </span>
<span id="L899"><span class="lineNum">     899</span> <span class="tlaGNC">         860 :               if (element_type != ML_PIPELINE_ELEMENT_UNKNOWN) {</span></span>
<span id="L900"><span class="lineNum">     900</span>              :                 ml_pipeline_element *e;</span>
<span id="L901"><span class="lineNum">     901</span>              : </span>
<span id="L902"><span class="lineNum">     902</span> <span class="tlaGNC">         356 :                 e = construct_element (gst_object_ref (elem), pipe_h, name,</span></span>
<span id="L903"><span class="lineNum">     903</span>              :                     element_type);</span>
<span id="L904"><span class="lineNum">     904</span> <span class="tlaGNC">         356 :                 if (e != NULL) {</span></span>
<span id="L905"><span class="lineNum">     905</span> <span class="tlaGNC">         356 :                   if (g_str_equal (element_name, &quot;tensor_if&quot;))</span></span>
<span id="L906"><span class="lineNum">     906</span> <span class="tlaGNC">           3 :                     process_tensor_if_option (e);</span></span>
<span id="L907"><span class="lineNum">     907</span> <span class="tlaGNC">         353 :                   else if (g_str_equal (element_name, &quot;tensor_filter&quot;))</span></span>
<span id="L908"><span class="lineNum">     908</span> <span class="tlaGNC">          39 :                     process_tensor_filter_option (e);</span></span>
<span id="L909"><span class="lineNum">     909</span>              : </span>
<span id="L910"><span class="lineNum">     910</span> <span class="tlaGNC">         356 :                   g_hash_table_insert (pipe_h-&gt;namednodes, g_strdup (name), e);</span></span>
<span id="L911"><span class="lineNum">     911</span>              :                 } else {</span>
<span id="L912"><span class="lineNum">     912</span>              :                   /* allocation failure */</span>
<span id="L913"><span class="lineNum">     913</span> <span class="tlaUNC tlaBgUNC">           0 :                   gst_object_unref (elem);</span></span>
<span id="L914"><span class="lineNum">     914</span> <span class="tlaUNC">           0 :                   _ml_error_report_continue</span></span>
<span id="L915"><span class="lineNum">     915</span>              :                       (&quot;Cannot allocate memory with construct_element().&quot;);</span>
<span id="L916"><span class="lineNum">     916</span> <span class="tlaUNC">           0 :                   status = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L917"><span class="lineNum">     917</span> <span class="tlaUNC">           0 :                   done = TRUE;</span></span>
<span id="L918"><span class="lineNum">     918</span>              :                 }</span>
<span id="L919"><span class="lineNum">     919</span>              :               }</span>
<span id="L920"><span class="lineNum">     920</span>              : </span>
<span id="L921"><span class="lineNum">     921</span> <span class="tlaGNC tlaBgGNC">         860 :               g_free (name);</span></span>
<span id="L922"><span class="lineNum">     922</span>              :             }</span>
<span id="L923"><span class="lineNum">     923</span>              :           }</span>
<span id="L924"><span class="lineNum">     924</span>              : </span>
<span id="L925"><span class="lineNum">     925</span> <span class="tlaGNC">         860 :           g_value_reset (&amp;item);</span></span>
<span id="L926"><span class="lineNum">     926</span> <span class="tlaGNC">         860 :           break;</span></span>
<span id="L927"><span class="lineNum">     927</span> <span class="tlaUNC tlaBgUNC">           0 :         case GST_ITERATOR_RESYNC:</span></span>
<span id="L928"><span class="lineNum">     928</span>              :         case GST_ITERATOR_ERROR:</span>
<span id="L929"><span class="lineNum">     929</span> <span class="tlaUNC">           0 :           _ml_logw (_ml_detail</span></span>
<span id="L930"><span class="lineNum">     930</span>              :               (&quot;There is an error or a resync-event while inspecting a pipeline. However, we can still execute the pipeline.&quot;));</span>
<span id="L931"><span class="lineNum">     931</span>              :           /* fallthrough */</span>
<span id="L932"><span class="lineNum">     932</span> <span class="tlaGNC tlaBgGNC">         145 :         case GST_ITERATOR_DONE:</span></span>
<span id="L933"><span class="lineNum">     933</span> <span class="tlaGNC">         145 :           done = TRUE;</span></span>
<span id="L934"><span class="lineNum">     934</span>              :       }</span>
<span id="L935"><span class="lineNum">     935</span>              :     }</span>
<span id="L936"><span class="lineNum">     936</span>              : </span>
<span id="L937"><span class="lineNum">     937</span> <span class="tlaGNC">         145 :     g_value_unset (&amp;item);</span></span>
<span id="L938"><span class="lineNum">     938</span>              :     /** @todo CRITICAL check the validity of elem=item registered in e */</span>
<span id="L939"><span class="lineNum">     939</span> <span class="tlaGNC">         145 :     gst_iterator_free (it);</span></span>
<span id="L940"><span class="lineNum">     940</span>              :   }</span>
<span id="L941"><span class="lineNum">     941</span>              : </span>
<span id="L942"><span class="lineNum">     942</span> <span class="tlaGNC">         145 :   g_mutex_unlock (&amp;pipe_h-&gt;lock);</span></span>
<span id="L943"><span class="lineNum">     943</span> <span class="tlaGNC">         145 :   return status;</span></span>
<span id="L944"><span class="lineNum">     944</span>              : }</span>
<span id="L945"><span class="lineNum">     945</span>              : </span>
<span id="L946"><span class="lineNum">     946</span>              : /**</span>
<span id="L947"><span class="lineNum">     947</span>              :  * @brief Internal function to create the hash table for managing internal resources</span>
<span id="L948"><span class="lineNum">     948</span>              :  */</span>
<span id="L949"><span class="lineNum">     949</span>              : static void</span>
<span id="L950"><span class="lineNum">     950</span> <span class="tlaGNC">         148 : create_internal_hash (ml_pipeline * pipe_h)</span></span>
<span id="L951"><span class="lineNum">     951</span>              : {</span>
<span id="L952"><span class="lineNum">     952</span> <span class="tlaGNC">         148 :   pipe_h-&gt;namednodes =</span></span>
<span id="L953"><span class="lineNum">     953</span> <span class="tlaGNC">         148 :       g_hash_table_new_full (g_str_hash, g_str_equal, g_free, cleanup_node);</span></span>
<span id="L954"><span class="lineNum">     954</span> <span class="tlaGNC">         148 :   pipe_h-&gt;resources =</span></span>
<span id="L955"><span class="lineNum">     955</span> <span class="tlaGNC">         148 :       g_hash_table_new_full (g_str_hash, g_str_equal, g_free, cleanup_resource);</span></span>
<span id="L956"><span class="lineNum">     956</span>              : </span>
<span id="L957"><span class="lineNum">     957</span> <span class="tlaGNC">         148 :   pipe_h-&gt;pipe_elm_type =</span></span>
<span id="L958"><span class="lineNum">     958</span> <span class="tlaGNC">         148 :       g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);</span></span>
<span id="L959"><span class="lineNum">     959</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;tensor_sink&quot;),</span></span>
<span id="L960"><span class="lineNum">     960</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_SINK));</span>
<span id="L961"><span class="lineNum">     961</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;appsrc&quot;),</span></span>
<span id="L962"><span class="lineNum">     962</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_APP_SRC));</span>
<span id="L963"><span class="lineNum">     963</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;appsink&quot;),</span></span>
<span id="L964"><span class="lineNum">     964</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_APP_SINK));</span>
<span id="L965"><span class="lineNum">     965</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;valve&quot;),</span></span>
<span id="L966"><span class="lineNum">     966</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_VALVE));</span>
<span id="L967"><span class="lineNum">     967</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;input-selector&quot;),</span></span>
<span id="L968"><span class="lineNum">     968</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_SWITCH_INPUT));</span>
<span id="L969"><span class="lineNum">     969</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;output-selector&quot;),</span></span>
<span id="L970"><span class="lineNum">     970</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_SWITCH_OUTPUT));</span>
<span id="L971"><span class="lineNum">     971</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;tensor_if&quot;),</span></span>
<span id="L972"><span class="lineNum">     972</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_COMMON));</span>
<span id="L973"><span class="lineNum">     973</span> <span class="tlaGNC">         148 :   g_hash_table_insert (pipe_h-&gt;pipe_elm_type, g_strdup (&quot;tensor_filter&quot;),</span></span>
<span id="L974"><span class="lineNum">     974</span>              :       GINT_TO_POINTER (ML_PIPELINE_ELEMENT_COMMON));</span>
<span id="L975"><span class="lineNum">     975</span> <span class="tlaGNC">         148 : }</span></span>
<span id="L976"><span class="lineNum">     976</span>              : </span>
<span id="L977"><span class="lineNum">     977</span>              : /**</span>
<span id="L978"><span class="lineNum">     978</span>              :  * @brief Internal function to construct the pipeline.</span>
<span id="L979"><span class="lineNum">     979</span>              :  * If is_internal is true, this will ignore the permission in Tizen.</span>
<span id="L980"><span class="lineNum">     980</span>              :  */</span>
<span id="L981"><span class="lineNum">     981</span>              : static int</span>
<span id="L982"><span class="lineNum">     982</span> <span class="tlaGNC">         150 : construct_pipeline_internal (const char *pipeline_description,</span></span>
<span id="L983"><span class="lineNum">     983</span>              :     ml_pipeline_state_cb cb, void *user_data, ml_pipeline_h * pipe,</span>
<span id="L984"><span class="lineNum">     984</span>              :     gboolean is_internal)</span>
<span id="L985"><span class="lineNum">     985</span>              : {</span>
<span id="L986"><span class="lineNum">     986</span> <span class="tlaGNC">         150 :   GError *err = NULL;</span></span>
<span id="L987"><span class="lineNum">     987</span>              :   GstElement *pipeline;</span>
<span id="L988"><span class="lineNum">     988</span> <span class="tlaGNC">         150 :   gchar *description = NULL;</span></span>
<span id="L989"><span class="lineNum">     989</span> <span class="tlaGNC">         150 :   int status = ML_ERROR_NONE;</span></span>
<span id="L990"><span class="lineNum">     990</span>              : </span>
<span id="L991"><span class="lineNum">     991</span>              :   ml_pipeline *pipe_h;</span>
<span id="L992"><span class="lineNum">     992</span>              : </span>
<span id="L993"><span class="lineNum">     993</span> <span class="tlaGNC">         300 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L994"><span class="lineNum">     994</span>              : </span>
<span id="L995"><span class="lineNum">     995</span> <span class="tlaGNC">         150 :   if (!pipe)</span></span>
<span id="L996"><span class="lineNum">     996</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L997"><span class="lineNum">     997</span>              :         &quot;ml_pipeline_construct error: parameter pipe is NULL. It should be a valid ml_pipeline_h pointer. E.g., ml_pipeline_h pipe; ml_pipeline_construct (..., &amp;pip);&quot;);</span>
<span id="L998"><span class="lineNum">     998</span>              : </span>
<span id="L999"><span class="lineNum">     999</span> <span class="tlaGNC">         149 :   if (!pipeline_description)</span></span>
<span id="L1000"><span class="lineNum">    1000</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1001"><span class="lineNum">    1001</span>              :         &quot;ml_pipeline_construct error: parameter pipeline_description is NULL. It should be a valid string of Gstreamer/NNStreamer pipeline description.&quot;);</span>
<span id="L1002"><span class="lineNum">    1002</span>              : </span>
<span id="L1003"><span class="lineNum">    1003</span>              :   /* init null */</span>
<span id="L1004"><span class="lineNum">    1004</span> <span class="tlaGNC">         148 :   *pipe = NULL;</span></span>
<span id="L1005"><span class="lineNum">    1005</span>              : </span>
<span id="L1006"><span class="lineNum">    1006</span> <span class="tlaGNC">         148 :   _ml_error_report_return_continue_iferr (_ml_initialize_gstreamer (),</span></span>
<span id="L1007"><span class="lineNum">    1007</span>              :       &quot;ml_pipeline_construct error: it has failed to initialize gstreamer(). Please check if you have a valid GStreamer library installed in your system.&quot;);</span>
<span id="L1008"><span class="lineNum">    1008</span>              : </span>
<span id="L1009"><span class="lineNum">    1009</span>              :   /* prepare pipeline handle */</span>
<span id="L1010"><span class="lineNum">    1010</span> <span class="tlaGNC">         148 :   pipe_h = g_new0 (ml_pipeline, 1);</span></span>
<span id="L1011"><span class="lineNum">    1011</span> <span class="tlaGNC">         148 :   if (pipe_h == NULL)</span></span>
<span id="L1012"><span class="lineNum">    1012</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_OUT_OF_MEMORY,</span></span>
<span id="L1013"><span class="lineNum">    1013</span>              :         &quot;ml_pipeline_construct error: failed to allocate memory for pipeline handle. Out of memory?&quot;);</span>
<span id="L1014"><span class="lineNum">    1014</span>              : </span>
<span id="L1015"><span class="lineNum">    1015</span> <span class="tlaGNC tlaBgGNC">         148 :   g_mutex_init (&amp;pipe_h-&gt;lock);</span></span>
<span id="L1016"><span class="lineNum">    1016</span>              : </span>
<span id="L1017"><span class="lineNum">    1017</span> <span class="tlaGNC">         148 :   pipe_h-&gt;isEOS = FALSE;</span></span>
<span id="L1018"><span class="lineNum">    1018</span> <span class="tlaGNC">         148 :   pipe_h-&gt;pipe_state = ML_PIPELINE_STATE_UNKNOWN;</span></span>
<span id="L1019"><span class="lineNum">    1019</span>              : </span>
<span id="L1020"><span class="lineNum">    1020</span> <span class="tlaGNC">         148 :   create_internal_hash (pipe_h);</span></span>
<span id="L1021"><span class="lineNum">    1021</span>              : </span>
<span id="L1022"><span class="lineNum">    1022</span>              :   /* convert predefined element and launch the pipeline */</span>
<span id="L1023"><span class="lineNum">    1023</span> <span class="tlaGNC">         148 :   status = convert_description ((ml_pipeline_h) pipe_h, pipeline_description,</span></span>
<span id="L1024"><span class="lineNum">    1024</span>              :       &amp;description, is_internal);</span>
<span id="L1025"><span class="lineNum">    1025</span> <span class="tlaGNC">         148 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L1026"><span class="lineNum">    1026</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L1027"><span class="lineNum">    1027</span>              :         (&quot;ml_pipeline_construct error: failed while converting pipeline description for GStreamer w/ convert_description() function, which has returned %d&quot;,</span>
<span id="L1028"><span class="lineNum">    1028</span>              :         status);</span>
<span id="L1029"><span class="lineNum">    1029</span> <span class="tlaUNC">           0 :     goto failed;</span></span>
<span id="L1030"><span class="lineNum">    1030</span>              :   }</span>
<span id="L1031"><span class="lineNum">    1031</span>              : </span>
<span id="L1032"><span class="lineNum">    1032</span> <span class="tlaGNC tlaBgGNC">         148 :   pipeline = gst_parse_launch (description, &amp;err);</span></span>
<span id="L1033"><span class="lineNum">    1033</span> <span class="tlaGNC">         148 :   g_free (description);</span></span>
<span id="L1034"><span class="lineNum">    1034</span>              : </span>
<span id="L1035"><span class="lineNum">    1035</span> <span class="tlaGNC">         148 :   if (pipeline == NULL || err) {</span></span>
<span id="L1036"><span class="lineNum">    1036</span> <span class="tlaGNC">           3 :     _ml_error_report</span></span>
<span id="L1037"><span class="lineNum">    1037</span>              :         (&quot;ml_pipeline_construct error: gst_parse_launch cannot parse and launch the given pipeline = [%s]. The error message from gst_parse_launch is '%s'.&quot;,</span>
<span id="L1038"><span class="lineNum">    1038</span>              :         pipeline_description, (err) ? err-&gt;message : &quot;unknown reason&quot;);</span>
<span id="L1039"><span class="lineNum">    1039</span> <span class="tlaGNC">           3 :     g_clear_error (&amp;err);</span></span>
<span id="L1040"><span class="lineNum">    1040</span>              : </span>
<span id="L1041"><span class="lineNum">    1041</span> <span class="tlaGNC">           3 :     if (pipeline)</span></span>
<span id="L1042"><span class="lineNum">    1042</span> <span class="tlaGNC">           3 :       gst_object_unref (pipeline);</span></span>
<span id="L1043"><span class="lineNum">    1043</span>              : </span>
<span id="L1044"><span class="lineNum">    1044</span> <span class="tlaGNC">           3 :     status = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L1045"><span class="lineNum">    1045</span> <span class="tlaGNC">           3 :     goto failed;</span></span>
<span id="L1046"><span class="lineNum">    1046</span>              :   }</span>
<span id="L1047"><span class="lineNum">    1047</span>              : </span>
<span id="L1048"><span class="lineNum">    1048</span> <span class="tlaGNC">         145 :   g_assert (GST_IS_PIPELINE (pipeline));</span></span>
<span id="L1049"><span class="lineNum">    1049</span> <span class="tlaGNC">         145 :   pipe_h-&gt;element = pipeline;</span></span>
<span id="L1050"><span class="lineNum">    1050</span>              : </span>
<span id="L1051"><span class="lineNum">    1051</span>              :   /* bus and message callback */</span>
<span id="L1052"><span class="lineNum">    1052</span> <span class="tlaGNC">         145 :   pipe_h-&gt;bus = gst_element_get_bus (pipeline);</span></span>
<span id="L1053"><span class="lineNum">    1053</span> <span class="tlaGNC">         145 :   g_assert (pipe_h-&gt;bus);</span></span>
<span id="L1054"><span class="lineNum">    1054</span>              : </span>
<span id="L1055"><span class="lineNum">    1055</span> <span class="tlaGNC">         145 :   gst_bus_enable_sync_message_emission (pipe_h-&gt;bus);</span></span>
<span id="L1056"><span class="lineNum">    1056</span> <span class="tlaGNC">         145 :   pipe_h-&gt;signal_msg = g_signal_connect (pipe_h-&gt;bus, &quot;sync-message&quot;,</span></span>
<span id="L1057"><span class="lineNum">    1057</span>              :       G_CALLBACK (cb_bus_sync_message), pipe_h);</span>
<span id="L1058"><span class="lineNum">    1058</span>              : </span>
<span id="L1059"><span class="lineNum">    1059</span>              :   /* state change callback */</span>
<span id="L1060"><span class="lineNum">    1060</span> <span class="tlaGNC">         145 :   pipe_h-&gt;state_cb.cb = cb;</span></span>
<span id="L1061"><span class="lineNum">    1061</span> <span class="tlaGNC">         145 :   pipe_h-&gt;state_cb.user_data = user_data;</span></span>
<span id="L1062"><span class="lineNum">    1062</span>              : </span>
<span id="L1063"><span class="lineNum">    1063</span>              :   /* iterate elements and prepare element handle */</span>
<span id="L1064"><span class="lineNum">    1064</span> <span class="tlaGNC">         145 :   status = iterate_element (pipe_h, pipeline, is_internal);</span></span>
<span id="L1065"><span class="lineNum">    1065</span> <span class="tlaGNC">         145 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L1066"><span class="lineNum">    1066</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue (&quot;ml_pipeline_construct error: ...&quot;);</span></span>
<span id="L1067"><span class="lineNum">    1067</span> <span class="tlaUNC">           0 :     goto failed;</span></span>
<span id="L1068"><span class="lineNum">    1068</span>              :   }</span>
<span id="L1069"><span class="lineNum">    1069</span>              : </span>
<span id="L1070"><span class="lineNum">    1070</span>              :   /* finally set pipeline state to PAUSED */</span>
<span id="L1071"><span class="lineNum">    1071</span> <span class="tlaGNC tlaBgGNC">         145 :   status = ml_pipeline_stop ((ml_pipeline_h) pipe_h);</span></span>
<span id="L1072"><span class="lineNum">    1072</span>              : </span>
<span id="L1073"><span class="lineNum">    1073</span> <span class="tlaGNC">         145 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L1074"><span class="lineNum">    1074</span>              :     /**</span>
<span id="L1075"><span class="lineNum">    1075</span>              :      * Let's wait until the pipeline state is changed to paused.</span>
<span id="L1076"><span class="lineNum">    1076</span>              :      * Otherwise, the following APIs like 'set_property' may incur</span>
<span id="L1077"><span class="lineNum">    1077</span>              :      * unintended behaviors. But, don't need to return any error</span>
<span id="L1078"><span class="lineNum">    1078</span>              :      * even if this state change is not finished within the timeout,</span>
<span id="L1079"><span class="lineNum">    1079</span>              :      * just replying on the caller.</span>
<span id="L1080"><span class="lineNum">    1080</span>              :      */</span>
<span id="L1081"><span class="lineNum">    1081</span> <span class="tlaGNC">         144 :     gst_element_get_state (pipeline, NULL, NULL, 10 * GST_MSECOND);</span></span>
<span id="L1082"><span class="lineNum">    1082</span>              :   } else {</span>
<span id="L1083"><span class="lineNum">    1083</span> <span class="tlaGNC">           1 :     _ml_error_report_continue</span></span>
<span id="L1084"><span class="lineNum">    1084</span>              :         (&quot;ml_pipeline_construct error: ml_pipeline_stop has failed with %d return. The pipeline should be able to be stopped when it is constructed.&quot;,</span>
<span id="L1085"><span class="lineNum">    1085</span>              :         status);</span>
<span id="L1086"><span class="lineNum">    1086</span>              :   }</span>
<span id="L1087"><span class="lineNum">    1087</span>              : </span>
<span id="L1088"><span class="lineNum">    1088</span> <span class="tlaGNC">         148 : failed:</span></span>
<span id="L1089"><span class="lineNum">    1089</span> <span class="tlaGNC">         148 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L1090"><span class="lineNum">    1090</span>              :     /* failed to construct the pipeline */</span>
<span id="L1091"><span class="lineNum">    1091</span> <span class="tlaGNC">           4 :     ml_pipeline_destroy ((ml_pipeline_h) pipe_h);</span></span>
<span id="L1092"><span class="lineNum">    1092</span>              :   } else {</span>
<span id="L1093"><span class="lineNum">    1093</span> <span class="tlaGNC">         144 :     *pipe = pipe_h;</span></span>
<span id="L1094"><span class="lineNum">    1094</span>              :   }</span>
<span id="L1095"><span class="lineNum">    1095</span>              : </span>
<span id="L1096"><span class="lineNum">    1096</span> <span class="tlaGNC">         148 :   return status;</span></span>
<span id="L1097"><span class="lineNum">    1097</span>              : }</span>
<span id="L1098"><span class="lineNum">    1098</span>              : </span>
<span id="L1099"><span class="lineNum">    1099</span>              : /**</span>
<span id="L1100"><span class="lineNum">    1100</span>              :  * @brief Construct the pipeline (more info in nnstreamer.h)</span>
<span id="L1101"><span class="lineNum">    1101</span>              :  */</span>
<span id="L1102"><span class="lineNum">    1102</span>              : int</span>
<span id="L1103"><span class="lineNum">    1103</span> <span class="tlaGNC">         148 : ml_pipeline_construct (const char *pipeline_description,</span></span>
<span id="L1104"><span class="lineNum">    1104</span>              :     ml_pipeline_state_cb cb, void *user_data, ml_pipeline_h * pipe)</span>
<span id="L1105"><span class="lineNum">    1105</span>              : {</span>
<span id="L1106"><span class="lineNum">    1106</span>              :   /* not an internal pipeline construction */</span>
<span id="L1107"><span class="lineNum">    1107</span> <span class="tlaGNC">         148 :   return construct_pipeline_internal (pipeline_description, cb, user_data, pipe,</span></span>
<span id="L1108"><span class="lineNum">    1108</span>              :       FALSE);</span>
<span id="L1109"><span class="lineNum">    1109</span>              : }</span>
<span id="L1110"><span class="lineNum">    1110</span>              : </span>
<span id="L1111"><span class="lineNum">    1111</span>              : #if defined (__TIZEN__)</span>
<span id="L1112"><span class="lineNum">    1112</span>              : /**</span>
<span id="L1113"><span class="lineNum">    1113</span>              :  * @brief Construct the pipeline (Tizen internal, see nnstreamer-tizen-internal.h)</span>
<span id="L1114"><span class="lineNum">    1114</span>              :  */</span>
<span id="L1115"><span class="lineNum">    1115</span>              : int</span>
<span id="L1116"><span class="lineNum">    1116</span> <span class="tlaGNC">           2 : ml_pipeline_construct_internal (const char *pipeline_description,</span></span>
<span id="L1117"><span class="lineNum">    1117</span>              :     ml_pipeline_state_cb cb, void *user_data, ml_pipeline_h * pipe)</span>
<span id="L1118"><span class="lineNum">    1118</span>              : {</span>
<span id="L1119"><span class="lineNum">    1119</span>              :   /* Tizen internal pipeline construction */</span>
<span id="L1120"><span class="lineNum">    1120</span> <span class="tlaGNC">           2 :   return construct_pipeline_internal (pipeline_description, cb, user_data, pipe,</span></span>
<span id="L1121"><span class="lineNum">    1121</span>              :       TRUE);</span>
<span id="L1122"><span class="lineNum">    1122</span>              : }</span>
<span id="L1123"><span class="lineNum">    1123</span>              : #endif /* __TIZEN__ */</span>
<span id="L1124"><span class="lineNum">    1124</span>              : </span>
<span id="L1125"><span class="lineNum">    1125</span>              : /**</span>
<span id="L1126"><span class="lineNum">    1126</span>              :  * @brief Destroy the pipeline (more info in nnstreamer.h)</span>
<span id="L1127"><span class="lineNum">    1127</span>              :  */</span>
<span id="L1128"><span class="lineNum">    1128</span>              : int</span>
<span id="L1129"><span class="lineNum">    1129</span> <span class="tlaGNC">         143 : ml_pipeline_destroy (ml_pipeline_h pipe)</span></span>
<span id="L1130"><span class="lineNum">    1130</span>              : {</span>
<span id="L1131"><span class="lineNum">    1131</span> <span class="tlaGNC">         143 :   ml_pipeline *p = pipe;</span></span>
<span id="L1132"><span class="lineNum">    1132</span>              :   GstStateChangeReturn scret;</span>
<span id="L1133"><span class="lineNum">    1133</span>              :   GstState state;</span>
<span id="L1134"><span class="lineNum">    1134</span> <span class="tlaGNC">         143 :   guint check_paused_cnt = 0;</span></span>
<span id="L1135"><span class="lineNum">    1135</span>              : </span>
<span id="L1136"><span class="lineNum">    1136</span> <span class="tlaGNC">         286 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1137"><span class="lineNum">    1137</span>              : </span>
<span id="L1138"><span class="lineNum">    1138</span> <span class="tlaGNC">         143 :   if (p == NULL)</span></span>
<span id="L1139"><span class="lineNum">    1139</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1140"><span class="lineNum">    1140</span>              :         &quot;The parameter, pipe, is NULL. It should be a valid ml_pipeline_h handle instance, usually created by ml_pipeline_construct().&quot;);</span>
<span id="L1141"><span class="lineNum">    1141</span>              : </span>
<span id="L1142"><span class="lineNum">    1142</span> <span class="tlaGNC tlaBgGNC">         143 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1143"><span class="lineNum">    1143</span>              : </span>
<span id="L1144"><span class="lineNum">    1144</span>              :   /* Before changing the state, remove all callbacks. */</span>
<span id="L1145"><span class="lineNum">    1145</span> <span class="tlaGNC">         143 :   p-&gt;state_cb.cb = NULL;</span></span>
<span id="L1146"><span class="lineNum">    1146</span>              : </span>
<span id="L1147"><span class="lineNum">    1147</span>              :   /* Destroy registered callback handles and resources */</span>
<span id="L1148"><span class="lineNum">    1148</span> <span class="tlaGNC">         143 :   g_hash_table_destroy (p-&gt;namednodes);</span></span>
<span id="L1149"><span class="lineNum">    1149</span> <span class="tlaGNC">         143 :   g_hash_table_destroy (p-&gt;resources);</span></span>
<span id="L1150"><span class="lineNum">    1150</span> <span class="tlaGNC">         143 :   g_hash_table_destroy (p-&gt;pipe_elm_type);</span></span>
<span id="L1151"><span class="lineNum">    1151</span> <span class="tlaGNC">         143 :   p-&gt;namednodes = p-&gt;resources = p-&gt;pipe_elm_type = NULL;</span></span>
<span id="L1152"><span class="lineNum">    1152</span>              : </span>
<span id="L1153"><span class="lineNum">    1153</span> <span class="tlaGNC">         143 :   if (p-&gt;element) {</span></span>
<span id="L1154"><span class="lineNum">    1154</span>              :     /* Pause the pipeline if it's playing */</span>
<span id="L1155"><span class="lineNum">    1155</span> <span class="tlaGNC">         140 :     scret = gst_element_get_state (p-&gt;element, &amp;state, NULL, 10 * GST_MSECOND); /* 10ms */</span></span>
<span id="L1156"><span class="lineNum">    1156</span> <span class="tlaGNC">         140 :     if (scret != GST_STATE_CHANGE_FAILURE &amp;&amp; state == GST_STATE_PLAYING) {</span></span>
<span id="L1157"><span class="lineNum">    1157</span> <span class="tlaGNC">           3 :       scret = gst_element_set_state (p-&gt;element, GST_STATE_PAUSED);</span></span>
<span id="L1158"><span class="lineNum">    1158</span> <span class="tlaGNC">           3 :       if (scret == GST_STATE_CHANGE_FAILURE) {</span></span>
<span id="L1159"><span class="lineNum">    1159</span> <span class="tlaUNC tlaBgUNC">           0 :         g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1160"><span class="lineNum">    1160</span> <span class="tlaUNC">           0 :         _ml_error_report_return (ML_ERROR_STREAMS_PIPE,</span></span>
<span id="L1161"><span class="lineNum">    1161</span>              :             &quot;gst_element_get_state() has failed to wait until state changed from PLAYING to PAUSED and returned GST_STATE_CHANGE_FAILURE. For the detail, please check the GStreamer log messages (or dlog messages in Tizen). It is possible that there is a filter or neural network that is taking too much time to finish.&quot;);</span>
<span id="L1162"><span class="lineNum">    1162</span>              :       }</span>
<span id="L1163"><span class="lineNum">    1163</span>              :     }</span>
<span id="L1164"><span class="lineNum">    1164</span>              : </span>
<span id="L1165"><span class="lineNum">    1165</span> <span class="tlaGNC tlaBgGNC">         140 :     g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1166"><span class="lineNum">    1166</span> <span class="tlaGNC">         239 :     while (p-&gt;pipe_state == ML_PIPELINE_STATE_PLAYING) {</span></span>
<span id="L1167"><span class="lineNum">    1167</span> <span class="tlaGNC">         100 :       check_paused_cnt++;</span></span>
<span id="L1168"><span class="lineNum">    1168</span>              :       /** check PAUSED every 1ms */</span>
<span id="L1169"><span class="lineNum">    1169</span> <span class="tlaGNC">         100 :       g_usleep (1000);</span></span>
<span id="L1170"><span class="lineNum">    1170</span> <span class="tlaGNC">         100 :       if (check_paused_cnt &gt;= WAIT_PAUSED_TIME_LIMIT) {</span></span>
<span id="L1171"><span class="lineNum">    1171</span> <span class="tlaGNC">           1 :         _ml_error_report</span></span>
<span id="L1172"><span class="lineNum">    1172</span>              :             (&quot;Timeout while waiting for a state change to 'PAUSED' from a 'sync-message' signal from the pipeline. It is possible that there is a filter or neural network that is taking too much time to finish.&quot;);</span>
<span id="L1173"><span class="lineNum">    1173</span> <span class="tlaGNC">           1 :         break;</span></span>
<span id="L1174"><span class="lineNum">    1174</span>              :       }</span>
<span id="L1175"><span class="lineNum">    1175</span>              :     }</span>
<span id="L1176"><span class="lineNum">    1176</span> <span class="tlaGNC">         140 :     g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1177"><span class="lineNum">    1177</span>              : </span>
<span id="L1178"><span class="lineNum">    1178</span>              :     /* Stop (NULL State) the pipeline */</span>
<span id="L1179"><span class="lineNum">    1179</span> <span class="tlaGNC">         140 :     scret = gst_element_set_state (p-&gt;element, GST_STATE_NULL);</span></span>
<span id="L1180"><span class="lineNum">    1180</span> <span class="tlaGNC">         140 :     if (scret != GST_STATE_CHANGE_SUCCESS) {</span></span>
<span id="L1181"><span class="lineNum">    1181</span> <span class="tlaUNC tlaBgUNC">           0 :       g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1182"><span class="lineNum">    1182</span> <span class="tlaUNC">           0 :       _ml_error_report_return (ML_ERROR_STREAMS_PIPE,</span></span>
<span id="L1183"><span class="lineNum">    1183</span>              :           &quot;gst_element_set_state to stop the pipeline has failed after trying to stop the pipeline with PAUSE and waiting for stopping. For the detail, please check the GStreamer log messages. It is possible that there is a filter of neural network that is taking too much time to finish.&quot;);</span>
<span id="L1184"><span class="lineNum">    1184</span>              :     }</span>
<span id="L1185"><span class="lineNum">    1185</span>              : </span>
<span id="L1186"><span class="lineNum">    1186</span> <span class="tlaGNC tlaBgGNC">         140 :     if (p-&gt;bus) {</span></span>
<span id="L1187"><span class="lineNum">    1187</span> <span class="tlaGNC">         140 :       g_signal_handler_disconnect (p-&gt;bus, p-&gt;signal_msg);</span></span>
<span id="L1188"><span class="lineNum">    1188</span> <span class="tlaGNC">         140 :       gst_object_unref (p-&gt;bus);</span></span>
<span id="L1189"><span class="lineNum">    1189</span>              :     }</span>
<span id="L1190"><span class="lineNum">    1190</span>              : </span>
<span id="L1191"><span class="lineNum">    1191</span> <span class="tlaGNC">         140 :     gst_object_unref (p-&gt;element);</span></span>
<span id="L1192"><span class="lineNum">    1192</span> <span class="tlaGNC">         140 :     p-&gt;element = NULL;</span></span>
<span id="L1193"><span class="lineNum">    1193</span>              :   }</span>
<span id="L1194"><span class="lineNum">    1194</span>              : </span>
<span id="L1195"><span class="lineNum">    1195</span> <span class="tlaGNC">         143 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1196"><span class="lineNum">    1196</span> <span class="tlaGNC">         143 :   g_mutex_clear (&amp;p-&gt;lock);</span></span>
<span id="L1197"><span class="lineNum">    1197</span>              : </span>
<span id="L1198"><span class="lineNum">    1198</span> <span class="tlaGNC">         143 :   g_free (p);</span></span>
<span id="L1199"><span class="lineNum">    1199</span> <span class="tlaGNC">         143 :   return ML_ERROR_NONE;</span></span>
<span id="L1200"><span class="lineNum">    1200</span>              : }</span>
<span id="L1201"><span class="lineNum">    1201</span>              : </span>
<span id="L1202"><span class="lineNum">    1202</span>              : /**</span>
<span id="L1203"><span class="lineNum">    1203</span>              :  * @brief Get the pipeline state (more info in nnstreamer.h)</span>
<span id="L1204"><span class="lineNum">    1204</span>              :  */</span>
<span id="L1205"><span class="lineNum">    1205</span>              : int</span>
<span id="L1206"><span class="lineNum">    1206</span> <span class="tlaGNC">          43 : ml_pipeline_get_state (ml_pipeline_h pipe, ml_pipeline_state_e * state)</span></span>
<span id="L1207"><span class="lineNum">    1207</span>              : {</span>
<span id="L1208"><span class="lineNum">    1208</span> <span class="tlaGNC">          43 :   ml_pipeline *p = pipe;</span></span>
<span id="L1209"><span class="lineNum">    1209</span>              :   GstState _state;</span>
<span id="L1210"><span class="lineNum">    1210</span>              :   GstStateChangeReturn scret;</span>
<span id="L1211"><span class="lineNum">    1211</span>              : </span>
<span id="L1212"><span class="lineNum">    1212</span> <span class="tlaGNC">          86 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1213"><span class="lineNum">    1213</span>              : </span>
<span id="L1214"><span class="lineNum">    1214</span> <span class="tlaGNC">          43 :   if (p == NULL)</span></span>
<span id="L1215"><span class="lineNum">    1215</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1216"><span class="lineNum">    1216</span>              :         &quot;The parameter, pipe, is NULL. It should be a valid ml_pipeline_h handle, which is usually created by ml_pipeline_construct ().&quot;);</span>
<span id="L1217"><span class="lineNum">    1217</span> <span class="tlaGNC tlaBgGNC">          43 :   if (state == NULL)</span></span>
<span id="L1218"><span class="lineNum">    1218</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1219"><span class="lineNum">    1219</span>              :         &quot;The parameter, state, is NULL. It should be a valid pointer of ml_pipeline_state_e. E.g., ml_pipeline_state_e state; ml_pipeline_get_state(pipe, &amp;state);&quot;);</span>
<span id="L1220"><span class="lineNum">    1220</span>              : </span>
<span id="L1221"><span class="lineNum">    1221</span> <span class="tlaGNC tlaBgGNC">          43 :   *state = ML_PIPELINE_STATE_UNKNOWN;</span></span>
<span id="L1222"><span class="lineNum">    1222</span>              : </span>
<span id="L1223"><span class="lineNum">    1223</span> <span class="tlaGNC">          43 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1224"><span class="lineNum">    1224</span> <span class="tlaGNC">          43 :   scret = gst_element_get_state (p-&gt;element, &amp;_state, NULL, GST_MSECOND);       /* Do it within 1ms! */</span></span>
<span id="L1225"><span class="lineNum">    1225</span> <span class="tlaGNC">          43 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1226"><span class="lineNum">    1226</span>              : </span>
<span id="L1227"><span class="lineNum">    1227</span> <span class="tlaGNC">          43 :   if (scret == GST_STATE_CHANGE_FAILURE)</span></span>
<span id="L1228"><span class="lineNum">    1228</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_STREAMS_PIPE,</span></span>
<span id="L1229"><span class="lineNum">    1229</span>              :         &quot;Failed to get the state of the pipeline. For the detail, please check the GStreamer log messages.&quot;);</span>
<span id="L1230"><span class="lineNum">    1230</span>              : </span>
<span id="L1231"><span class="lineNum">    1231</span> <span class="tlaGNC tlaBgGNC">          43 :   *state = (ml_pipeline_state_e) _state;</span></span>
<span id="L1232"><span class="lineNum">    1232</span> <span class="tlaGNC">          43 :   return ML_ERROR_NONE;</span></span>
<span id="L1233"><span class="lineNum">    1233</span>              : }</span>
<span id="L1234"><span class="lineNum">    1234</span>              : </span>
<span id="L1235"><span class="lineNum">    1235</span>              : /****************************************************</span>
<span id="L1236"><span class="lineNum">    1236</span>              :  ** NNStreamer Pipeline Start/Stop Control         **</span>
<span id="L1237"><span class="lineNum">    1237</span>              :  ****************************************************/</span>
<span id="L1238"><span class="lineNum">    1238</span>              : /**</span>
<span id="L1239"><span class="lineNum">    1239</span>              :  * @brief Start/Resume the pipeline! (more info in nnstreamer.h)</span>
<span id="L1240"><span class="lineNum">    1240</span>              :  */</span>
<span id="L1241"><span class="lineNum">    1241</span>              : int</span>
<span id="L1242"><span class="lineNum">    1242</span> <span class="tlaGNC">          53 : ml_pipeline_start (ml_pipeline_h pipe)</span></span>
<span id="L1243"><span class="lineNum">    1243</span>              : {</span>
<span id="L1244"><span class="lineNum">    1244</span> <span class="tlaGNC">          53 :   ml_pipeline *p = pipe;</span></span>
<span id="L1245"><span class="lineNum">    1245</span>              :   GstStateChangeReturn scret;</span>
<span id="L1246"><span class="lineNum">    1246</span> <span class="tlaGNC">          53 :   int status = ML_ERROR_NONE;</span></span>
<span id="L1247"><span class="lineNum">    1247</span>              : </span>
<span id="L1248"><span class="lineNum">    1248</span> <span class="tlaGNC">          53 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1249"><span class="lineNum">    1249</span>              : </span>
<span id="L1250"><span class="lineNum">    1250</span> <span class="tlaGNC">          53 :   if (p == NULL)</span></span>
<span id="L1251"><span class="lineNum">    1251</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1252"><span class="lineNum">    1252</span>              :         &quot;The parameter, pipe, is NULL. It should be a valid ml_pipeline_h handle, which is usually created by ml_pipeline_construct ().&quot;);</span>
<span id="L1253"><span class="lineNum">    1253</span>              : </span>
<span id="L1254"><span class="lineNum">    1254</span> <span class="tlaGNC tlaBgGNC">          53 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1255"><span class="lineNum">    1255</span>              : </span>
<span id="L1256"><span class="lineNum">    1256</span>              :   /* check the resources when starting the pipeline */</span>
<span id="L1257"><span class="lineNum">    1257</span> <span class="tlaGNC">          53 :   if (g_hash_table_size (p-&gt;resources)) {</span></span>
<span id="L1258"><span class="lineNum">    1258</span>              :     GHashTableIter iter;</span>
<span id="L1259"><span class="lineNum">    1259</span>              :     gpointer key, value;</span>
<span id="L1260"><span class="lineNum">    1260</span>              : </span>
<span id="L1261"><span class="lineNum">    1261</span>              :     /* iterate all handle and acquire res if released */</span>
<span id="L1262"><span class="lineNum">    1262</span> <span class="tlaUNC tlaBgUNC">           0 :     g_hash_table_iter_init (&amp;iter, p-&gt;resources);</span></span>
<span id="L1263"><span class="lineNum">    1263</span> <span class="tlaUNC">           0 :     while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value)) {</span></span>
<span id="L1264"><span class="lineNum">    1264</span> <span class="tlaUNC">           0 :       if (g_str_has_prefix (key, &quot;tizen&quot;)) {</span></span>
<span id="L1265"><span class="lineNum">    1265</span> <span class="tlaUNC">           0 :         status = get_tizen_resource (pipe, key);</span></span>
<span id="L1266"><span class="lineNum">    1266</span> <span class="tlaUNC">           0 :         if (status != ML_ERROR_NONE) {</span></span>
<span id="L1267"><span class="lineNum">    1267</span> <span class="tlaUNC">           0 :           _ml_error_report_continue</span></span>
<span id="L1268"><span class="lineNum">    1268</span>              :               (&quot;Internal API _ml_tizen_get_resource () has failed: Tizen mm resource manager has failed to acquire the resource of '%s'&quot;,</span>
<span id="L1269"><span class="lineNum">    1269</span>              :               (gchar *) key);</span>
<span id="L1270"><span class="lineNum">    1270</span> <span class="tlaUNC">           0 :           goto done;</span></span>
<span id="L1271"><span class="lineNum">    1271</span>              :         }</span>
<span id="L1272"><span class="lineNum">    1272</span>              :       }</span>
<span id="L1273"><span class="lineNum">    1273</span>              :     }</span>
<span id="L1274"><span class="lineNum">    1274</span>              :   }</span>
<span id="L1275"><span class="lineNum">    1275</span>              : </span>
<span id="L1276"><span class="lineNum">    1276</span> <span class="tlaGNC tlaBgGNC">          53 :   scret = gst_element_set_state (p-&gt;element, GST_STATE_PLAYING);</span></span>
<span id="L1277"><span class="lineNum">    1277</span> <span class="tlaGNC">          53 :   if (scret == GST_STATE_CHANGE_FAILURE) {</span></span>
<span id="L1278"><span class="lineNum">    1278</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1279"><span class="lineNum">    1279</span>              :         (&quot;Failed to set the state of the pipeline to PLAYING. For the detail, please check the GStreamer log messages.&quot;);</span>
<span id="L1280"><span class="lineNum">    1280</span> <span class="tlaUNC">           0 :     status = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L1281"><span class="lineNum">    1281</span>              :   }</span>
<span id="L1282"><span class="lineNum">    1282</span>              : </span>
<span id="L1283"><span class="lineNum">    1283</span> <span class="tlaGNC tlaBgGNC">          53 : done:</span></span>
<span id="L1284"><span class="lineNum">    1284</span> <span class="tlaGNC">          53 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1285"><span class="lineNum">    1285</span> <span class="tlaGNC">          53 :   return status;</span></span>
<span id="L1286"><span class="lineNum">    1286</span>              : }</span>
<span id="L1287"><span class="lineNum">    1287</span>              : </span>
<span id="L1288"><span class="lineNum">    1288</span>              : /**</span>
<span id="L1289"><span class="lineNum">    1289</span>              :  * @brief Pause the pipeline! (more info in nnstreamer.h)</span>
<span id="L1290"><span class="lineNum">    1290</span>              :  */</span>
<span id="L1291"><span class="lineNum">    1291</span>              : int</span>
<span id="L1292"><span class="lineNum">    1292</span> <span class="tlaGNC">         193 : ml_pipeline_stop (ml_pipeline_h pipe)</span></span>
<span id="L1293"><span class="lineNum">    1293</span>              : {</span>
<span id="L1294"><span class="lineNum">    1294</span> <span class="tlaGNC">         193 :   ml_pipeline *p = pipe;</span></span>
<span id="L1295"><span class="lineNum">    1295</span>              :   GstStateChangeReturn scret;</span>
<span id="L1296"><span class="lineNum">    1296</span>              : </span>
<span id="L1297"><span class="lineNum">    1297</span> <span class="tlaGNC">         193 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1298"><span class="lineNum">    1298</span>              : </span>
<span id="L1299"><span class="lineNum">    1299</span> <span class="tlaGNC">         193 :   if (p == NULL)</span></span>
<span id="L1300"><span class="lineNum">    1300</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1301"><span class="lineNum">    1301</span>              :         &quot;The parameter, pipe, is NULL. It should be a valid ml_pipeline_h instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L1302"><span class="lineNum">    1302</span>              : </span>
<span id="L1303"><span class="lineNum">    1303</span> <span class="tlaGNC tlaBgGNC">         193 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1304"><span class="lineNum">    1304</span> <span class="tlaGNC">         193 :   scret = gst_element_set_state (p-&gt;element, GST_STATE_PAUSED);</span></span>
<span id="L1305"><span class="lineNum">    1305</span> <span class="tlaGNC">         193 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1306"><span class="lineNum">    1306</span>              : </span>
<span id="L1307"><span class="lineNum">    1307</span> <span class="tlaGNC">         193 :   if (scret == GST_STATE_CHANGE_FAILURE)</span></span>
<span id="L1308"><span class="lineNum">    1308</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_STREAMS_PIPE,</span></span>
<span id="L1309"><span class="lineNum">    1309</span>              :         &quot;Failed to set the state of the pipeline to PAUSED. For the detail, please check the GStreamer log messages.&quot;);</span>
<span id="L1310"><span class="lineNum">    1310</span>              : </span>
<span id="L1311"><span class="lineNum">    1311</span> <span class="tlaGNC">         192 :   return ML_ERROR_NONE;</span></span>
<span id="L1312"><span class="lineNum">    1312</span>              : }</span>
<span id="L1313"><span class="lineNum">    1313</span>              : </span>
<span id="L1314"><span class="lineNum">    1314</span>              : /**</span>
<span id="L1315"><span class="lineNum">    1315</span>              :  * @brief Clears all data and resets the running-time of the pipeline (more info in nnstreamer.h)</span>
<span id="L1316"><span class="lineNum">    1316</span>              :  */</span>
<span id="L1317"><span class="lineNum">    1317</span>              : int</span>
<span id="L1318"><span class="lineNum">    1318</span> <span class="tlaGNC">           2 : ml_pipeline_flush (ml_pipeline_h pipe, bool start)</span></span>
<span id="L1319"><span class="lineNum">    1319</span>              : {</span>
<span id="L1320"><span class="lineNum">    1320</span> <span class="tlaGNC">           2 :   ml_pipeline *p = pipe;</span></span>
<span id="L1321"><span class="lineNum">    1321</span> <span class="tlaGNC">           2 :   int status = ML_ERROR_NONE;</span></span>
<span id="L1322"><span class="lineNum">    1322</span>              : </span>
<span id="L1323"><span class="lineNum">    1323</span> <span class="tlaGNC">           2 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1324"><span class="lineNum">    1324</span>              : </span>
<span id="L1325"><span class="lineNum">    1325</span> <span class="tlaGNC">           2 :   if (p == NULL)</span></span>
<span id="L1326"><span class="lineNum">    1326</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1327"><span class="lineNum">    1327</span>              :         &quot;The parameter, pipe, is NULL. It should be a valid ml_pipeline_h instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L1328"><span class="lineNum">    1328</span>              : </span>
<span id="L1329"><span class="lineNum">    1329</span> <span class="tlaGNC">           1 :   _ml_error_report_return_continue_iferr (ml_pipeline_stop (pipe),</span></span>
<span id="L1330"><span class="lineNum">    1330</span>              :       &quot;Failed to stop the pipeline with ml_pipeline_stop (). It has returned %d.&quot;,</span>
<span id="L1331"><span class="lineNum">    1331</span>              :       _ERRNO);</span>
<span id="L1332"><span class="lineNum">    1332</span>              : </span>
<span id="L1333"><span class="lineNum">    1333</span> <span class="tlaGNC">           1 :   _ml_logi (&quot;The pipeline is stopped, clear all data from the pipeline.&quot;);</span></span>
<span id="L1334"><span class="lineNum">    1334</span>              : </span>
<span id="L1335"><span class="lineNum">    1335</span>              :   /* send flush event to pipeline */</span>
<span id="L1336"><span class="lineNum">    1336</span> <span class="tlaGNC">           1 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1337"><span class="lineNum">    1337</span> <span class="tlaGNC">           1 :   if (!gst_element_send_event (p-&gt;element, gst_event_new_flush_start ())) {</span></span>
<span id="L1338"><span class="lineNum">    1338</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logw (&quot;Error occurs while sending flush_start event.&quot;);</span></span>
<span id="L1339"><span class="lineNum">    1339</span>              :   }</span>
<span id="L1340"><span class="lineNum">    1340</span>              : </span>
<span id="L1341"><span class="lineNum">    1341</span> <span class="tlaGNC tlaBgGNC">           1 :   if (!gst_element_send_event (p-&gt;element, gst_event_new_flush_stop (TRUE))) {</span></span>
<span id="L1342"><span class="lineNum">    1342</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logw (&quot;Error occurs while sending flush_stop event.&quot;);</span></span>
<span id="L1343"><span class="lineNum">    1343</span>              :   }</span>
<span id="L1344"><span class="lineNum">    1344</span> <span class="tlaGNC tlaBgGNC">           1 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1345"><span class="lineNum">    1345</span>              : </span>
<span id="L1346"><span class="lineNum">    1346</span> <span class="tlaGNC">           1 :   if (start &amp;&amp; status == ML_ERROR_NONE)</span></span>
<span id="L1347"><span class="lineNum">    1347</span> <span class="tlaGNC">           1 :     status = ml_pipeline_start (pipe);</span></span>
<span id="L1348"><span class="lineNum">    1348</span>              : </span>
<span id="L1349"><span class="lineNum">    1349</span> <span class="tlaGNC">           1 :   return status;</span></span>
<span id="L1350"><span class="lineNum">    1350</span>              : }</span>
<span id="L1351"><span class="lineNum">    1351</span>              : </span>
<span id="L1352"><span class="lineNum">    1352</span>              : /****************************************************</span>
<span id="L1353"><span class="lineNum">    1353</span>              :  ** NNStreamer Pipeline Sink/Src Control           **</span>
<span id="L1354"><span class="lineNum">    1354</span>              :  ****************************************************/</span>
<span id="L1355"><span class="lineNum">    1355</span>              : /**</span>
<span id="L1356"><span class="lineNum">    1356</span>              :  * @brief Register a callback for sink (more info in nnstreamer.h)</span>
<span id="L1357"><span class="lineNum">    1357</span>              :  */</span>
<span id="L1358"><span class="lineNum">    1358</span>              : int</span>
<span id="L1359"><span class="lineNum">    1359</span> <span class="tlaGNC">          46 : ml_pipeline_sink_register (ml_pipeline_h pipe, const char *sink_name,</span></span>
<span id="L1360"><span class="lineNum">    1360</span>              :     ml_pipeline_sink_cb cb, void *user_data, ml_pipeline_sink_h * h)</span>
<span id="L1361"><span class="lineNum">    1361</span>              : {</span>
<span id="L1362"><span class="lineNum">    1362</span>              :   ml_pipeline_element *elem;</span>
<span id="L1363"><span class="lineNum">    1363</span> <span class="tlaGNC">          46 :   ml_pipeline *p = pipe;</span></span>
<span id="L1364"><span class="lineNum">    1364</span>              :   ml_pipeline_common_elem *sink;</span>
<span id="L1365"><span class="lineNum">    1365</span> <span class="tlaGNC">          46 :   int ret = ML_ERROR_NONE;</span></span>
<span id="L1366"><span class="lineNum">    1366</span>              : </span>
<span id="L1367"><span class="lineNum">    1367</span> <span class="tlaGNC">          46 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1368"><span class="lineNum">    1368</span>              : </span>
<span id="L1369"><span class="lineNum">    1369</span> <span class="tlaGNC">          46 :   if (h == NULL)</span></span>
<span id="L1370"><span class="lineNum">    1370</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1371"><span class="lineNum">    1371</span>              :         &quot;The argument, h (ml_pipeline_sink_h), is NULL. It should be a valid pointer to a new ml_pipeline_sink_h instance. E.g., ml_pipeline_sink_h h; ml_pipeline_sink_register (...., &amp;h);&quot;);</span>
<span id="L1372"><span class="lineNum">    1372</span>              : </span>
<span id="L1373"><span class="lineNum">    1373</span>              :   /* init null */</span>
<span id="L1374"><span class="lineNum">    1374</span> <span class="tlaGNC">          45 :   *h = NULL;</span></span>
<span id="L1375"><span class="lineNum">    1375</span>              : </span>
<span id="L1376"><span class="lineNum">    1376</span> <span class="tlaGNC">          45 :   if (pipe == NULL)</span></span>
<span id="L1377"><span class="lineNum">    1377</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1378"><span class="lineNum">    1378</span>              :         &quot;The argument, pipe (ml_pipeline_h), is NULL. It should be a valid ml_pipeline_h instance, usually created by ml_pipeline_construct.&quot;);</span>
<span id="L1379"><span class="lineNum">    1379</span>              : </span>
<span id="L1380"><span class="lineNum">    1380</span> <span class="tlaGNC">          44 :   if (sink_name == NULL)</span></span>
<span id="L1381"><span class="lineNum">    1381</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1382"><span class="lineNum">    1382</span>              :         &quot;The argument, sink_name (const char *), is NULL. It should be a valid string naming the sink handle (h).&quot;);</span>
<span id="L1383"><span class="lineNum">    1383</span>              : </span>
<span id="L1384"><span class="lineNum">    1384</span> <span class="tlaGNC">          43 :   if (cb == NULL)</span></span>
<span id="L1385"><span class="lineNum">    1385</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1386"><span class="lineNum">    1386</span>              :         &quot;The argument, cb (ml_pipeline_sink_cb), is NULL. It should be a call-back function called for data-sink events.&quot;);</span>
<span id="L1387"><span class="lineNum">    1387</span>              : </span>
<span id="L1388"><span class="lineNum">    1388</span> <span class="tlaGNC">          42 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1389"><span class="lineNum">    1389</span> <span class="tlaGNC">          42 :   elem = g_hash_table_lookup (p-&gt;namednodes, sink_name);</span></span>
<span id="L1390"><span class="lineNum">    1390</span>              : </span>
<span id="L1391"><span class="lineNum">    1391</span> <span class="tlaGNC">          42 :   if (elem == NULL) {</span></span>
<span id="L1392"><span class="lineNum">    1392</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1393"><span class="lineNum">    1393</span>              :         (&quot;There is no element named [%s](sink_name) in the pipeline. Please check your pipeline description.&quot;,</span>
<span id="L1394"><span class="lineNum">    1394</span>              :         sink_name);</span>
<span id="L1395"><span class="lineNum">    1395</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1396"><span class="lineNum">    1396</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1397"><span class="lineNum">    1397</span>              :   }</span>
<span id="L1398"><span class="lineNum">    1398</span>              : </span>
<span id="L1399"><span class="lineNum">    1399</span> <span class="tlaGNC">          41 :   if (elem-&gt;type != ML_PIPELINE_ELEMENT_SINK &amp;&amp;</span></span>
<span id="L1400"><span class="lineNum">    1400</span> <span class="tlaGNC">           5 :       elem-&gt;type != ML_PIPELINE_ELEMENT_APP_SINK) {</span></span>
<span id="L1401"><span class="lineNum">    1401</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1402"><span class="lineNum">    1402</span>              :         (&quot;The element [%s](sink_name) in the pipeline is not a sink element. Please supply the name of tensor_sink or appsink.&quot;,</span>
<span id="L1403"><span class="lineNum">    1403</span>              :         sink_name);</span>
<span id="L1404"><span class="lineNum">    1404</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1405"><span class="lineNum">    1405</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1406"><span class="lineNum">    1406</span>              :   }</span>
<span id="L1407"><span class="lineNum">    1407</span>              : </span>
<span id="L1408"><span class="lineNum">    1408</span> <span class="tlaGNC">          40 :   if (elem-&gt;handle_id &gt; 0) {</span></span>
<span id="L1409"><span class="lineNum">    1409</span>              :     /* no need to connect signal to sink element */</span>
<span id="L1410"><span class="lineNum">    1410</span> <span class="tlaGNC">           1 :     _ml_logw (&quot;Sink callback is already registered.&quot;);</span></span>
<span id="L1411"><span class="lineNum">    1411</span>              :   } else {</span>
<span id="L1412"><span class="lineNum">    1412</span>              :     /* set callback for new data */</span>
<span id="L1413"><span class="lineNum">    1413</span> <span class="tlaGNC">          39 :     if (elem-&gt;type == ML_PIPELINE_ELEMENT_SINK) {</span></span>
<span id="L1414"><span class="lineNum">    1414</span>              :       /* tensor_sink */</span>
<span id="L1415"><span class="lineNum">    1415</span> <span class="tlaGNC">          36 :       g_object_set (G_OBJECT (elem-&gt;element), &quot;emit-signal&quot;, (gboolean) TRUE,</span></span>
<span id="L1416"><span class="lineNum">    1416</span>              :           NULL);</span>
<span id="L1417"><span class="lineNum">    1417</span> <span class="tlaGNC">          36 :       elem-&gt;handle_id =</span></span>
<span id="L1418"><span class="lineNum">    1418</span> <span class="tlaGNC">          36 :           g_signal_connect (elem-&gt;element, &quot;new-data&quot;,</span></span>
<span id="L1419"><span class="lineNum">    1419</span>              :           G_CALLBACK (cb_sink_event), elem);</span>
<span id="L1420"><span class="lineNum">    1420</span>              :     } else {</span>
<span id="L1421"><span class="lineNum">    1421</span>              :       /* appsink */</span>
<span id="L1422"><span class="lineNum">    1422</span> <span class="tlaGNC">           3 :       g_object_set (G_OBJECT (elem-&gt;element), &quot;emit-signals&quot;, (gboolean) TRUE,</span></span>
<span id="L1423"><span class="lineNum">    1423</span>              :           NULL);</span>
<span id="L1424"><span class="lineNum">    1424</span> <span class="tlaGNC">           3 :       elem-&gt;handle_id =</span></span>
<span id="L1425"><span class="lineNum">    1425</span> <span class="tlaGNC">           3 :           g_signal_connect (elem-&gt;element, &quot;new-sample&quot;,</span></span>
<span id="L1426"><span class="lineNum">    1426</span>              :           G_CALLBACK (cb_appsink_new_sample), elem);</span>
<span id="L1427"><span class="lineNum">    1427</span>              :     }</span>
<span id="L1428"><span class="lineNum">    1428</span>              : </span>
<span id="L1429"><span class="lineNum">    1429</span> <span class="tlaGNC">          39 :     if (elem-&gt;handle_id == 0) {</span></span>
<span id="L1430"><span class="lineNum">    1430</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L1431"><span class="lineNum">    1431</span>              :           (&quot;Failed to connect a signal to the element [%s](sink_name). g_signal_connect has returned NULL.&quot;,</span>
<span id="L1432"><span class="lineNum">    1432</span>              :           sink_name);</span>
<span id="L1433"><span class="lineNum">    1433</span> <span class="tlaUNC">           0 :       ret = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L1434"><span class="lineNum">    1434</span> <span class="tlaUNC">           0 :       goto unlock_return;</span></span>
<span id="L1435"><span class="lineNum">    1435</span>              :     }</span>
<span id="L1436"><span class="lineNum">    1436</span>              :   }</span>
<span id="L1437"><span class="lineNum">    1437</span>              : </span>
<span id="L1438"><span class="lineNum">    1438</span> <span class="tlaGNC tlaBgGNC">          40 :   sink = g_new0 (ml_pipeline_common_elem, 1);</span></span>
<span id="L1439"><span class="lineNum">    1439</span> <span class="tlaGNC">          40 :   if (sink == NULL) {</span></span>
<span id="L1440"><span class="lineNum">    1440</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1441"><span class="lineNum">    1441</span>              :         (&quot;Failed to allocate memory for the sink handle of %s. Out of memory?&quot;,</span>
<span id="L1442"><span class="lineNum">    1442</span>              :         sink_name);</span>
<span id="L1443"><span class="lineNum">    1443</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L1444"><span class="lineNum">    1444</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1445"><span class="lineNum">    1445</span>              :   }</span>
<span id="L1446"><span class="lineNum">    1446</span>              : </span>
<span id="L1447"><span class="lineNum">    1447</span> <span class="tlaGNC tlaBgGNC">          40 :   sink-&gt;callback_info = g_new0 (callback_info_s, 1);</span></span>
<span id="L1448"><span class="lineNum">    1448</span> <span class="tlaGNC">          40 :   if (sink-&gt;callback_info == NULL) {</span></span>
<span id="L1449"><span class="lineNum">    1449</span> <span class="tlaUNC tlaBgUNC">           0 :     g_free (sink);</span></span>
<span id="L1450"><span class="lineNum">    1450</span> <span class="tlaUNC">           0 :     _ml_error_report</span></span>
<span id="L1451"><span class="lineNum">    1451</span>              :         (&quot;Failed to allocate memory for the sink handle of %s. Out of memory?&quot;,</span>
<span id="L1452"><span class="lineNum">    1452</span>              :         sink_name);</span>
<span id="L1453"><span class="lineNum">    1453</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L1454"><span class="lineNum">    1454</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1455"><span class="lineNum">    1455</span>              :   }</span>
<span id="L1456"><span class="lineNum">    1456</span>              : </span>
<span id="L1457"><span class="lineNum">    1457</span> <span class="tlaGNC tlaBgGNC">          40 :   sink-&gt;pipe = p;</span></span>
<span id="L1458"><span class="lineNum">    1458</span> <span class="tlaGNC">          40 :   sink-&gt;element = elem;</span></span>
<span id="L1459"><span class="lineNum">    1459</span> <span class="tlaGNC">          40 :   sink-&gt;callback_info-&gt;sink_cb = cb;</span></span>
<span id="L1460"><span class="lineNum">    1460</span> <span class="tlaGNC">          40 :   sink-&gt;callback_info-&gt;sink_pdata = user_data;</span></span>
<span id="L1461"><span class="lineNum">    1461</span> <span class="tlaGNC">          40 :   *h = sink;</span></span>
<span id="L1462"><span class="lineNum">    1462</span>              : </span>
<span id="L1463"><span class="lineNum">    1463</span> <span class="tlaGNC">          40 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L1464"><span class="lineNum">    1464</span>              : </span>
<span id="L1465"><span class="lineNum">    1465</span> <span class="tlaGNC">          40 :   elem-&gt;maxid++;</span></span>
<span id="L1466"><span class="lineNum">    1466</span> <span class="tlaGNC">          40 :   sink-&gt;id = elem-&gt;maxid;</span></span>
<span id="L1467"><span class="lineNum">    1467</span> <span class="tlaGNC">          40 :   elem-&gt;handles = g_list_append (elem-&gt;handles, sink);</span></span>
<span id="L1468"><span class="lineNum">    1468</span>              : </span>
<span id="L1469"><span class="lineNum">    1469</span> <span class="tlaGNC">          40 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L1470"><span class="lineNum">    1470</span>              : </span>
<span id="L1471"><span class="lineNum">    1471</span> <span class="tlaGNC">          42 : unlock_return:</span></span>
<span id="L1472"><span class="lineNum">    1472</span> <span class="tlaGNC">          42 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1473"><span class="lineNum">    1473</span> <span class="tlaGNC">          42 :   return ret;</span></span>
<span id="L1474"><span class="lineNum">    1474</span>              : }</span>
<span id="L1475"><span class="lineNum">    1475</span>              : </span>
<span id="L1476"><span class="lineNum">    1476</span>              : /**</span>
<span id="L1477"><span class="lineNum">    1477</span>              :  * @brief Unregister a callback for sink (more info in nnstreamer.h)</span>
<span id="L1478"><span class="lineNum">    1478</span>              :  */</span>
<span id="L1479"><span class="lineNum">    1479</span>              : int</span>
<span id="L1480"><span class="lineNum">    1480</span> <span class="tlaGNC">          13 : ml_pipeline_sink_unregister (ml_pipeline_sink_h h)</span></span>
<span id="L1481"><span class="lineNum">    1481</span>              : {</span>
<span id="L1482"><span class="lineNum">    1482</span> <span class="tlaGNC">          13 :   handle_init (sink, h);</span></span>
<span id="L1483"><span class="lineNum">    1483</span>              : </span>
<span id="L1484"><span class="lineNum">    1484</span> <span class="tlaGNC">          13 :   if (elem-&gt;handle_id &gt; 0) {</span></span>
<span id="L1485"><span class="lineNum">    1485</span> <span class="tlaGNC">          12 :     g_signal_handler_disconnect (elem-&gt;element, elem-&gt;handle_id);</span></span>
<span id="L1486"><span class="lineNum">    1486</span> <span class="tlaGNC">          12 :     elem-&gt;handle_id = 0;</span></span>
<span id="L1487"><span class="lineNum">    1487</span>              :   }</span>
<span id="L1488"><span class="lineNum">    1488</span>              : </span>
<span id="L1489"><span class="lineNum">    1489</span> <span class="tlaGNC">          13 :   elem-&gt;handles = g_list_remove (elem-&gt;handles, sink);</span></span>
<span id="L1490"><span class="lineNum">    1490</span> <span class="tlaGNC">          13 :   free_element_handle (sink);</span></span>
<span id="L1491"><span class="lineNum">    1491</span>              : </span>
<span id="L1492"><span class="lineNum">    1492</span> <span class="tlaGNC">          13 :   handle_exit (h);</span></span>
<span id="L1493"><span class="lineNum">    1493</span>              : }</span>
<span id="L1494"><span class="lineNum">    1494</span>              : </span>
<span id="L1495"><span class="lineNum">    1495</span>              : /**</span>
<span id="L1496"><span class="lineNum">    1496</span>              :  * @brief Parse tensors info of src element.</span>
<span id="L1497"><span class="lineNum">    1497</span>              :  */</span>
<span id="L1498"><span class="lineNum">    1498</span>              : static int</span>
<span id="L1499"><span class="lineNum">    1499</span> <span class="tlaGNC">       12486 : ml_pipeline_src_parse_tensors_info (ml_pipeline_element * elem)</span></span>
<span id="L1500"><span class="lineNum">    1500</span>              : {</span>
<span id="L1501"><span class="lineNum">    1501</span> <span class="tlaGNC">       12486 :   GstCaps *caps = NULL;</span></span>
<span id="L1502"><span class="lineNum">    1502</span> <span class="tlaGNC">       12486 :   gboolean found = FALSE, flexible = FALSE;</span></span>
<span id="L1503"><span class="lineNum">    1503</span>              : </span>
<span id="L1504"><span class="lineNum">    1504</span> <span class="tlaGNC">       12486 :   if (elem-&gt;src == NULL) {</span></span>
<span id="L1505"><span class="lineNum">    1505</span> <span class="tlaGNC">          41 :     elem-&gt;src = gst_element_get_static_pad (elem-&gt;element, &quot;src&quot;);</span></span>
<span id="L1506"><span class="lineNum">    1506</span>              :   }</span>
<span id="L1507"><span class="lineNum">    1507</span>              : </span>
<span id="L1508"><span class="lineNum">    1508</span> <span class="tlaGNC">       12486 :   if (elem-&gt;src == NULL) {</span></span>
<span id="L1509"><span class="lineNum">    1509</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1510"><span class="lineNum">    1510</span>              :         (&quot;Failed to get the src pad of the element[%s]. The designated source element does not have available src pad? For the detail, please check the GStreamer log messages.&quot;,</span>
<span id="L1511"><span class="lineNum">    1511</span>              :         elem-&gt;name);</span>
<span id="L1512"><span class="lineNum">    1512</span> <span class="tlaGNC tlaBgGNC">       12486 :     return ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L1513"><span class="lineNum">    1513</span>              :   }</span>
<span id="L1514"><span class="lineNum">    1514</span>              : </span>
<span id="L1515"><span class="lineNum">    1515</span>              :   /* If caps is given, use it. e.g. Use cap &quot;image/png&quot; when the pipeline is */</span>
<span id="L1516"><span class="lineNum">    1516</span>              :   /* given as &quot;appsrc caps=image/png ! pngdec ! ... &quot; */</span>
<span id="L1517"><span class="lineNum">    1517</span> <span class="tlaGNC">       12486 :   caps = gst_pad_get_current_caps (elem-&gt;src);</span></span>
<span id="L1518"><span class="lineNum">    1518</span> <span class="tlaGNC">       12486 :   if (!caps)</span></span>
<span id="L1519"><span class="lineNum">    1519</span> <span class="tlaGNC">       12422 :     caps = gst_pad_get_allowed_caps (elem-&gt;src);</span></span>
<span id="L1520"><span class="lineNum">    1520</span>              : </span>
<span id="L1521"><span class="lineNum">    1521</span> <span class="tlaGNC">       12486 :   if (!caps) {</span></span>
<span id="L1522"><span class="lineNum">    1522</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logw</span></span>
<span id="L1523"><span class="lineNum">    1523</span>              :         (&quot;Cannot find caps. The pipeline is not yet negotiated for src element [%s].&quot;,</span>
<span id="L1524"><span class="lineNum">    1524</span>              :         elem-&gt;name);</span>
<span id="L1525"><span class="lineNum">    1525</span> <span class="tlaUNC">           0 :     gst_object_unref (elem-&gt;src);</span></span>
<span id="L1526"><span class="lineNum">    1526</span> <span class="tlaUNC">           0 :     elem-&gt;src = NULL;</span></span>
<span id="L1527"><span class="lineNum">    1527</span> <span class="tlaUNC">           0 :     return ML_ERROR_TRY_AGAIN;</span></span>
<span id="L1528"><span class="lineNum">    1528</span>              :   }</span>
<span id="L1529"><span class="lineNum">    1529</span>              : </span>
<span id="L1530"><span class="lineNum">    1530</span> <span class="tlaGNC tlaBgGNC">       12486 :   found = get_tensors_info_from_caps (caps, &amp;elem-&gt;tensors_info, &amp;flexible);</span></span>
<span id="L1531"><span class="lineNum">    1531</span>              : </span>
<span id="L1532"><span class="lineNum">    1532</span> <span class="tlaGNC">       12486 :   if (found) {</span></span>
<span id="L1533"><span class="lineNum">    1533</span> <span class="tlaGNC">       12480 :     elem-&gt;is_flexible_tensor = flexible;</span></span>
<span id="L1534"><span class="lineNum">    1534</span>              :   } else {</span>
<span id="L1535"><span class="lineNum">    1535</span> <span class="tlaGNC">           6 :     if (gst_caps_is_fixed (caps)) {</span></span>
<span id="L1536"><span class="lineNum">    1536</span> <span class="tlaGNC">           5 :       GstStructure *st = gst_caps_get_structure (caps, 0);</span></span>
<span id="L1537"><span class="lineNum">    1537</span> <span class="tlaGNC">           5 :       elem-&gt;is_media_stream = !gst_structure_is_tensor_stream (st);</span></span>
<span id="L1538"><span class="lineNum">    1538</span>              :     }</span>
<span id="L1539"><span class="lineNum">    1539</span>              :   }</span>
<span id="L1540"><span class="lineNum">    1540</span>              : </span>
<span id="L1541"><span class="lineNum">    1541</span> <span class="tlaGNC">       12486 :   gst_caps_unref (caps);</span></span>
<span id="L1542"><span class="lineNum">    1542</span> <span class="tlaGNC">       12486 :   return ML_ERROR_NONE;</span></span>
<span id="L1543"><span class="lineNum">    1543</span>              : }</span>
<span id="L1544"><span class="lineNum">    1544</span>              : </span>
<span id="L1545"><span class="lineNum">    1545</span>              : /**</span>
<span id="L1546"><span class="lineNum">    1546</span>              :  * @brief Get a handle to operate a src (more info in nnstreamer.h)</span>
<span id="L1547"><span class="lineNum">    1547</span>              :  */</span>
<span id="L1548"><span class="lineNum">    1548</span>              : int</span>
<span id="L1549"><span class="lineNum">    1549</span> <span class="tlaGNC">          48 : ml_pipeline_src_get_handle (ml_pipeline_h pipe, const char *src_name,</span></span>
<span id="L1550"><span class="lineNum">    1550</span>              :     ml_pipeline_src_h * h)</span>
<span id="L1551"><span class="lineNum">    1551</span>              : {</span>
<span id="L1552"><span class="lineNum">    1552</span> <span class="tlaGNC">          48 :   ml_pipeline *p = pipe;</span></span>
<span id="L1553"><span class="lineNum">    1553</span>              :   ml_pipeline_element *elem;</span>
<span id="L1554"><span class="lineNum">    1554</span>              :   ml_pipeline_common_elem *src;</span>
<span id="L1555"><span class="lineNum">    1555</span> <span class="tlaGNC">          48 :   int ret = ML_ERROR_NONE;</span></span>
<span id="L1556"><span class="lineNum">    1556</span>              : </span>
<span id="L1557"><span class="lineNum">    1557</span> <span class="tlaGNC">          48 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1558"><span class="lineNum">    1558</span>              : </span>
<span id="L1559"><span class="lineNum">    1559</span> <span class="tlaGNC">          48 :   if (h == NULL)</span></span>
<span id="L1560"><span class="lineNum">    1560</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1561"><span class="lineNum">    1561</span>              :         &quot;The parameter, h (ml_pipeline_src_h), is NULL. It should be a valid pointer to a new (or to be cleared) instance. E.g., ml_pipeline_src_h h; ml_pipeline_src_get_handle (..., &amp;h);&quot;);</span>
<span id="L1562"><span class="lineNum">    1562</span>              : </span>
<span id="L1563"><span class="lineNum">    1563</span>              :   /* init null */</span>
<span id="L1564"><span class="lineNum">    1564</span> <span class="tlaGNC">          47 :   *h = NULL;</span></span>
<span id="L1565"><span class="lineNum">    1565</span>              : </span>
<span id="L1566"><span class="lineNum">    1566</span> <span class="tlaGNC">          47 :   if (pipe == NULL)</span></span>
<span id="L1567"><span class="lineNum">    1567</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1568"><span class="lineNum">    1568</span>              :         &quot;The parameter, pipe (ml_pipeline_h), is NULL. It should be a valid ml_pipeline_h instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L1569"><span class="lineNum">    1569</span>              : </span>
<span id="L1570"><span class="lineNum">    1570</span> <span class="tlaGNC">          46 :   if (src_name == NULL)</span></span>
<span id="L1571"><span class="lineNum">    1571</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1572"><span class="lineNum">    1572</span>              :         &quot;The parameter, src_name (const char *), is NULL. This string is the name of source element (appsrc) you want to push data stream from your application threads.&quot;);</span>
<span id="L1573"><span class="lineNum">    1573</span>              : </span>
<span id="L1574"><span class="lineNum">    1574</span> <span class="tlaGNC">          45 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1575"><span class="lineNum">    1575</span>              : </span>
<span id="L1576"><span class="lineNum">    1576</span> <span class="tlaGNC">          45 :   elem = g_hash_table_lookup (p-&gt;namednodes, src_name);</span></span>
<span id="L1577"><span class="lineNum">    1577</span>              : </span>
<span id="L1578"><span class="lineNum">    1578</span> <span class="tlaGNC">          45 :   if (elem == NULL) {</span></span>
<span id="L1579"><span class="lineNum">    1579</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1580"><span class="lineNum">    1580</span>              :         (&quot;Cannot find the name, '%s': there is no element named [%s] in the given pipeline.&quot;,</span>
<span id="L1581"><span class="lineNum">    1581</span>              :         src_name, src_name);</span>
<span id="L1582"><span class="lineNum">    1582</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1583"><span class="lineNum">    1583</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1584"><span class="lineNum">    1584</span>              :   }</span>
<span id="L1585"><span class="lineNum">    1585</span>              : </span>
<span id="L1586"><span class="lineNum">    1586</span> <span class="tlaGNC">          44 :   if (elem-&gt;type != ML_PIPELINE_ELEMENT_APP_SRC) {</span></span>
<span id="L1587"><span class="lineNum">    1587</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1588"><span class="lineNum">    1588</span>              :         (&quot;The element designated by '%s' is not a source element (appsrc). Please provide a name of source element for ml_pipeline_src_get_handle API.&quot;,</span>
<span id="L1589"><span class="lineNum">    1589</span>              :         src_name);</span>
<span id="L1590"><span class="lineNum">    1590</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1591"><span class="lineNum">    1591</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1592"><span class="lineNum">    1592</span>              :   }</span>
<span id="L1593"><span class="lineNum">    1593</span>              : </span>
<span id="L1594"><span class="lineNum">    1594</span> <span class="tlaGNC">          43 :   src = *h = g_new0 (ml_pipeline_common_elem, 1);</span></span>
<span id="L1595"><span class="lineNum">    1595</span> <span class="tlaGNC">          43 :   if (src == NULL) {</span></span>
<span id="L1596"><span class="lineNum">    1596</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1597"><span class="lineNum">    1597</span>              :         (&quot;Failed to allocate the src handle for %s. Out of memory?&quot;, src_name);</span>
<span id="L1598"><span class="lineNum">    1598</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L1599"><span class="lineNum">    1599</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1600"><span class="lineNum">    1600</span>              :   }</span>
<span id="L1601"><span class="lineNum">    1601</span>              : </span>
<span id="L1602"><span class="lineNum">    1602</span> <span class="tlaGNC tlaBgGNC">          43 :   src-&gt;pipe = p;</span></span>
<span id="L1603"><span class="lineNum">    1603</span> <span class="tlaGNC">          43 :   src-&gt;element = elem;</span></span>
<span id="L1604"><span class="lineNum">    1604</span>              : </span>
<span id="L1605"><span class="lineNum">    1605</span> <span class="tlaGNC">          43 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L1606"><span class="lineNum">    1606</span>              : </span>
<span id="L1607"><span class="lineNum">    1607</span> <span class="tlaGNC">          43 :   elem-&gt;maxid++;</span></span>
<span id="L1608"><span class="lineNum">    1608</span> <span class="tlaGNC">          43 :   src-&gt;id = elem-&gt;maxid;</span></span>
<span id="L1609"><span class="lineNum">    1609</span> <span class="tlaGNC">          43 :   elem-&gt;handles = g_list_append (elem-&gt;handles, src);</span></span>
<span id="L1610"><span class="lineNum">    1610</span>              : </span>
<span id="L1611"><span class="lineNum">    1611</span> <span class="tlaGNC">          43 :   ml_pipeline_src_parse_tensors_info (elem);</span></span>
<span id="L1612"><span class="lineNum">    1612</span> <span class="tlaGNC">          43 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L1613"><span class="lineNum">    1613</span>              : </span>
<span id="L1614"><span class="lineNum">    1614</span> <span class="tlaGNC">          45 : unlock_return:</span></span>
<span id="L1615"><span class="lineNum">    1615</span> <span class="tlaGNC">          45 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1616"><span class="lineNum">    1616</span>              : </span>
<span id="L1617"><span class="lineNum">    1617</span> <span class="tlaGNC">          45 :   return ret;</span></span>
<span id="L1618"><span class="lineNum">    1618</span>              : }</span>
<span id="L1619"><span class="lineNum">    1619</span>              : </span>
<span id="L1620"><span class="lineNum">    1620</span>              : /**</span>
<span id="L1621"><span class="lineNum">    1621</span>              :  * @brief Close a src node (more info in nnstreamer.h)</span>
<span id="L1622"><span class="lineNum">    1622</span>              :  */</span>
<span id="L1623"><span class="lineNum">    1623</span>              : int</span>
<span id="L1624"><span class="lineNum">    1624</span> <span class="tlaGNC">           7 : ml_pipeline_src_release_handle (ml_pipeline_src_h h)</span></span>
<span id="L1625"><span class="lineNum">    1625</span>              : {</span>
<span id="L1626"><span class="lineNum">    1626</span> <span class="tlaGNC">           7 :   handle_init (src, h);</span></span>
<span id="L1627"><span class="lineNum">    1627</span>              : </span>
<span id="L1628"><span class="lineNum">    1628</span> <span class="tlaGNC">           7 :   elem-&gt;handles = g_list_remove (elem-&gt;handles, src);</span></span>
<span id="L1629"><span class="lineNum">    1629</span> <span class="tlaGNC">           7 :   free_element_handle (src);</span></span>
<span id="L1630"><span class="lineNum">    1630</span>              : </span>
<span id="L1631"><span class="lineNum">    1631</span> <span class="tlaGNC">           7 :   handle_exit (h);</span></span>
<span id="L1632"><span class="lineNum">    1632</span>              : }</span>
<span id="L1633"><span class="lineNum">    1633</span>              : </span>
<span id="L1634"><span class="lineNum">    1634</span>              : /**</span>
<span id="L1635"><span class="lineNum">    1635</span>              :  * @brief Push a data frame to a src (more info in nnstreamer.h)</span>
<span id="L1636"><span class="lineNum">    1636</span>              :  */</span>
<span id="L1637"><span class="lineNum">    1637</span>              : int</span>
<span id="L1638"><span class="lineNum">    1638</span> <span class="tlaGNC">        6264 : ml_pipeline_src_input_data (ml_pipeline_src_h h, ml_tensors_data_h data,</span></span>
<span id="L1639"><span class="lineNum">    1639</span>              :     ml_pipeline_buf_policy_e policy)</span>
<span id="L1640"><span class="lineNum">    1640</span>              : {</span>
<span id="L1641"><span class="lineNum">    1641</span>              :   GstBuffer *buffer;</span>
<span id="L1642"><span class="lineNum">    1642</span>              :   GstMemory *mem, *tmp;</span>
<span id="L1643"><span class="lineNum">    1643</span>              :   gpointer mem_data;</span>
<span id="L1644"><span class="lineNum">    1644</span>              :   gsize mem_size;</span>
<span id="L1645"><span class="lineNum">    1645</span>              :   GstFlowReturn gret;</span>
<span id="L1646"><span class="lineNum">    1646</span>              :   GstTensorsInfo gst_info;</span>
<span id="L1647"><span class="lineNum">    1647</span>              :   ml_tensors_data_s *_data;</span>
<span id="L1648"><span class="lineNum">    1648</span>              :   unsigned int i;</span>
<span id="L1649"><span class="lineNum">    1649</span>              : </span>
<span id="L1650"><span class="lineNum">    1650</span> <span class="tlaGNC">       12528 :   handle_init (src, h);</span></span>
<span id="L1651"><span class="lineNum">    1651</span>              : </span>
<span id="L1652"><span class="lineNum">    1652</span> <span class="tlaGNC">        6264 :   _data = (ml_tensors_data_s *) data;</span></span>
<span id="L1653"><span class="lineNum">    1653</span> <span class="tlaGNC">        6264 :   if (!_data) {</span></span>
<span id="L1654"><span class="lineNum">    1654</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1655"><span class="lineNum">    1655</span>              :         (&quot;The given parameter, data (ml_tensors_data_h), is NULL. It should be a valid ml_tensor_data_h instance, which is usually created by ml_tensors_data_create().&quot;);</span>
<span id="L1656"><span class="lineNum">    1656</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1657"><span class="lineNum">    1657</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1658"><span class="lineNum">    1658</span>              :   }</span>
<span id="L1659"><span class="lineNum">    1659</span> <span class="tlaGNC">        6263 :   G_LOCK_UNLESS_NOLOCK (*_data);</span></span>
<span id="L1660"><span class="lineNum">    1660</span>              : </span>
<span id="L1661"><span class="lineNum">    1661</span> <span class="tlaGNC">        6263 :   if (_data-&gt;num_tensors &lt; 1 || _data-&gt;num_tensors &gt; ML_TENSOR_SIZE_LIMIT) {</span></span>
<span id="L1662"><span class="lineNum">    1662</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1663"><span class="lineNum">    1663</span>              :         (&quot;The number of tensors of the given data (ml_tensors_data_h) is invalid. The number of tensors of data is %u. It should be between 1 and %u.&quot;,</span>
<span id="L1664"><span class="lineNum">    1664</span>              :         _data-&gt;num_tensors, ML_TENSOR_SIZE_LIMIT);</span>
<span id="L1665"><span class="lineNum">    1665</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1666"><span class="lineNum">    1666</span> <span class="tlaUNC">           0 :     goto dont_destroy_data;</span></span>
<span id="L1667"><span class="lineNum">    1667</span>              :   }</span>
<span id="L1668"><span class="lineNum">    1668</span>              : </span>
<span id="L1669"><span class="lineNum">    1669</span> <span class="tlaGNC tlaBgGNC">        6263 :   ret = ml_pipeline_src_parse_tensors_info (elem);</span></span>
<span id="L1670"><span class="lineNum">    1670</span>              : </span>
<span id="L1671"><span class="lineNum">    1671</span> <span class="tlaGNC">        6263 :   if (ret != ML_ERROR_NONE) {</span></span>
<span id="L1672"><span class="lineNum">    1672</span> <span class="tlaUNC tlaBgUNC">           0 :     if (ret == ML_ERROR_TRY_AGAIN)</span></span>
<span id="L1673"><span class="lineNum">    1673</span> <span class="tlaUNC">           0 :       _ml_error_report_continue</span></span>
<span id="L1674"><span class="lineNum">    1674</span>              :           (&quot;The pipeline is not ready to accept input streams. The input is ignored.&quot;);</span>
<span id="L1675"><span class="lineNum">    1675</span>              :     else</span>
<span id="L1676"><span class="lineNum">    1676</span> <span class="tlaUNC">           0 :       _ml_error_report_continue</span></span>
<span id="L1677"><span class="lineNum">    1677</span>              :           (&quot;The pipeline is either not ready to accept input streams, yet, or does not have appropriate source elements to accept input streams.&quot;);</span>
<span id="L1678"><span class="lineNum">    1678</span> <span class="tlaUNC">           0 :     goto dont_destroy_data;</span></span>
<span id="L1679"><span class="lineNum">    1679</span>              :   }</span>
<span id="L1680"><span class="lineNum">    1680</span>              : </span>
<span id="L1681"><span class="lineNum">    1681</span> <span class="tlaGNC tlaBgGNC">        6263 :   if (!elem-&gt;is_media_stream &amp;&amp; !elem-&gt;is_flexible_tensor) {</span></span>
<span id="L1682"><span class="lineNum">    1682</span> <span class="tlaGNC">        6256 :     if (elem-&gt;tensors_info.num_tensors != _data-&gt;num_tensors) {</span></span>
<span id="L1683"><span class="lineNum">    1683</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L1684"><span class="lineNum">    1684</span>              :           (&quot;The src push of [%s] cannot be handled because the number of tensors in a frame mismatches. %u != %u&quot;,</span>
<span id="L1685"><span class="lineNum">    1685</span>              :           elem-&gt;name, elem-&gt;tensors_info.num_tensors, _data-&gt;num_tensors);</span>
<span id="L1686"><span class="lineNum">    1686</span>              : </span>
<span id="L1687"><span class="lineNum">    1687</span> <span class="tlaUNC">           0 :       ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1688"><span class="lineNum">    1688</span> <span class="tlaUNC">           0 :       goto dont_destroy_data;</span></span>
<span id="L1689"><span class="lineNum">    1689</span>              :     }</span>
<span id="L1690"><span class="lineNum">    1690</span>              : </span>
<span id="L1691"><span class="lineNum">    1691</span> <span class="tlaGNC tlaBgGNC">       12665 :     for (i = 0; i &lt; _data-&gt;num_tensors; i++) {</span></span>
<span id="L1692"><span class="lineNum">    1692</span> <span class="tlaGNC">        6411 :       size_t sz = gst_tensors_info_get_size (&amp;elem-&gt;tensors_info, i);</span></span>
<span id="L1693"><span class="lineNum">    1693</span>              : </span>
<span id="L1694"><span class="lineNum">    1694</span> <span class="tlaGNC">        6411 :       if (sz != _data-&gt;tensors[i].size) {</span></span>
<span id="L1695"><span class="lineNum">    1695</span> <span class="tlaGNC">           2 :         _ml_error_report</span></span>
<span id="L1696"><span class="lineNum">    1696</span>              :             (&quot;The given input tensor size (%d'th, %zu bytes) mismatches the source pad (%zu bytes)&quot;,</span>
<span id="L1697"><span class="lineNum">    1697</span>              :             i, _data-&gt;tensors[i].size, sz);</span>
<span id="L1698"><span class="lineNum">    1698</span>              : </span>
<span id="L1699"><span class="lineNum">    1699</span> <span class="tlaGNC">           2 :         ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1700"><span class="lineNum">    1700</span> <span class="tlaGNC">           2 :         goto dont_destroy_data;</span></span>
<span id="L1701"><span class="lineNum">    1701</span>              :       }</span>
<span id="L1702"><span class="lineNum">    1702</span>              :     }</span>
<span id="L1703"><span class="lineNum">    1703</span>              :   }</span>
<span id="L1704"><span class="lineNum">    1704</span>              : </span>
<span id="L1705"><span class="lineNum">    1705</span>              :   /* Create buffer to be pushed from buf[] */</span>
<span id="L1706"><span class="lineNum">    1706</span> <span class="tlaGNC">        6261 :   buffer = gst_buffer_new ();</span></span>
<span id="L1707"><span class="lineNum">    1707</span> <span class="tlaGNC">        6261 :   _ml_tensors_info_copy_from_ml (&amp;gst_info, _data-&gt;info);</span></span>
<span id="L1708"><span class="lineNum">    1708</span>              : </span>
<span id="L1709"><span class="lineNum">    1709</span> <span class="tlaGNC">       12683 :   for (i = 0; i &lt; _data-&gt;num_tensors; i++) {</span></span>
<span id="L1710"><span class="lineNum">    1710</span>              :     GstTensorInfo *_gst_tensor_info =</span>
<span id="L1711"><span class="lineNum">    1711</span> <span class="tlaGNC">        6422 :         gst_tensors_info_get_nth_info (&amp;gst_info, i);</span></span>
<span id="L1712"><span class="lineNum">    1712</span> <span class="tlaGNC">        6422 :     mem_data = _data-&gt;tensors[i].data;</span></span>
<span id="L1713"><span class="lineNum">    1713</span> <span class="tlaGNC">        6422 :     mem_size = _data-&gt;tensors[i].size;</span></span>
<span id="L1714"><span class="lineNum">    1714</span>              : </span>
<span id="L1715"><span class="lineNum">    1715</span> <span class="tlaGNC">        6422 :     mem = tmp = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,</span></span>
<span id="L1716"><span class="lineNum">    1716</span>              :         mem_data, mem_size, 0, mem_size, mem_data,</span>
<span id="L1717"><span class="lineNum">    1717</span>              :         (policy == ML_PIPELINE_BUF_POLICY_AUTO_FREE) ? g_free : NULL);</span>
<span id="L1718"><span class="lineNum">    1718</span>              : </span>
<span id="L1719"><span class="lineNum">    1719</span>              :     /* flex tensor, append header. */</span>
<span id="L1720"><span class="lineNum">    1720</span> <span class="tlaGNC">        6422 :     if (elem-&gt;is_flexible_tensor) {</span></span>
<span id="L1721"><span class="lineNum">    1721</span>              :       GstTensorMetaInfo meta;</span>
<span id="L1722"><span class="lineNum">    1722</span>              : </span>
<span id="L1723"><span class="lineNum">    1723</span> <span class="tlaGNC">           9 :       gst_tensor_info_convert_to_meta (_gst_tensor_info, &amp;meta);</span></span>
<span id="L1724"><span class="lineNum">    1724</span>              : </span>
<span id="L1725"><span class="lineNum">    1725</span> <span class="tlaGNC">           9 :       mem = gst_tensor_meta_info_append_header (&amp;meta, tmp);</span></span>
<span id="L1726"><span class="lineNum">    1726</span> <span class="tlaGNC">           9 :       gst_memory_unref (tmp);</span></span>
<span id="L1727"><span class="lineNum">    1727</span>              :     }</span>
<span id="L1728"><span class="lineNum">    1728</span>              : </span>
<span id="L1729"><span class="lineNum">    1729</span> <span class="tlaGNC">        6422 :     gst_tensor_buffer_append_memory (buffer, mem, _gst_tensor_info);</span></span>
<span id="L1730"><span class="lineNum">    1730</span>              :     /** @todo Verify that gst_buffer_append lists tensors/gstmem in the correct order */</span>
<span id="L1731"><span class="lineNum">    1731</span>              :   }</span>
<span id="L1732"><span class="lineNum">    1732</span>              : </span>
<span id="L1733"><span class="lineNum">    1733</span> <span class="tlaGNC">        6261 :   gst_tensors_info_free (&amp;gst_info);</span></span>
<span id="L1734"><span class="lineNum">    1734</span>              : </span>
<span id="L1735"><span class="lineNum">    1735</span>              :   /* Unlock if it's not auto-free. We do not know when it'll be freed. */</span>
<span id="L1736"><span class="lineNum">    1736</span> <span class="tlaGNC">        6261 :   if (policy != ML_PIPELINE_BUF_POLICY_AUTO_FREE)</span></span>
<span id="L1737"><span class="lineNum">    1737</span> <span class="tlaGNC">          55 :     G_UNLOCK_UNLESS_NOLOCK (*_data);</span></span>
<span id="L1738"><span class="lineNum">    1738</span>              : </span>
<span id="L1739"><span class="lineNum">    1739</span>              :   /* Push the data! */</span>
<span id="L1740"><span class="lineNum">    1740</span> <span class="tlaGNC">        6261 :   gret = gst_app_src_push_buffer (GST_APP_SRC (elem-&gt;element), buffer);</span></span>
<span id="L1741"><span class="lineNum">    1741</span>              : </span>
<span id="L1742"><span class="lineNum">    1742</span>              :   /* Free data ptr if buffer policy is auto-free */</span>
<span id="L1743"><span class="lineNum">    1743</span> <span class="tlaGNC">        6261 :   if (policy == ML_PIPELINE_BUF_POLICY_AUTO_FREE) {</span></span>
<span id="L1744"><span class="lineNum">    1744</span> <span class="tlaGNC">        6206 :     G_UNLOCK_UNLESS_NOLOCK (*_data);</span></span>
<span id="L1745"><span class="lineNum">    1745</span> <span class="tlaGNC">        6206 :     _ml_tensors_data_destroy_internal (_data, FALSE);</span></span>
<span id="L1746"><span class="lineNum">    1746</span> <span class="tlaGNC">        6206 :     _data = NULL;</span></span>
<span id="L1747"><span class="lineNum">    1747</span>              :   }</span>
<span id="L1748"><span class="lineNum">    1748</span>              : </span>
<span id="L1749"><span class="lineNum">    1749</span> <span class="tlaGNC">        6261 :   if (gret == GST_FLOW_FLUSHING) {</span></span>
<span id="L1750"><span class="lineNum">    1750</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logw</span></span>
<span id="L1751"><span class="lineNum">    1751</span>              :         (&quot;The pipeline is not in PAUSED/PLAYING. The input may be ignored.&quot;);</span>
<span id="L1752"><span class="lineNum">    1752</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_TRY_AGAIN;</span></span>
<span id="L1753"><span class="lineNum">    1753</span> <span class="tlaGNC tlaBgGNC">        6261 :   } else if (gret == GST_FLOW_EOS) {</span></span>
<span id="L1754"><span class="lineNum">    1754</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logw (&quot;THe pipeline is in EOS state. The input is ignored.&quot;);</span></span>
<span id="L1755"><span class="lineNum">    1755</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L1756"><span class="lineNum">    1756</span>              :   }</span>
<span id="L1757"><span class="lineNum">    1757</span>              : </span>
<span id="L1758"><span class="lineNum">    1758</span> <span class="tlaGNC tlaBgGNC">        6261 :   goto unlock_return;</span></span>
<span id="L1759"><span class="lineNum">    1759</span>              : </span>
<span id="L1760"><span class="lineNum">    1760</span> <span class="tlaGNC">           2 : dont_destroy_data:</span></span>
<span id="L1761"><span class="lineNum">    1761</span> <span class="tlaGNC">           2 :   G_UNLOCK_UNLESS_NOLOCK (*_data);</span></span>
<span id="L1762"><span class="lineNum">    1762</span>              : </span>
<span id="L1763"><span class="lineNum">    1763</span> <span class="tlaGNC">        6264 :   handle_exit (h);</span></span>
<span id="L1764"><span class="lineNum">    1764</span>              : }</span>
<span id="L1765"><span class="lineNum">    1765</span>              : </span>
<span id="L1766"><span class="lineNum">    1766</span>              : /**</span>
<span id="L1767"><span class="lineNum">    1767</span>              :  * @brief Internal function to fetch ml_pipeline_src_callbacks_s pointer</span>
<span id="L1768"><span class="lineNum">    1768</span>              :  */</span>
<span id="L1769"><span class="lineNum">    1769</span>              : static ml_pipeline_src_callbacks_s *</span>
<span id="L1770"><span class="lineNum">    1770</span> <span class="tlaGNC">        6176 : get_app_src_callback (ml_pipeline_common_elem * src_h, void **data)</span></span>
<span id="L1771"><span class="lineNum">    1771</span>              : {</span>
<span id="L1772"><span class="lineNum">    1772</span> <span class="tlaGNC">        6176 :   ml_pipeline_src_callbacks_s *src_cb = NULL;</span></span>
<span id="L1773"><span class="lineNum">    1773</span>              : </span>
<span id="L1774"><span class="lineNum">    1774</span> <span class="tlaGNC">        6176 :   if (src_h-&gt;callback_info) {</span></span>
<span id="L1775"><span class="lineNum">    1775</span> <span class="tlaGNC">        6176 :     src_cb = &amp;src_h-&gt;callback_info-&gt;src_cb;</span></span>
<span id="L1776"><span class="lineNum">    1776</span> <span class="tlaGNC">        6176 :     *data = src_h-&gt;callback_info-&gt;src_pdata;</span></span>
<span id="L1777"><span class="lineNum">    1777</span>              :   }</span>
<span id="L1778"><span class="lineNum">    1778</span>              : </span>
<span id="L1779"><span class="lineNum">    1779</span> <span class="tlaGNC">        6176 :   return src_cb;</span></span>
<span id="L1780"><span class="lineNum">    1780</span>              : }</span>
<span id="L1781"><span class="lineNum">    1781</span>              : </span>
<span id="L1782"><span class="lineNum">    1782</span>              : /**</span>
<span id="L1783"><span class="lineNum">    1783</span>              :  * @brief Internal function for appsrc callback - need_data.</span>
<span id="L1784"><span class="lineNum">    1784</span>              :  */</span>
<span id="L1785"><span class="lineNum">    1785</span>              : static void</span>
<span id="L1786"><span class="lineNum">    1786</span> <span class="tlaGNC">        6176 : _pipe_src_cb_need_data (GstAppSrc * src, guint length, gpointer user_data)</span></span>
<span id="L1787"><span class="lineNum">    1787</span>              : {</span>
<span id="L1788"><span class="lineNum">    1788</span>              :   ml_pipeline_common_elem *src_h;</span>
<span id="L1789"><span class="lineNum">    1789</span> <span class="tlaGNC">        6176 :   ml_pipeline_src_callbacks_s *src_cb = NULL;</span></span>
<span id="L1790"><span class="lineNum">    1790</span> <span class="tlaGNC">        6176 :   void *pdata = NULL;</span></span>
<span id="L1791"><span class="lineNum">    1791</span>              : </span>
<span id="L1792"><span class="lineNum">    1792</span> <span class="tlaGNC">        6176 :   src_h = (ml_pipeline_common_elem *) user_data;</span></span>
<span id="L1793"><span class="lineNum">    1793</span> <span class="tlaGNC">        6176 :   if (!src_h)</span></span>
<span id="L1794"><span class="lineNum">    1794</span> <span class="tlaUNC tlaBgUNC">           0 :     return;</span></span>
<span id="L1795"><span class="lineNum">    1795</span>              : </span>
<span id="L1796"><span class="lineNum">    1796</span> <span class="tlaGNC tlaBgGNC">        6176 :   src_cb = get_app_src_callback (src_h, &amp;pdata);</span></span>
<span id="L1797"><span class="lineNum">    1797</span> <span class="tlaGNC">        6176 :   if (src_cb &amp;&amp; src_cb-&gt;need_data)</span></span>
<span id="L1798"><span class="lineNum">    1798</span> <span class="tlaGNC">        6176 :     src_cb-&gt;need_data (src_h, length, pdata);</span></span>
<span id="L1799"><span class="lineNum">    1799</span>              : }</span>
<span id="L1800"><span class="lineNum">    1800</span>              : </span>
<span id="L1801"><span class="lineNum">    1801</span>              : /**</span>
<span id="L1802"><span class="lineNum">    1802</span>              :  * @brief Internal function for appsrc callback - enough_data.</span>
<span id="L1803"><span class="lineNum">    1803</span>              :  */</span>
<span id="L1804"><span class="lineNum">    1804</span>              : static void</span>
<span id="L1805"><span class="lineNum">    1805</span> <span class="tlaUNC tlaBgUNC">           0 : _pipe_src_cb_enough_data (GstAppSrc * src, gpointer user_data)</span></span>
<span id="L1806"><span class="lineNum">    1806</span>              : {</span>
<span id="L1807"><span class="lineNum">    1807</span>              :   ml_pipeline_common_elem *src_h;</span>
<span id="L1808"><span class="lineNum">    1808</span> <span class="tlaUNC">           0 :   ml_pipeline_src_callbacks_s *src_cb = NULL;</span></span>
<span id="L1809"><span class="lineNum">    1809</span> <span class="tlaUNC">           0 :   void *pdata = NULL;</span></span>
<span id="L1810"><span class="lineNum">    1810</span>              : </span>
<span id="L1811"><span class="lineNum">    1811</span> <span class="tlaUNC">           0 :   src_h = (ml_pipeline_common_elem *) user_data;</span></span>
<span id="L1812"><span class="lineNum">    1812</span> <span class="tlaUNC">           0 :   if (!src_h)</span></span>
<span id="L1813"><span class="lineNum">    1813</span> <span class="tlaUNC">           0 :     return;</span></span>
<span id="L1814"><span class="lineNum">    1814</span>              : </span>
<span id="L1815"><span class="lineNum">    1815</span> <span class="tlaUNC">           0 :   src_cb = get_app_src_callback (src_h, &amp;pdata);</span></span>
<span id="L1816"><span class="lineNum">    1816</span> <span class="tlaUNC">           0 :   if (src_cb &amp;&amp; src_cb-&gt;enough_data)</span></span>
<span id="L1817"><span class="lineNum">    1817</span> <span class="tlaUNC">           0 :     src_cb-&gt;enough_data (src_h, pdata);</span></span>
<span id="L1818"><span class="lineNum">    1818</span>              : }</span>
<span id="L1819"><span class="lineNum">    1819</span>              : </span>
<span id="L1820"><span class="lineNum">    1820</span>              : /**</span>
<span id="L1821"><span class="lineNum">    1821</span>              :  * @brief Internal function for appsrc callback - seek_data.</span>
<span id="L1822"><span class="lineNum">    1822</span>              :  */</span>
<span id="L1823"><span class="lineNum">    1823</span>              : static gboolean</span>
<span id="L1824"><span class="lineNum">    1824</span> <span class="tlaUNC">           0 : _pipe_src_cb_seek_data (GstAppSrc * src, guint64 offset, gpointer user_data)</span></span>
<span id="L1825"><span class="lineNum">    1825</span>              : {</span>
<span id="L1826"><span class="lineNum">    1826</span>              :   ml_pipeline_common_elem *src_h;</span>
<span id="L1827"><span class="lineNum">    1827</span> <span class="tlaUNC">           0 :   ml_pipeline_src_callbacks_s *src_cb = NULL;</span></span>
<span id="L1828"><span class="lineNum">    1828</span> <span class="tlaUNC">           0 :   void *pdata = NULL;</span></span>
<span id="L1829"><span class="lineNum">    1829</span>              : </span>
<span id="L1830"><span class="lineNum">    1830</span> <span class="tlaUNC">           0 :   src_h = (ml_pipeline_common_elem *) user_data;</span></span>
<span id="L1831"><span class="lineNum">    1831</span> <span class="tlaUNC">           0 :   if (!src_h)</span></span>
<span id="L1832"><span class="lineNum">    1832</span> <span class="tlaUNC">           0 :     return TRUE;</span></span>
<span id="L1833"><span class="lineNum">    1833</span>              : </span>
<span id="L1834"><span class="lineNum">    1834</span> <span class="tlaUNC">           0 :   src_cb = get_app_src_callback (src_h, &amp;pdata);</span></span>
<span id="L1835"><span class="lineNum">    1835</span> <span class="tlaUNC">           0 :   if (src_cb &amp;&amp; src_cb-&gt;seek_data)</span></span>
<span id="L1836"><span class="lineNum">    1836</span> <span class="tlaUNC">           0 :     src_cb-&gt;seek_data (src_h, offset, pdata);</span></span>
<span id="L1837"><span class="lineNum">    1837</span>              : </span>
<span id="L1838"><span class="lineNum">    1838</span> <span class="tlaUNC">           0 :   return TRUE;</span></span>
<span id="L1839"><span class="lineNum">    1839</span>              : }</span>
<span id="L1840"><span class="lineNum">    1840</span>              : </span>
<span id="L1841"><span class="lineNum">    1841</span>              : /**</span>
<span id="L1842"><span class="lineNum">    1842</span>              :  * @brief Register callbacks for src events (more info in nnstreamer.h)</span>
<span id="L1843"><span class="lineNum">    1843</span>              :  */</span>
<span id="L1844"><span class="lineNum">    1844</span>              : int</span>
<span id="L1845"><span class="lineNum">    1845</span> <span class="tlaGNC tlaBgGNC">           4 : ml_pipeline_src_set_event_cb (ml_pipeline_src_h src_handle,</span></span>
<span id="L1846"><span class="lineNum">    1846</span>              :     ml_pipeline_src_callbacks_s * cb, void *user_data)</span>
<span id="L1847"><span class="lineNum">    1847</span>              : {</span>
<span id="L1848"><span class="lineNum">    1848</span> <span class="tlaGNC">           4 :   GstAppSrcCallbacks appsrc_cb = { 0, };</span></span>
<span id="L1849"><span class="lineNum">    1849</span>              : </span>
<span id="L1850"><span class="lineNum">    1850</span> <span class="tlaGNC">           7 :   handle_init (src, src_handle);</span></span>
<span id="L1851"><span class="lineNum">    1851</span>              : </span>
<span id="L1852"><span class="lineNum">    1852</span> <span class="tlaGNC">           3 :   if (cb == NULL) {</span></span>
<span id="L1853"><span class="lineNum">    1853</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1854"><span class="lineNum">    1854</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1855"><span class="lineNum">    1855</span>              :   }</span>
<span id="L1856"><span class="lineNum">    1856</span>              : </span>
<span id="L1857"><span class="lineNum">    1857</span> <span class="tlaGNC">           2 :   if (src-&gt;callback_info == NULL)</span></span>
<span id="L1858"><span class="lineNum">    1858</span> <span class="tlaGNC">           2 :     src-&gt;callback_info = g_new0 (callback_info_s, 1);</span></span>
<span id="L1859"><span class="lineNum">    1859</span> <span class="tlaGNC">           2 :   if (src-&gt;callback_info == NULL) {</span></span>
<span id="L1860"><span class="lineNum">    1860</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1861"><span class="lineNum">    1861</span>              :         (&quot;Failed to allocate memory of the callback info for %s. Out of memory?&quot;,</span>
<span id="L1862"><span class="lineNum">    1862</span>              :         elem-&gt;name);</span>
<span id="L1863"><span class="lineNum">    1863</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L1864"><span class="lineNum">    1864</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1865"><span class="lineNum">    1865</span>              :   }</span>
<span id="L1866"><span class="lineNum">    1866</span>              : </span>
<span id="L1867"><span class="lineNum">    1867</span> <span class="tlaGNC tlaBgGNC">           2 :   src-&gt;callback_info-&gt;src_cb = *cb;</span></span>
<span id="L1868"><span class="lineNum">    1868</span> <span class="tlaGNC">           2 :   src-&gt;callback_info-&gt;src_pdata = user_data;</span></span>
<span id="L1869"><span class="lineNum">    1869</span>              : </span>
<span id="L1870"><span class="lineNum">    1870</span> <span class="tlaGNC">           2 :   appsrc_cb.need_data = _pipe_src_cb_need_data;</span></span>
<span id="L1871"><span class="lineNum">    1871</span> <span class="tlaGNC">           2 :   appsrc_cb.enough_data = _pipe_src_cb_enough_data;</span></span>
<span id="L1872"><span class="lineNum">    1872</span> <span class="tlaGNC">           2 :   appsrc_cb.seek_data = _pipe_src_cb_seek_data;</span></span>
<span id="L1873"><span class="lineNum">    1873</span>              : </span>
<span id="L1874"><span class="lineNum">    1874</span> <span class="tlaGNC">           2 :   gst_app_src_set_callbacks (GST_APP_SRC (elem-&gt;element), &amp;appsrc_cb,</span></span>
<span id="L1875"><span class="lineNum">    1875</span>              :       src_handle, NULL);</span>
<span id="L1876"><span class="lineNum">    1876</span>              : </span>
<span id="L1877"><span class="lineNum">    1877</span> <span class="tlaGNC">           3 :   handle_exit (src_handle);</span></span>
<span id="L1878"><span class="lineNum">    1878</span>              : }</span>
<span id="L1879"><span class="lineNum">    1879</span>              : </span>
<span id="L1880"><span class="lineNum">    1880</span>              : /**</span>
<span id="L1881"><span class="lineNum">    1881</span>              :  * @brief Gets a handle for the tensors metadata of given src node.</span>
<span id="L1882"><span class="lineNum">    1882</span>              :  */</span>
<span id="L1883"><span class="lineNum">    1883</span>              : int</span>
<span id="L1884"><span class="lineNum">    1884</span> <span class="tlaGNC">        6180 : ml_pipeline_src_get_tensors_info (ml_pipeline_src_h h, ml_tensors_info_h * info)</span></span>
<span id="L1885"><span class="lineNum">    1885</span>              : {</span>
<span id="L1886"><span class="lineNum">    1886</span> <span class="tlaGNC">        6180 :   handle_init (src, h);</span></span>
<span id="L1887"><span class="lineNum">    1887</span>              : </span>
<span id="L1888"><span class="lineNum">    1888</span> <span class="tlaGNC">        6180 :   if (info == NULL) {</span></span>
<span id="L1889"><span class="lineNum">    1889</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1890"><span class="lineNum">    1890</span>              :         (&quot;The parameter, info (ml_tensors_info_h *), is NULL. It should be a valid pointer to a ml_tensors_info_h instance, which is usually created by ml_tensors_info_create().&quot;);</span>
<span id="L1891"><span class="lineNum">    1891</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1892"><span class="lineNum">    1892</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1893"><span class="lineNum">    1893</span>              :   }</span>
<span id="L1894"><span class="lineNum">    1894</span>              : </span>
<span id="L1895"><span class="lineNum">    1895</span> <span class="tlaGNC tlaBgGNC">        6180 :   ret = ml_pipeline_src_parse_tensors_info (elem);</span></span>
<span id="L1896"><span class="lineNum">    1896</span>              : </span>
<span id="L1897"><span class="lineNum">    1897</span> <span class="tlaGNC">        6180 :   if (ret == ML_ERROR_NONE) {</span></span>
<span id="L1898"><span class="lineNum">    1898</span> <span class="tlaGNC">        6180 :     ret = _ml_tensors_info_create_from_gst (info, &amp;elem-&gt;tensors_info);</span></span>
<span id="L1899"><span class="lineNum">    1899</span>              :   } else {</span>
<span id="L1900"><span class="lineNum">    1900</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L1901"><span class="lineNum">    1901</span>              :         (&quot;ml_pipeline_src_parse_tensors_info () has returned error; it cannot fetch input tensor info (metadata of input stream) for the given ml_pipeline_src_h handle (h). ml_pipeline_src_get_tensors_info () cannot continue.&quot;);</span>
<span id="L1902"><span class="lineNum">    1902</span>              :   }</span>
<span id="L1903"><span class="lineNum">    1903</span>              : </span>
<span id="L1904"><span class="lineNum">    1904</span> <span class="tlaGNC tlaBgGNC">        6180 :   handle_exit (h);</span></span>
<span id="L1905"><span class="lineNum">    1905</span>              : }</span>
<span id="L1906"><span class="lineNum">    1906</span>              : </span>
<span id="L1907"><span class="lineNum">    1907</span>              : /****************************************************</span>
<span id="L1908"><span class="lineNum">    1908</span>              :  ** NNStreamer Pipeline Switch/Valve Control       **</span>
<span id="L1909"><span class="lineNum">    1909</span>              :  ****************************************************/</span>
<span id="L1910"><span class="lineNum">    1910</span>              : </span>
<span id="L1911"><span class="lineNum">    1911</span>              : /**</span>
<span id="L1912"><span class="lineNum">    1912</span>              :  * @brief Get a handle to operate a selector (more info in nnstreamer.h)</span>
<span id="L1913"><span class="lineNum">    1913</span>              :  */</span>
<span id="L1914"><span class="lineNum">    1914</span>              : int</span>
<span id="L1915"><span class="lineNum">    1915</span> <span class="tlaGNC">          10 : ml_pipeline_switch_get_handle (ml_pipeline_h pipe, const char *switch_name,</span></span>
<span id="L1916"><span class="lineNum">    1916</span>              :     ml_pipeline_switch_e * type, ml_pipeline_switch_h * h)</span>
<span id="L1917"><span class="lineNum">    1917</span>              : {</span>
<span id="L1918"><span class="lineNum">    1918</span>              :   ml_pipeline_element *elem;</span>
<span id="L1919"><span class="lineNum">    1919</span> <span class="tlaGNC">          10 :   ml_pipeline *p = pipe;</span></span>
<span id="L1920"><span class="lineNum">    1920</span>              :   ml_pipeline_common_elem *swtc;</span>
<span id="L1921"><span class="lineNum">    1921</span> <span class="tlaGNC">          10 :   int ret = ML_ERROR_NONE;</span></span>
<span id="L1922"><span class="lineNum">    1922</span>              : </span>
<span id="L1923"><span class="lineNum">    1923</span> <span class="tlaGNC">          10 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L1924"><span class="lineNum">    1924</span>              : </span>
<span id="L1925"><span class="lineNum">    1925</span> <span class="tlaGNC">          10 :   if (h == NULL)</span></span>
<span id="L1926"><span class="lineNum">    1926</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1927"><span class="lineNum">    1927</span>              :         &quot;The parameter, h (ml_pipeline_switch_h *), is NULL. It should be a new or to-be-cleared instance of ml_pipeline_switch_h. E.g., ml_pipeline_switch_h h; ml_pipeline_switch_get_handle (..., &amp;h);&quot;);</span>
<span id="L1928"><span class="lineNum">    1928</span>              : </span>
<span id="L1929"><span class="lineNum">    1929</span>              :   /* init null */</span>
<span id="L1930"><span class="lineNum">    1930</span> <span class="tlaGNC">           9 :   *h = NULL;</span></span>
<span id="L1931"><span class="lineNum">    1931</span>              : </span>
<span id="L1932"><span class="lineNum">    1932</span> <span class="tlaGNC">           9 :   if (pipe == NULL)</span></span>
<span id="L1933"><span class="lineNum">    1933</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1934"><span class="lineNum">    1934</span>              :         &quot;The parameter, pipe (ml_pipeline_h), is NULL. It should be a valid ml_pipeline_h pipeline instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L1935"><span class="lineNum">    1935</span>              : </span>
<span id="L1936"><span class="lineNum">    1936</span> <span class="tlaGNC">           8 :   if (switch_name == NULL)</span></span>
<span id="L1937"><span class="lineNum">    1937</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L1938"><span class="lineNum">    1938</span>              :         &quot;The parameter, switch_name, is NULL. It should be a valid string of the corresponding name of a switch element.&quot;);</span>
<span id="L1939"><span class="lineNum">    1939</span>              : </span>
<span id="L1940"><span class="lineNum">    1940</span> <span class="tlaGNC">           7 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L1941"><span class="lineNum">    1941</span> <span class="tlaGNC">           7 :   elem = g_hash_table_lookup (p-&gt;namednodes, switch_name);</span></span>
<span id="L1942"><span class="lineNum">    1942</span>              : </span>
<span id="L1943"><span class="lineNum">    1943</span> <span class="tlaGNC">           7 :   if (elem == NULL) {</span></span>
<span id="L1944"><span class="lineNum">    1944</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1945"><span class="lineNum">    1945</span>              :         (&quot;The parameter, switch_name (%s), is invalid. An element with the name, '%s', cannot be found in the supplied pipeline (pipe)&quot;,</span>
<span id="L1946"><span class="lineNum">    1946</span>              :         switch_name, switch_name);</span>
<span id="L1947"><span class="lineNum">    1947</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1948"><span class="lineNum">    1948</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1949"><span class="lineNum">    1949</span>              :   }</span>
<span id="L1950"><span class="lineNum">    1950</span>              : </span>
<span id="L1951"><span class="lineNum">    1951</span> <span class="tlaGNC">           6 :   if (elem-&gt;type == ML_PIPELINE_ELEMENT_SWITCH_INPUT) {</span></span>
<span id="L1952"><span class="lineNum">    1952</span> <span class="tlaGNC">           4 :     if (type)</span></span>
<span id="L1953"><span class="lineNum">    1953</span> <span class="tlaGNC">           1 :       *type = ML_PIPELINE_SWITCH_INPUT_SELECTOR;</span></span>
<span id="L1954"><span class="lineNum">    1954</span> <span class="tlaGNC">           2 :   } else if (elem-&gt;type == ML_PIPELINE_ELEMENT_SWITCH_OUTPUT) {</span></span>
<span id="L1955"><span class="lineNum">    1955</span> <span class="tlaGNC">           1 :     if (type)</span></span>
<span id="L1956"><span class="lineNum">    1956</span> <span class="tlaGNC">           1 :       *type = ML_PIPELINE_SWITCH_OUTPUT_SELECTOR;</span></span>
<span id="L1957"><span class="lineNum">    1957</span>              :   } else {</span>
<span id="L1958"><span class="lineNum">    1958</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L1959"><span class="lineNum">    1959</span>              :         (&quot;An element with the given name, '%s', is found; however, it is not a 'switch' element. A switch-handle cannot be fetched from a non-switch element. It should be either input-selector or output-selector.&quot;,</span>
<span id="L1960"><span class="lineNum">    1960</span>              :         switch_name);</span>
<span id="L1961"><span class="lineNum">    1961</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L1962"><span class="lineNum">    1962</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L1963"><span class="lineNum">    1963</span>              :   }</span>
<span id="L1964"><span class="lineNum">    1964</span>              : </span>
<span id="L1965"><span class="lineNum">    1965</span> <span class="tlaGNC">           5 :   swtc = *h = g_new0 (ml_pipeline_common_elem, 1);</span></span>
<span id="L1966"><span class="lineNum">    1966</span> <span class="tlaGNC">           5 :   if (swtc == NULL) {</span></span>
<span id="L1967"><span class="lineNum">    1967</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L1968"><span class="lineNum">    1968</span>              :         (&quot;Failed to allocate memory of the switch handle, %s. Out of memory?&quot;,</span>
<span id="L1969"><span class="lineNum">    1969</span>              :         switch_name);</span>
<span id="L1970"><span class="lineNum">    1970</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L1971"><span class="lineNum">    1971</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L1972"><span class="lineNum">    1972</span>              :   }</span>
<span id="L1973"><span class="lineNum">    1973</span>              : </span>
<span id="L1974"><span class="lineNum">    1974</span> <span class="tlaGNC tlaBgGNC">           5 :   swtc-&gt;pipe = p;</span></span>
<span id="L1975"><span class="lineNum">    1975</span> <span class="tlaGNC">           5 :   swtc-&gt;element = elem;</span></span>
<span id="L1976"><span class="lineNum">    1976</span>              : </span>
<span id="L1977"><span class="lineNum">    1977</span> <span class="tlaGNC">           5 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L1978"><span class="lineNum">    1978</span>              : </span>
<span id="L1979"><span class="lineNum">    1979</span> <span class="tlaGNC">           5 :   elem-&gt;maxid++;</span></span>
<span id="L1980"><span class="lineNum">    1980</span> <span class="tlaGNC">           5 :   swtc-&gt;id = elem-&gt;maxid;</span></span>
<span id="L1981"><span class="lineNum">    1981</span> <span class="tlaGNC">           5 :   elem-&gt;handles = g_list_append (elem-&gt;handles, swtc);</span></span>
<span id="L1982"><span class="lineNum">    1982</span>              : </span>
<span id="L1983"><span class="lineNum">    1983</span> <span class="tlaGNC">           5 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L1984"><span class="lineNum">    1984</span>              : </span>
<span id="L1985"><span class="lineNum">    1985</span> <span class="tlaGNC">           7 : unlock_return:</span></span>
<span id="L1986"><span class="lineNum">    1986</span> <span class="tlaGNC">           7 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L1987"><span class="lineNum">    1987</span> <span class="tlaGNC">           7 :   return ret;</span></span>
<span id="L1988"><span class="lineNum">    1988</span>              : }</span>
<span id="L1989"><span class="lineNum">    1989</span>              : </span>
<span id="L1990"><span class="lineNum">    1990</span>              : /**</span>
<span id="L1991"><span class="lineNum">    1991</span>              :  * @brief Close the given switch handle (more info in nnstreamer.h)</span>
<span id="L1992"><span class="lineNum">    1992</span>              :  */</span>
<span id="L1993"><span class="lineNum">    1993</span>              : int</span>
<span id="L1994"><span class="lineNum">    1994</span> <span class="tlaGNC">           5 : ml_pipeline_switch_release_handle (ml_pipeline_switch_h h)</span></span>
<span id="L1995"><span class="lineNum">    1995</span>              : {</span>
<span id="L1996"><span class="lineNum">    1996</span> <span class="tlaGNC">           5 :   handle_init (swtc, h);</span></span>
<span id="L1997"><span class="lineNum">    1997</span>              : </span>
<span id="L1998"><span class="lineNum">    1998</span> <span class="tlaGNC">           5 :   elem-&gt;handles = g_list_remove (elem-&gt;handles, swtc);</span></span>
<span id="L1999"><span class="lineNum">    1999</span> <span class="tlaGNC">           5 :   free_element_handle (swtc);</span></span>
<span id="L2000"><span class="lineNum">    2000</span>              : </span>
<span id="L2001"><span class="lineNum">    2001</span> <span class="tlaGNC">           5 :   handle_exit (h);</span></span>
<span id="L2002"><span class="lineNum">    2002</span>              : }</span>
<span id="L2003"><span class="lineNum">    2003</span>              : </span>
<span id="L2004"><span class="lineNum">    2004</span>              : /**</span>
<span id="L2005"><span class="lineNum">    2005</span>              :  * @brief Control the switch (more info in nnstreamer.h)</span>
<span id="L2006"><span class="lineNum">    2006</span>              :  */</span>
<span id="L2007"><span class="lineNum">    2007</span>              : int</span>
<span id="L2008"><span class="lineNum">    2008</span> <span class="tlaGNC">           5 : ml_pipeline_switch_select (ml_pipeline_switch_h h, const char *pad_name)</span></span>
<span id="L2009"><span class="lineNum">    2009</span>              : {</span>
<span id="L2010"><span class="lineNum">    2010</span>              :   GstPad *active_pad, *new_pad;</span>
<span id="L2011"><span class="lineNum">    2011</span>              :   gchar *active_name;</span>
<span id="L2012"><span class="lineNum">    2012</span>              : </span>
<span id="L2013"><span class="lineNum">    2013</span> <span class="tlaGNC">           9 :   handle_init (swtc, h);</span></span>
<span id="L2014"><span class="lineNum">    2014</span>              : </span>
<span id="L2015"><span class="lineNum">    2015</span> <span class="tlaGNC">           4 :   if (pad_name == NULL) {</span></span>
<span id="L2016"><span class="lineNum">    2016</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L2017"><span class="lineNum">    2017</span>              :         (&quot;The parameter, pad_name (const char *), is NULL. It should be a valid name of a pad (GSTPAD) in the given switch, h.&quot;);</span>
<span id="L2018"><span class="lineNum">    2018</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2019"><span class="lineNum">    2019</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L2020"><span class="lineNum">    2020</span>              :   }</span>
<span id="L2021"><span class="lineNum">    2021</span>              : </span>
<span id="L2022"><span class="lineNum">    2022</span> <span class="tlaGNC">           3 :   g_object_get (G_OBJECT (elem-&gt;element), &quot;active-pad&quot;, &amp;active_pad, NULL);</span></span>
<span id="L2023"><span class="lineNum">    2023</span> <span class="tlaGNC">           3 :   active_name = gst_pad_get_name (active_pad);</span></span>
<span id="L2024"><span class="lineNum">    2024</span>              : </span>
<span id="L2025"><span class="lineNum">    2025</span> <span class="tlaGNC">           3 :   if (g_strcmp0 (pad_name, active_name) == 0) {</span></span>
<span id="L2026"><span class="lineNum">    2026</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logi (&quot;Switch is called, but there is no effective changes: %s-&gt;%s.&quot;,</span></span>
<span id="L2027"><span class="lineNum">    2027</span>              :         active_name, pad_name);</span>
<span id="L2028"><span class="lineNum">    2028</span> <span class="tlaUNC">           0 :     g_free (active_name);</span></span>
<span id="L2029"><span class="lineNum">    2029</span> <span class="tlaUNC">           0 :     gst_object_unref (active_pad);</span></span>
<span id="L2030"><span class="lineNum">    2030</span>              : </span>
<span id="L2031"><span class="lineNum">    2031</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2032"><span class="lineNum">    2032</span>              :   }</span>
<span id="L2033"><span class="lineNum">    2033</span>              : </span>
<span id="L2034"><span class="lineNum">    2034</span> <span class="tlaGNC tlaBgGNC">           3 :   g_free (active_name);</span></span>
<span id="L2035"><span class="lineNum">    2035</span> <span class="tlaGNC">           3 :   gst_object_unref (active_pad);</span></span>
<span id="L2036"><span class="lineNum">    2036</span>              : </span>
<span id="L2037"><span class="lineNum">    2037</span> <span class="tlaGNC">           3 :   new_pad = gst_element_get_static_pad (elem-&gt;element, pad_name);</span></span>
<span id="L2038"><span class="lineNum">    2038</span> <span class="tlaGNC">           3 :   if (new_pad == NULL) {</span></span>
<span id="L2039"><span class="lineNum">    2039</span>              :     /* Not Found! */</span>
<span id="L2040"><span class="lineNum">    2040</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L2041"><span class="lineNum">    2041</span>              :         (&quot;Cannot find the pad, [%s], from the switch, [%s]. Please check the pad name. You may use ml_pipeline_switch_pad_list() to fetch the valid pad names.&quot;,</span>
<span id="L2042"><span class="lineNum">    2042</span>              :         pad_name, elem-&gt;name);</span>
<span id="L2043"><span class="lineNum">    2043</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2044"><span class="lineNum">    2044</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L2045"><span class="lineNum">    2045</span>              :   }</span>
<span id="L2046"><span class="lineNum">    2046</span>              : </span>
<span id="L2047"><span class="lineNum">    2047</span> <span class="tlaGNC">           2 :   g_object_set (G_OBJECT (elem-&gt;element), &quot;active-pad&quot;, new_pad, NULL);</span></span>
<span id="L2048"><span class="lineNum">    2048</span> <span class="tlaGNC">           2 :   gst_object_unref (new_pad);</span></span>
<span id="L2049"><span class="lineNum">    2049</span>              : </span>
<span id="L2050"><span class="lineNum">    2050</span> <span class="tlaGNC">           2 :   _ml_logi (&quot;Switched to [%s] successfully at switch [%s].&quot;, pad_name,</span></span>
<span id="L2051"><span class="lineNum">    2051</span>              :       elem-&gt;name);</span>
<span id="L2052"><span class="lineNum">    2052</span>              : </span>
<span id="L2053"><span class="lineNum">    2053</span> <span class="tlaGNC">           4 :   handle_exit (h);</span></span>
<span id="L2054"><span class="lineNum">    2054</span>              : }</span>
<span id="L2055"><span class="lineNum">    2055</span>              : </span>
<span id="L2056"><span class="lineNum">    2056</span>              : /**</span>
<span id="L2057"><span class="lineNum">    2057</span>              :  * @brief Gets the pad names of a switch.</span>
<span id="L2058"><span class="lineNum">    2058</span>              :  */</span>
<span id="L2059"><span class="lineNum">    2059</span>              : int</span>
<span id="L2060"><span class="lineNum">    2060</span> <span class="tlaGNC">           2 : ml_pipeline_switch_get_pad_list (ml_pipeline_switch_h h, char ***list)</span></span>
<span id="L2061"><span class="lineNum">    2061</span>              : {</span>
<span id="L2062"><span class="lineNum">    2062</span>              :   GstIterator *it;</span>
<span id="L2063"><span class="lineNum">    2063</span> <span class="tlaGNC">           2 :   GValue item = G_VALUE_INIT;</span></span>
<span id="L2064"><span class="lineNum">    2064</span> <span class="tlaGNC">           2 :   gboolean done = FALSE;</span></span>
<span id="L2065"><span class="lineNum">    2065</span> <span class="tlaGNC">           2 :   GList *dllist = NULL;</span></span>
<span id="L2066"><span class="lineNum">    2066</span>              :   GstPad *pad;</span>
<span id="L2067"><span class="lineNum">    2067</span> <span class="tlaGNC">           2 :   int counter = 0;</span></span>
<span id="L2068"><span class="lineNum">    2068</span>              : </span>
<span id="L2069"><span class="lineNum">    2069</span> <span class="tlaGNC">           4 :   handle_init (swtc, h);</span></span>
<span id="L2070"><span class="lineNum">    2070</span>              : </span>
<span id="L2071"><span class="lineNum">    2071</span> <span class="tlaGNC">           2 :   if (list == NULL) {</span></span>
<span id="L2072"><span class="lineNum">    2072</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2073"><span class="lineNum">    2073</span>              :         (&quot;The parameter, list (char ***), is NULL. It should be a valid pointer to store a list of strings. E.g., char **list; ml_pipeline_switch_get_pad_list (h, &amp;list);&quot;);</span>
<span id="L2074"><span class="lineNum">    2074</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2075"><span class="lineNum">    2075</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2076"><span class="lineNum">    2076</span>              :   }</span>
<span id="L2077"><span class="lineNum">    2077</span>              : </span>
<span id="L2078"><span class="lineNum">    2078</span>              :   /* init null */</span>
<span id="L2079"><span class="lineNum">    2079</span> <span class="tlaGNC tlaBgGNC">           2 :   *list = NULL;</span></span>
<span id="L2080"><span class="lineNum">    2080</span>              : </span>
<span id="L2081"><span class="lineNum">    2081</span> <span class="tlaGNC">           2 :   if (elem-&gt;type == ML_PIPELINE_ELEMENT_SWITCH_INPUT)</span></span>
<span id="L2082"><span class="lineNum">    2082</span> <span class="tlaGNC">           1 :     it = gst_element_iterate_sink_pads (elem-&gt;element);</span></span>
<span id="L2083"><span class="lineNum">    2083</span> <span class="tlaGNC">           1 :   else if (elem-&gt;type == ML_PIPELINE_ELEMENT_SWITCH_OUTPUT)</span></span>
<span id="L2084"><span class="lineNum">    2084</span> <span class="tlaGNC">           1 :     it = gst_element_iterate_src_pads (elem-&gt;element);</span></span>
<span id="L2085"><span class="lineNum">    2085</span>              :   else {</span>
<span id="L2086"><span class="lineNum">    2086</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2087"><span class="lineNum">    2087</span>              :         (&quot;The element, [%s], is supposed to be input/output switch, but it is not. Internal data structure is broken.&quot;,</span>
<span id="L2088"><span class="lineNum">    2088</span>              :         elem-&gt;name);</span>
<span id="L2089"><span class="lineNum">    2089</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L2090"><span class="lineNum">    2090</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2091"><span class="lineNum">    2091</span>              :   }</span>
<span id="L2092"><span class="lineNum">    2092</span>              : </span>
<span id="L2093"><span class="lineNum">    2093</span> <span class="tlaGNC tlaBgGNC">           8 :   while (!done) {</span></span>
<span id="L2094"><span class="lineNum">    2094</span> <span class="tlaGNC">           6 :     switch (gst_iterator_next (it, &amp;item)) {</span></span>
<span id="L2095"><span class="lineNum">    2095</span> <span class="tlaGNC">           4 :       case GST_ITERATOR_OK:</span></span>
<span id="L2096"><span class="lineNum">    2096</span> <span class="tlaGNC">           4 :         pad = GST_PAD (g_value_get_object (&amp;item));</span></span>
<span id="L2097"><span class="lineNum">    2097</span> <span class="tlaGNC">           4 :         dllist = g_list_append (dllist, gst_pad_get_name (pad));</span></span>
<span id="L2098"><span class="lineNum">    2098</span> <span class="tlaGNC">           4 :         counter++;</span></span>
<span id="L2099"><span class="lineNum">    2099</span> <span class="tlaGNC">           4 :         g_value_reset (&amp;item);</span></span>
<span id="L2100"><span class="lineNum">    2100</span> <span class="tlaGNC">           4 :         break;</span></span>
<span id="L2101"><span class="lineNum">    2101</span> <span class="tlaUNC tlaBgUNC">           0 :       case GST_ITERATOR_RESYNC:</span></span>
<span id="L2102"><span class="lineNum">    2102</span> <span class="tlaUNC">           0 :         g_list_free_full (dllist, g_free);      /* This frees all strings as well */</span></span>
<span id="L2103"><span class="lineNum">    2103</span> <span class="tlaUNC">           0 :         dllist = NULL;</span></span>
<span id="L2104"><span class="lineNum">    2104</span> <span class="tlaUNC">           0 :         counter = 0;</span></span>
<span id="L2105"><span class="lineNum">    2105</span> <span class="tlaUNC">           0 :         gst_iterator_resync (it);</span></span>
<span id="L2106"><span class="lineNum">    2106</span> <span class="tlaUNC">           0 :         break;</span></span>
<span id="L2107"><span class="lineNum">    2107</span> <span class="tlaUNC">           0 :       case GST_ITERATOR_ERROR:</span></span>
<span id="L2108"><span class="lineNum">    2108</span> <span class="tlaUNC">           0 :         _ml_error_report</span></span>
<span id="L2109"><span class="lineNum">    2109</span>              :             (&quot;Cannot access the list of pad properly of a switch, [%s]. Internal data structure is broken?&quot;,</span>
<span id="L2110"><span class="lineNum">    2110</span>              :             elem-&gt;name);</span>
<span id="L2111"><span class="lineNum">    2111</span> <span class="tlaUNC">           0 :         ret = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L2112"><span class="lineNum">    2112</span> <span class="tlaUNC">           0 :         break;</span></span>
<span id="L2113"><span class="lineNum">    2113</span> <span class="tlaGNC tlaBgGNC">           2 :       case GST_ITERATOR_DONE:</span></span>
<span id="L2114"><span class="lineNum">    2114</span> <span class="tlaGNC">           2 :         done = TRUE;</span></span>
<span id="L2115"><span class="lineNum">    2115</span> <span class="tlaGNC">           2 :         break;</span></span>
<span id="L2116"><span class="lineNum">    2116</span>              :     }</span>
<span id="L2117"><span class="lineNum">    2117</span>              :   }</span>
<span id="L2118"><span class="lineNum">    2118</span>              : </span>
<span id="L2119"><span class="lineNum">    2119</span> <span class="tlaGNC">           2 :   gst_iterator_free (it);</span></span>
<span id="L2120"><span class="lineNum">    2120</span>              : </span>
<span id="L2121"><span class="lineNum">    2121</span>              :   /* There has been no error with that &quot;while&quot; loop. */</span>
<span id="L2122"><span class="lineNum">    2122</span> <span class="tlaGNC">           2 :   if (ret == ML_ERROR_NONE) {</span></span>
<span id="L2123"><span class="lineNum">    2123</span> <span class="tlaGNC">           2 :     int i = 0;</span></span>
<span id="L2124"><span class="lineNum">    2124</span>              :     GList *l;</span>
<span id="L2125"><span class="lineNum">    2125</span>              : </span>
<span id="L2126"><span class="lineNum">    2126</span> <span class="tlaGNC">           2 :     *list = g_malloc0 (sizeof (char *) * (counter + 1));</span></span>
<span id="L2127"><span class="lineNum">    2127</span> <span class="tlaGNC">           2 :     if (*list == NULL) {</span></span>
<span id="L2128"><span class="lineNum">    2128</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L2129"><span class="lineNum">    2129</span>              :           (&quot;Failed to allocate memory for pad list (parameter list). Out of memory?&quot;);</span>
<span id="L2130"><span class="lineNum">    2130</span> <span class="tlaUNC">           0 :       ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L2131"><span class="lineNum">    2131</span> <span class="tlaUNC">           0 :       g_list_free_full (dllist, g_free);</span></span>
<span id="L2132"><span class="lineNum">    2132</span> <span class="tlaUNC">           0 :       goto unlock_return;</span></span>
<span id="L2133"><span class="lineNum">    2133</span>              :     }</span>
<span id="L2134"><span class="lineNum">    2134</span>              : </span>
<span id="L2135"><span class="lineNum">    2135</span> <span class="tlaGNC tlaBgGNC">           6 :     for (l = dllist; l != NULL; l = l-&gt;next) {</span></span>
<span id="L2136"><span class="lineNum">    2136</span> <span class="tlaGNC">           4 :       (*list)[i] = l-&gt;data;     /* Allocated by gst_pad_get_name(). Caller has to free it */</span></span>
<span id="L2137"><span class="lineNum">    2137</span> <span class="tlaGNC">           4 :       i++;</span></span>
<span id="L2138"><span class="lineNum">    2138</span>              : </span>
<span id="L2139"><span class="lineNum">    2139</span> <span class="tlaGNC">           4 :       if (i &gt; counter) {</span></span>
<span id="L2140"><span class="lineNum">    2140</span> <span class="tlaUNC tlaBgUNC">           0 :         g_list_free_full (dllist, g_free);      /* This frees all strings as well */</span></span>
<span id="L2141"><span class="lineNum">    2141</span> <span class="tlaUNC">           0 :         g_free (*list);</span></span>
<span id="L2142"><span class="lineNum">    2142</span> <span class="tlaUNC">           0 :         *list = NULL;</span></span>
<span id="L2143"><span class="lineNum">    2143</span>              : </span>
<span id="L2144"><span class="lineNum">    2144</span> <span class="tlaUNC">           0 :         _ml_error_report</span></span>
<span id="L2145"><span class="lineNum">    2145</span>              :             (&quot;Internal data inconsistency. This could be a bug in nnstreamer. Switch [%s].&quot;,</span>
<span id="L2146"><span class="lineNum">    2146</span>              :             elem-&gt;name);</span>
<span id="L2147"><span class="lineNum">    2147</span> <span class="tlaUNC">           0 :         ret = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L2148"><span class="lineNum">    2148</span> <span class="tlaUNC">           0 :         goto unlock_return;</span></span>
<span id="L2149"><span class="lineNum">    2149</span>              :       }</span>
<span id="L2150"><span class="lineNum">    2150</span>              :     }</span>
<span id="L2151"><span class="lineNum">    2151</span>              :   }</span>
<span id="L2152"><span class="lineNum">    2152</span> <span class="tlaGNC tlaBgGNC">           2 :   g_list_free (dllist);         /* This does not free the strings.. fortunately. */</span></span>
<span id="L2153"><span class="lineNum">    2153</span>              : </span>
<span id="L2154"><span class="lineNum">    2154</span> <span class="tlaGNC">           2 :   handle_exit (h);</span></span>
<span id="L2155"><span class="lineNum">    2155</span>              : }</span>
<span id="L2156"><span class="lineNum">    2156</span>              : </span>
<span id="L2157"><span class="lineNum">    2157</span>              : /**</span>
<span id="L2158"><span class="lineNum">    2158</span>              :  * @brief Get a handle to operate a Valve (more info in nnstreamer.h)</span>
<span id="L2159"><span class="lineNum">    2159</span>              :  */</span>
<span id="L2160"><span class="lineNum">    2160</span>              : int</span>
<span id="L2161"><span class="lineNum">    2161</span> <span class="tlaGNC">           6 : ml_pipeline_valve_get_handle (ml_pipeline_h pipe, const char *valve_name,</span></span>
<span id="L2162"><span class="lineNum">    2162</span>              :     ml_pipeline_valve_h * h)</span>
<span id="L2163"><span class="lineNum">    2163</span>              : {</span>
<span id="L2164"><span class="lineNum">    2164</span>              :   ml_pipeline_element *elem;</span>
<span id="L2165"><span class="lineNum">    2165</span> <span class="tlaGNC">           6 :   ml_pipeline *p = pipe;</span></span>
<span id="L2166"><span class="lineNum">    2166</span>              :   ml_pipeline_common_elem *valve;</span>
<span id="L2167"><span class="lineNum">    2167</span> <span class="tlaGNC">           6 :   int ret = ML_ERROR_NONE;</span></span>
<span id="L2168"><span class="lineNum">    2168</span>              : </span>
<span id="L2169"><span class="lineNum">    2169</span> <span class="tlaGNC">           6 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L2170"><span class="lineNum">    2170</span>              : </span>
<span id="L2171"><span class="lineNum">    2171</span> <span class="tlaGNC">           6 :   if (h == NULL)</span></span>
<span id="L2172"><span class="lineNum">    2172</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2173"><span class="lineNum">    2173</span>              :         &quot;The parameter, h (ml_pipeline_valve_h), is NULL. It should be a valid pointer of ml_pipeline_valve_h. E.g., ml_pipeline_valve_h h; ml_pipeline_valve_get_handle (..., &amp;h);&quot;);</span>
<span id="L2174"><span class="lineNum">    2174</span>              : </span>
<span id="L2175"><span class="lineNum">    2175</span>              :   /* init null */</span>
<span id="L2176"><span class="lineNum">    2176</span> <span class="tlaGNC">           5 :   *h = NULL;</span></span>
<span id="L2177"><span class="lineNum">    2177</span>              : </span>
<span id="L2178"><span class="lineNum">    2178</span> <span class="tlaGNC">           5 :   if (pipe == NULL)</span></span>
<span id="L2179"><span class="lineNum">    2179</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2180"><span class="lineNum">    2180</span>              :         &quot;The parameter, pipe (ml_pipeline_h), is NULL. It should be a valid ml_pipeline_h instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L2181"><span class="lineNum">    2181</span>              : </span>
<span id="L2182"><span class="lineNum">    2182</span> <span class="tlaGNC">           4 :   if (valve_name == NULL)</span></span>
<span id="L2183"><span class="lineNum">    2183</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2184"><span class="lineNum">    2184</span>              :         &quot;The parameter, valve_name (const char *), is NULL. It should be a valid string of the valve name.&quot;);</span>
<span id="L2185"><span class="lineNum">    2185</span>              : </span>
<span id="L2186"><span class="lineNum">    2186</span> <span class="tlaGNC">           3 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L2187"><span class="lineNum">    2187</span> <span class="tlaGNC">           3 :   elem = g_hash_table_lookup (p-&gt;namednodes, valve_name);</span></span>
<span id="L2188"><span class="lineNum">    2188</span>              : </span>
<span id="L2189"><span class="lineNum">    2189</span> <span class="tlaGNC">           3 :   if (elem == NULL) {</span></span>
<span id="L2190"><span class="lineNum">    2190</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L2191"><span class="lineNum">    2191</span>              :         (&quot;Cannot find the valve with the given name, '%s', in the pipeline. There is no element in the pipeline with such a name. Please check if you have a value with the appropriate name.&quot;,</span>
<span id="L2192"><span class="lineNum">    2192</span>              :         valve_name);</span>
<span id="L2193"><span class="lineNum">    2193</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2194"><span class="lineNum">    2194</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L2195"><span class="lineNum">    2195</span>              :   }</span>
<span id="L2196"><span class="lineNum">    2196</span>              : </span>
<span id="L2197"><span class="lineNum">    2197</span> <span class="tlaGNC">           2 :   if (elem-&gt;type != ML_PIPELINE_ELEMENT_VALVE) {</span></span>
<span id="L2198"><span class="lineNum">    2198</span> <span class="tlaGNC">           1 :     _ml_error_report</span></span>
<span id="L2199"><span class="lineNum">    2199</span>              :         (&quot;Cannot find the value with the given name, '%s', in the pipeline. There is an element with such a name; however, the element is not a valve. Please correct the names of element in the pipeline.&quot;,</span>
<span id="L2200"><span class="lineNum">    2200</span>              :         valve_name);</span>
<span id="L2201"><span class="lineNum">    2201</span> <span class="tlaGNC">           1 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2202"><span class="lineNum">    2202</span> <span class="tlaGNC">           1 :     goto unlock_return;</span></span>
<span id="L2203"><span class="lineNum">    2203</span>              :   }</span>
<span id="L2204"><span class="lineNum">    2204</span>              : </span>
<span id="L2205"><span class="lineNum">    2205</span> <span class="tlaGNC">           1 :   valve = *h = g_new0 (ml_pipeline_common_elem, 1);</span></span>
<span id="L2206"><span class="lineNum">    2206</span> <span class="tlaGNC">           1 :   if (valve == NULL) {</span></span>
<span id="L2207"><span class="lineNum">    2207</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2208"><span class="lineNum">    2208</span>              :         (&quot;Cannot allocate memory for valve handle of %s. Out of memory?&quot;,</span>
<span id="L2209"><span class="lineNum">    2209</span>              :         valve_name);</span>
<span id="L2210"><span class="lineNum">    2210</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L2211"><span class="lineNum">    2211</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2212"><span class="lineNum">    2212</span>              :   }</span>
<span id="L2213"><span class="lineNum">    2213</span>              : </span>
<span id="L2214"><span class="lineNum">    2214</span> <span class="tlaGNC tlaBgGNC">           1 :   valve-&gt;pipe = p;</span></span>
<span id="L2215"><span class="lineNum">    2215</span> <span class="tlaGNC">           1 :   valve-&gt;element = elem;</span></span>
<span id="L2216"><span class="lineNum">    2216</span>              : </span>
<span id="L2217"><span class="lineNum">    2217</span> <span class="tlaGNC">           1 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L2218"><span class="lineNum">    2218</span>              : </span>
<span id="L2219"><span class="lineNum">    2219</span> <span class="tlaGNC">           1 :   elem-&gt;maxid++;</span></span>
<span id="L2220"><span class="lineNum">    2220</span> <span class="tlaGNC">           1 :   valve-&gt;id = elem-&gt;maxid;</span></span>
<span id="L2221"><span class="lineNum">    2221</span> <span class="tlaGNC">           1 :   elem-&gt;handles = g_list_append (elem-&gt;handles, valve);</span></span>
<span id="L2222"><span class="lineNum">    2222</span>              : </span>
<span id="L2223"><span class="lineNum">    2223</span> <span class="tlaGNC">           1 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L2224"><span class="lineNum">    2224</span>              : </span>
<span id="L2225"><span class="lineNum">    2225</span> <span class="tlaGNC">           3 : unlock_return:</span></span>
<span id="L2226"><span class="lineNum">    2226</span> <span class="tlaGNC">           3 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L2227"><span class="lineNum">    2227</span> <span class="tlaGNC">           3 :   return ret;</span></span>
<span id="L2228"><span class="lineNum">    2228</span>              : }</span>
<span id="L2229"><span class="lineNum">    2229</span>              : </span>
<span id="L2230"><span class="lineNum">    2230</span>              : /**</span>
<span id="L2231"><span class="lineNum">    2231</span>              :  * @brief Close the given valve handle (more info in nnstreamer.h)</span>
<span id="L2232"><span class="lineNum">    2232</span>              :  */</span>
<span id="L2233"><span class="lineNum">    2233</span>              : int</span>
<span id="L2234"><span class="lineNum">    2234</span> <span class="tlaGNC">           1 : ml_pipeline_valve_release_handle (ml_pipeline_valve_h h)</span></span>
<span id="L2235"><span class="lineNum">    2235</span>              : {</span>
<span id="L2236"><span class="lineNum">    2236</span> <span class="tlaGNC">           1 :   handle_init (valve, h);</span></span>
<span id="L2237"><span class="lineNum">    2237</span>              : </span>
<span id="L2238"><span class="lineNum">    2238</span> <span class="tlaGNC">           1 :   elem-&gt;handles = g_list_remove (elem-&gt;handles, valve);</span></span>
<span id="L2239"><span class="lineNum">    2239</span> <span class="tlaGNC">           1 :   free_element_handle (valve);</span></span>
<span id="L2240"><span class="lineNum">    2240</span>              : </span>
<span id="L2241"><span class="lineNum">    2241</span> <span class="tlaGNC">           1 :   handle_exit (h);</span></span>
<span id="L2242"><span class="lineNum">    2242</span>              : }</span>
<span id="L2243"><span class="lineNum">    2243</span>              : </span>
<span id="L2244"><span class="lineNum">    2244</span>              : /**</span>
<span id="L2245"><span class="lineNum">    2245</span>              :  * @brief Control the valve with the given handle (more info in nnstreamer.h)</span>
<span id="L2246"><span class="lineNum">    2246</span>              :  */</span>
<span id="L2247"><span class="lineNum">    2247</span>              : int</span>
<span id="L2248"><span class="lineNum">    2248</span> <span class="tlaGNC">           2 : ml_pipeline_valve_set_open (ml_pipeline_valve_h h, bool open)</span></span>
<span id="L2249"><span class="lineNum">    2249</span>              : {</span>
<span id="L2250"><span class="lineNum">    2250</span> <span class="tlaGNC">           2 :   gboolean drop = FALSE;</span></span>
<span id="L2251"><span class="lineNum">    2251</span> <span class="tlaGNC">           4 :   handle_init (valve, h);</span></span>
<span id="L2252"><span class="lineNum">    2252</span>              : </span>
<span id="L2253"><span class="lineNum">    2253</span> <span class="tlaGNC">           2 :   g_object_get (G_OBJECT (elem-&gt;element), &quot;drop&quot;, &amp;drop, NULL);</span></span>
<span id="L2254"><span class="lineNum">    2254</span>              : </span>
<span id="L2255"><span class="lineNum">    2255</span> <span class="tlaGNC">           2 :   if ((open != false) != (drop != FALSE)) {</span></span>
<span id="L2256"><span class="lineNum">    2256</span>              :     /* Nothing to do */</span>
<span id="L2257"><span class="lineNum">    2257</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_logi (&quot;Valve is called, but there is no effective changes&quot;);</span></span>
<span id="L2258"><span class="lineNum">    2258</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2259"><span class="lineNum">    2259</span>              :   }</span>
<span id="L2260"><span class="lineNum">    2260</span>              : </span>
<span id="L2261"><span class="lineNum">    2261</span> <span class="tlaGNC tlaBgGNC">           2 :   drop = (open) ? FALSE : TRUE;</span></span>
<span id="L2262"><span class="lineNum">    2262</span> <span class="tlaGNC">           2 :   g_object_set (G_OBJECT (elem-&gt;element), &quot;drop&quot;, drop, NULL);</span></span>
<span id="L2263"><span class="lineNum">    2263</span>              : </span>
<span id="L2264"><span class="lineNum">    2264</span> <span class="tlaGNC">           2 :   handle_exit (h);</span></span>
<span id="L2265"><span class="lineNum">    2265</span>              : }</span>
<span id="L2266"><span class="lineNum">    2266</span>              : </span>
<span id="L2267"><span class="lineNum">    2267</span>              : /********************************************************</span>
<span id="L2268"><span class="lineNum">    2268</span>              :  ** NNStreamer Element Property Control in Pipeline    **</span>
<span id="L2269"><span class="lineNum">    2269</span>              :  ********************************************************/</span>
<span id="L2270"><span class="lineNum">    2270</span>              : /**</span>
<span id="L2271"><span class="lineNum">    2271</span>              :  * @brief Gets an element handle in NNStreamer pipelines to control its properties.</span>
<span id="L2272"><span class="lineNum">    2272</span>              :  */</span>
<span id="L2273"><span class="lineNum">    2273</span>              : int</span>
<span id="L2274"><span class="lineNum">    2274</span> <span class="tlaGNC">          64 : ml_pipeline_element_get_handle (ml_pipeline_h pipe, const char *element_name,</span></span>
<span id="L2275"><span class="lineNum">    2275</span>              :     ml_pipeline_element_h * elem_h)</span>
<span id="L2276"><span class="lineNum">    2276</span>              : {</span>
<span id="L2277"><span class="lineNum">    2277</span> <span class="tlaGNC">          64 :   int ret = ML_ERROR_NONE;</span></span>
<span id="L2278"><span class="lineNum">    2278</span>              :   ml_pipeline_element *elem;</span>
<span id="L2279"><span class="lineNum">    2279</span>              :   ml_pipeline_common_elem *common_elem;</span>
<span id="L2280"><span class="lineNum">    2280</span> <span class="tlaGNC">          64 :   ml_pipeline *p = pipe;</span></span>
<span id="L2281"><span class="lineNum">    2281</span>              : </span>
<span id="L2282"><span class="lineNum">    2282</span>              :   /* Check input parameter */</span>
<span id="L2283"><span class="lineNum">    2283</span> <span class="tlaGNC">          64 :   if (pipe == NULL)</span></span>
<span id="L2284"><span class="lineNum">    2284</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2285"><span class="lineNum">    2285</span>              :         &quot;The parameter, pipe (ml_pipeline_h), is NULL. It should be a valid ml_pipeline_h instance, which is usually created by ml_pipeline_construct().&quot;);</span>
<span id="L2286"><span class="lineNum">    2286</span>              : </span>
<span id="L2287"><span class="lineNum">    2287</span> <span class="tlaGNC tlaBgGNC">          64 :   if (element_name == NULL)</span></span>
<span id="L2288"><span class="lineNum">    2288</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2289"><span class="lineNum">    2289</span>              :         &quot;The parameter, element_name (const char *), is NULL. It should be a valid string of the element name to be searched.&quot;);</span>
<span id="L2290"><span class="lineNum">    2290</span>              : </span>
<span id="L2291"><span class="lineNum">    2291</span> <span class="tlaGNC">          63 :   if (elem_h == NULL)</span></span>
<span id="L2292"><span class="lineNum">    2292</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2293"><span class="lineNum">    2293</span>              :         &quot;The parameter, elem_h (ml_pipeline_element_h), is NULL. It should be a valid pointer of ml_pipeline_element_h. E.g., ml_pipeline_element_h eh; ml_pipeline_element_get_handle (..., &amp;eh);&quot;);</span>
<span id="L2294"><span class="lineNum">    2294</span> <span class="tlaGNC tlaBgGNC">          63 :   *elem_h = NULL;</span></span>
<span id="L2295"><span class="lineNum">    2295</span>              : </span>
<span id="L2296"><span class="lineNum">    2296</span> <span class="tlaGNC">          63 :   g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L2297"><span class="lineNum">    2297</span>              : </span>
<span id="L2298"><span class="lineNum">    2298</span>              :   /* 1. Search element in lookup table first */</span>
<span id="L2299"><span class="lineNum">    2299</span> <span class="tlaGNC">          63 :   elem = g_hash_table_lookup (p-&gt;namednodes, element_name);</span></span>
<span id="L2300"><span class="lineNum">    2300</span> <span class="tlaGNC">          63 :   if (elem == NULL) {</span></span>
<span id="L2301"><span class="lineNum">    2301</span>              :     /* 2. Search element in pipeline itself */</span>
<span id="L2302"><span class="lineNum">    2302</span>              :     GstElement *gst_elem;</span>
<span id="L2303"><span class="lineNum">    2303</span>              : </span>
<span id="L2304"><span class="lineNum">    2304</span> <span class="tlaGNC">          49 :     gst_elem = gst_bin_get_by_name (GST_BIN (p-&gt;element), element_name);</span></span>
<span id="L2305"><span class="lineNum">    2305</span> <span class="tlaGNC">          49 :     if (gst_elem == NULL) {</span></span>
<span id="L2306"><span class="lineNum">    2306</span> <span class="tlaGNC">           1 :       _ml_error_report</span></span>
<span id="L2307"><span class="lineNum">    2307</span>              :           (&quot;Cannot find the element with the given name, '%s', in the pipeline. There is no element in the pipeline with such a name. Please check if you have an element with the appropriate name.&quot;,</span>
<span id="L2308"><span class="lineNum">    2308</span>              :           element_name);</span>
<span id="L2309"><span class="lineNum">    2309</span> <span class="tlaGNC">           1 :       ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2310"><span class="lineNum">    2310</span> <span class="tlaGNC">           1 :       goto unlock_return;</span></span>
<span id="L2311"><span class="lineNum">    2311</span>              :     }</span>
<span id="L2312"><span class="lineNum">    2312</span>              : </span>
<span id="L2313"><span class="lineNum">    2313</span>              :     /* Caching for next search */</span>
<span id="L2314"><span class="lineNum">    2314</span> <span class="tlaGNC">          48 :     elem = construct_element (gst_elem, pipe, element_name,</span></span>
<span id="L2315"><span class="lineNum">    2315</span>              :         ML_PIPELINE_ELEMENT_COMMON);</span>
<span id="L2316"><span class="lineNum">    2316</span> <span class="tlaGNC">          48 :     if (elem == NULL) {</span></span>
<span id="L2317"><span class="lineNum">    2317</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L2318"><span class="lineNum">    2318</span>              :           (&quot;Cannot allocate memory for element handle of %s. Out of memory?&quot;,</span>
<span id="L2319"><span class="lineNum">    2319</span>              :           element_name);</span>
<span id="L2320"><span class="lineNum">    2320</span> <span class="tlaUNC">           0 :       ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L2321"><span class="lineNum">    2321</span> <span class="tlaUNC">           0 :       goto unlock_return;</span></span>
<span id="L2322"><span class="lineNum">    2322</span>              :     }</span>
<span id="L2323"><span class="lineNum">    2323</span> <span class="tlaGNC tlaBgGNC">          48 :     g_hash_table_insert (p-&gt;namednodes, g_strdup (element_name), elem);</span></span>
<span id="L2324"><span class="lineNum">    2324</span>              :   }</span>
<span id="L2325"><span class="lineNum">    2325</span>              : </span>
<span id="L2326"><span class="lineNum">    2326</span>              :   /* Type checking */</span>
<span id="L2327"><span class="lineNum">    2327</span> <span class="tlaGNC">          62 :   if (elem-&gt;type == ML_PIPELINE_ELEMENT_UNKNOWN) {</span></span>
<span id="L2328"><span class="lineNum">    2328</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2329"><span class="lineNum">    2329</span>              :         (&quot;There is an element named [%s] in the pipeline, but its type is unknown. It is possible that the app thread has touched ML-API's internal data structure.&quot;,</span>
<span id="L2330"><span class="lineNum">    2330</span>              :         element_name);</span>
<span id="L2331"><span class="lineNum">    2331</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2332"><span class="lineNum">    2332</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2333"><span class="lineNum">    2333</span>              :   }</span>
<span id="L2334"><span class="lineNum">    2334</span>              : </span>
<span id="L2335"><span class="lineNum">    2335</span> <span class="tlaGNC tlaBgGNC">          62 :   common_elem = *elem_h = g_new0 (ml_pipeline_common_elem, 1);</span></span>
<span id="L2336"><span class="lineNum">    2336</span> <span class="tlaGNC">          62 :   if (common_elem == NULL) {</span></span>
<span id="L2337"><span class="lineNum">    2337</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2338"><span class="lineNum">    2338</span>              :         (&quot;Failed to allocate the internal handler for %s. Out of memory?&quot;,</span>
<span id="L2339"><span class="lineNum">    2339</span>              :         element_name);</span>
<span id="L2340"><span class="lineNum">    2340</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L2341"><span class="lineNum">    2341</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2342"><span class="lineNum">    2342</span>              :   }</span>
<span id="L2343"><span class="lineNum">    2343</span>              : </span>
<span id="L2344"><span class="lineNum">    2344</span> <span class="tlaGNC tlaBgGNC">          62 :   common_elem-&gt;pipe = p;</span></span>
<span id="L2345"><span class="lineNum">    2345</span> <span class="tlaGNC">          62 :   common_elem-&gt;element = elem;</span></span>
<span id="L2346"><span class="lineNum">    2346</span>              : </span>
<span id="L2347"><span class="lineNum">    2347</span> <span class="tlaGNC">          62 :   g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L2348"><span class="lineNum">    2348</span> <span class="tlaGNC">          62 :   elem-&gt;maxid++;</span></span>
<span id="L2349"><span class="lineNum">    2349</span> <span class="tlaGNC">          62 :   common_elem-&gt;id = elem-&gt;maxid;</span></span>
<span id="L2350"><span class="lineNum">    2350</span> <span class="tlaGNC">          62 :   elem-&gt;handles = g_list_append (elem-&gt;handles, common_elem);</span></span>
<span id="L2351"><span class="lineNum">    2351</span> <span class="tlaGNC">          62 :   g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L2352"><span class="lineNum">    2352</span>              : </span>
<span id="L2353"><span class="lineNum">    2353</span> <span class="tlaGNC">          63 : unlock_return:</span></span>
<span id="L2354"><span class="lineNum">    2354</span> <span class="tlaGNC">          63 :   g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L2355"><span class="lineNum">    2355</span> <span class="tlaGNC">          63 :   return ret;</span></span>
<span id="L2356"><span class="lineNum">    2356</span>              : }</span>
<span id="L2357"><span class="lineNum">    2357</span>              : </span>
<span id="L2358"><span class="lineNum">    2358</span>              : /**</span>
<span id="L2359"><span class="lineNum">    2359</span>              :  * @brief Releases the given element handle.</span>
<span id="L2360"><span class="lineNum">    2360</span>              :  */</span>
<span id="L2361"><span class="lineNum">    2361</span>              : int</span>
<span id="L2362"><span class="lineNum">    2362</span> <span class="tlaGNC">          62 : ml_pipeline_element_release_handle (ml_pipeline_element_h elem_h)</span></span>
<span id="L2363"><span class="lineNum">    2363</span>              : {</span>
<span id="L2364"><span class="lineNum">    2364</span> <span class="tlaGNC">          62 :   handle_init (common_elem, elem_h);</span></span>
<span id="L2365"><span class="lineNum">    2365</span>              : </span>
<span id="L2366"><span class="lineNum">    2366</span> <span class="tlaGNC">          61 :   elem-&gt;handles = g_list_remove (elem-&gt;handles, common_elem);</span></span>
<span id="L2367"><span class="lineNum">    2367</span> <span class="tlaGNC">          61 :   free_element_handle (common_elem);</span></span>
<span id="L2368"><span class="lineNum">    2368</span>              : </span>
<span id="L2369"><span class="lineNum">    2369</span> <span class="tlaGNC">          61 :   handle_exit (elem_h);</span></span>
<span id="L2370"><span class="lineNum">    2370</span>              : }</span>
<span id="L2371"><span class="lineNum">    2371</span>              : </span>
<span id="L2372"><span class="lineNum">    2372</span>              : /**</span>
<span id="L2373"><span class="lineNum">    2373</span>              :  * @brief Check property existence and its type.</span>
<span id="L2374"><span class="lineNum">    2374</span>              :  */</span>
<span id="L2375"><span class="lineNum">    2375</span>              : static bool</span>
<span id="L2376"><span class="lineNum">    2376</span> <span class="tlaGNC">         109 : ml_pipeline_element_check_property (GObjectClass * klass,</span></span>
<span id="L2377"><span class="lineNum">    2377</span>              :     const char *property_name, const GType type)</span>
<span id="L2378"><span class="lineNum">    2378</span>              : {</span>
<span id="L2379"><span class="lineNum">    2379</span> <span class="tlaGNC">         109 :   GParamSpec *pspec = NULL;</span></span>
<span id="L2380"><span class="lineNum">    2380</span>              : </span>
<span id="L2381"><span class="lineNum">    2381</span>              :   /* Check property existence */</span>
<span id="L2382"><span class="lineNum">    2382</span> <span class="tlaGNC">         109 :   pspec = g_object_class_find_property (klass, property_name);</span></span>
<span id="L2383"><span class="lineNum">    2383</span> <span class="tlaGNC">         109 :   if (pspec == NULL) {</span></span>
<span id="L2384"><span class="lineNum">    2384</span> <span class="tlaGNC">          16 :     _ml_logw (&quot;The property name [%s] does not exist.&quot;, property_name);</span></span>
<span id="L2385"><span class="lineNum">    2385</span> <span class="tlaGNC">          16 :     return FALSE;</span></span>
<span id="L2386"><span class="lineNum">    2386</span>              :   }</span>
<span id="L2387"><span class="lineNum">    2387</span>              : </span>
<span id="L2388"><span class="lineNum">    2388</span>              :   /* Compare property's type with given type */</span>
<span id="L2389"><span class="lineNum">    2389</span> <span class="tlaGNC">         109 :   if (!((pspec-&gt;value_type == type) ||</span></span>
<span id="L2390"><span class="lineNum">    2390</span> <span class="tlaGNC">          33 :           (type == G_TYPE_ENUM &amp;&amp; G_TYPE_IS_ENUM (pspec-&gt;value_type)) ||</span></span>
<span id="L2391"><span class="lineNum">    2391</span> <span class="tlaGNC">          22 :           (type == G_TYPE_INT64 &amp;&amp; pspec-&gt;value_type == G_TYPE_LONG) ||</span></span>
<span id="L2392"><span class="lineNum">    2392</span> <span class="tlaGNC">          22 :           (type == G_TYPE_UINT64 &amp;&amp; pspec-&gt;value_type == G_TYPE_ULONG) ||</span></span>
<span id="L2393"><span class="lineNum">    2393</span> <span class="tlaGNC">          22 :           (type == G_TYPE_INT &amp;&amp; G_TYPE_IS_ENUM (pspec-&gt;value_type)) ||</span></span>
<span id="L2394"><span class="lineNum">    2394</span> <span class="tlaGNC">           5 :           (type == G_TYPE_UINT &amp;&amp; G_TYPE_IS_ENUM (pspec-&gt;value_type)) ||</span></span>
<span id="L2395"><span class="lineNum">    2395</span> <span class="tlaGNC">           2 :           (type == G_TYPE_DOUBLE &amp;&amp; pspec-&gt;value_type == G_TYPE_FLOAT))) {</span></span>
<span id="L2396"><span class="lineNum">    2396</span> <span class="tlaGNC">          16 :     _ml_logw (&quot;The type of property name [%s] is '%s'&quot;, property_name,</span></span>
<span id="L2397"><span class="lineNum">    2397</span>              :         g_type_name (pspec-&gt;value_type));</span>
<span id="L2398"><span class="lineNum">    2398</span> <span class="tlaGNC">          16 :     return FALSE;</span></span>
<span id="L2399"><span class="lineNum">    2399</span>              :   }</span>
<span id="L2400"><span class="lineNum">    2400</span> <span class="tlaGNC">          77 :   return TRUE;</span></span>
<span id="L2401"><span class="lineNum">    2401</span>              : }</span>
<span id="L2402"><span class="lineNum">    2402</span>              : </span>
<span id="L2403"><span class="lineNum">    2403</span>              : /**</span>
<span id="L2404"><span class="lineNum">    2404</span>              :  * @brief Sets the value of given element's property in NNStreamer pipelines.</span>
<span id="L2405"><span class="lineNum">    2405</span>              :  */</span>
<span id="L2406"><span class="lineNum">    2406</span>              : static int</span>
<span id="L2407"><span class="lineNum">    2407</span> <span class="tlaGNC">          83 : ml_pipeline_element_set_property (ml_pipeline_element_h elem_h,</span></span>
<span id="L2408"><span class="lineNum">    2408</span>              :     const char *property_name, gpointer value, GType type)</span>
<span id="L2409"><span class="lineNum">    2409</span>              : {</span>
<span id="L2410"><span class="lineNum">    2410</span> <span class="tlaGNC">          83 :   handle_init (common_elem, elem_h);</span></span>
<span id="L2411"><span class="lineNum">    2411</span>              : </span>
<span id="L2412"><span class="lineNum">    2412</span>              :   /* Check the input parameter */</span>
<span id="L2413"><span class="lineNum">    2413</span> <span class="tlaGNC">          75 :   if (property_name == NULL) {</span></span>
<span id="L2414"><span class="lineNum">    2414</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2415"><span class="lineNum">    2415</span>              :         (&quot;The parameter, property_name (const char *), is NULL. It should be a valid string of property name.&quot;);</span>
<span id="L2416"><span class="lineNum">    2416</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2417"><span class="lineNum">    2417</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2418"><span class="lineNum">    2418</span>              :   }</span>
<span id="L2419"><span class="lineNum">    2419</span>              : </span>
<span id="L2420"><span class="lineNum">    2420</span>              :   /* Check property existence &amp; its type */</span>
<span id="L2421"><span class="lineNum">    2421</span> <span class="tlaGNC tlaBgGNC">          75 :   if (!ml_pipeline_element_check_property (G_OBJECT_GET_CLASS (elem-&gt;element),</span></span>
<span id="L2422"><span class="lineNum">    2422</span>              :           property_name, type)) {</span>
<span id="L2423"><span class="lineNum">    2423</span> <span class="tlaGNC">          16 :     _ml_error_report</span></span>
<span id="L2424"><span class="lineNum">    2424</span>              :         (&quot;The property ('%s') of the element, '%s', cannot be checked. It looks like this property does not exist in this element.&quot;,</span>
<span id="L2425"><span class="lineNum">    2425</span>              :         property_name, elem-&gt;name);</span>
<span id="L2426"><span class="lineNum">    2426</span> <span class="tlaGNC">          16 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2427"><span class="lineNum">    2427</span> <span class="tlaGNC">          16 :     goto unlock_return;</span></span>
<span id="L2428"><span class="lineNum">    2428</span>              :   }</span>
<span id="L2429"><span class="lineNum">    2429</span>              : </span>
<span id="L2430"><span class="lineNum">    2430</span>              :   /* Set property */</span>
<span id="L2431"><span class="lineNum">    2431</span> <span class="tlaGNC">          59 :   if (type == G_TYPE_DOUBLE || type == G_TYPE_FLOAT) {</span></span>
<span id="L2432"><span class="lineNum">    2432</span> <span class="tlaGNC">           7 :     g_object_set (G_OBJECT (elem-&gt;element), property_name,</span></span>
<span id="L2433"><span class="lineNum">    2433</span>              :         *(double *) value, NULL);</span>
<span id="L2434"><span class="lineNum">    2434</span> <span class="tlaGNC">          52 :   } else if (type == G_TYPE_INT64) {</span></span>
<span id="L2435"><span class="lineNum">    2435</span> <span class="tlaGNC">           7 :     g_object_set (G_OBJECT (elem-&gt;element), property_name,</span></span>
<span id="L2436"><span class="lineNum">    2436</span>              :         *(int64_t *) value, NULL);</span>
<span id="L2437"><span class="lineNum">    2437</span> <span class="tlaGNC">          45 :   } else if (type == G_TYPE_UINT64) {</span></span>
<span id="L2438"><span class="lineNum">    2438</span> <span class="tlaGNC">           7 :     g_object_set (G_OBJECT (elem-&gt;element), property_name,</span></span>
<span id="L2439"><span class="lineNum">    2439</span>              :         *(uint64_t *) value, NULL);</span>
<span id="L2440"><span class="lineNum">    2440</span>              :   } else {</span>
<span id="L2441"><span class="lineNum">    2441</span> <span class="tlaGNC">          38 :     g_object_set (G_OBJECT (elem-&gt;element), property_name, value, NULL);</span></span>
<span id="L2442"><span class="lineNum">    2442</span>              :   }</span>
<span id="L2443"><span class="lineNum">    2443</span>              : </span>
<span id="L2444"><span class="lineNum">    2444</span> <span class="tlaGNC">          75 :   handle_exit (elem_h);</span></span>
<span id="L2445"><span class="lineNum">    2445</span>              : }</span>
<span id="L2446"><span class="lineNum">    2446</span>              : </span>
<span id="L2447"><span class="lineNum">    2447</span>              : /**</span>
<span id="L2448"><span class="lineNum">    2448</span>              :  * @brief Gets the value of given element's property in NNStreamer pipelines.</span>
<span id="L2449"><span class="lineNum">    2449</span>              :  */</span>
<span id="L2450"><span class="lineNum">    2450</span>              : static int</span>
<span id="L2451"><span class="lineNum">    2451</span> <span class="tlaGNC">          50 : ml_pipeline_element_get_property (ml_pipeline_element_h elem_h,</span></span>
<span id="L2452"><span class="lineNum">    2452</span>              :     const char *property_name, GType type, gpointer pvalue)</span>
<span id="L2453"><span class="lineNum">    2453</span>              : {</span>
<span id="L2454"><span class="lineNum">    2454</span> <span class="tlaGNC">          50 :   handle_init (common_elem, elem_h);</span></span>
<span id="L2455"><span class="lineNum">    2455</span>              : </span>
<span id="L2456"><span class="lineNum">    2456</span>              :   /* Check the input parameter */</span>
<span id="L2457"><span class="lineNum">    2457</span> <span class="tlaGNC">          42 :   if (property_name == NULL) {</span></span>
<span id="L2458"><span class="lineNum">    2458</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2459"><span class="lineNum">    2459</span>              :         (&quot;The parameter, property_name (const char *), is NULL. It should be a valid string of the property name of an element.&quot;);</span>
<span id="L2460"><span class="lineNum">    2460</span> <span class="tlaUNC">           0 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2461"><span class="lineNum">    2461</span> <span class="tlaUNC">           0 :     goto unlock_return;</span></span>
<span id="L2462"><span class="lineNum">    2462</span>              :   }</span>
<span id="L2463"><span class="lineNum">    2463</span>              : </span>
<span id="L2464"><span class="lineNum">    2464</span> <span class="tlaGNC tlaBgGNC">          42 :   if (pvalue == NULL) {</span></span>
<span id="L2465"><span class="lineNum">    2465</span> <span class="tlaGNC">           8 :     _ml_error_report</span></span>
<span id="L2466"><span class="lineNum">    2466</span>              :         (&quot;The parameter, pvalue (gpointer / a pointer of a value), is NULL. It should be a valid gpointer (a pointer of a value). E.g., char *str; ... ml_pipeline_get_property_string (... &amp;str); ... int32_t val; ... ml_pipeline_get_property_int32 (..., &amp;val);&quot;);</span>
<span id="L2467"><span class="lineNum">    2467</span> <span class="tlaGNC">           8 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2468"><span class="lineNum">    2468</span> <span class="tlaGNC">           8 :     goto unlock_return;</span></span>
<span id="L2469"><span class="lineNum">    2469</span>              :   }</span>
<span id="L2470"><span class="lineNum">    2470</span>              : </span>
<span id="L2471"><span class="lineNum">    2471</span>              :   /* Check property existence &amp; its type */</span>
<span id="L2472"><span class="lineNum">    2472</span> <span class="tlaGNC">          34 :   if (!ml_pipeline_element_check_property (G_OBJECT_GET_CLASS (elem-&gt;element),</span></span>
<span id="L2473"><span class="lineNum">    2473</span>              :           property_name, type)) {</span>
<span id="L2474"><span class="lineNum">    2474</span> <span class="tlaGNC">          16 :     _ml_error_report</span></span>
<span id="L2475"><span class="lineNum">    2475</span>              :         (&quot;Cannot check the property ('%s') or the element ('%s'). Please check if you have the corresponding element in the pipeline.&quot;,</span>
<span id="L2476"><span class="lineNum">    2476</span>              :         property_name, elem-&gt;name);</span>
<span id="L2477"><span class="lineNum">    2477</span> <span class="tlaGNC">          16 :     ret = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2478"><span class="lineNum">    2478</span> <span class="tlaGNC">          16 :     goto unlock_return;</span></span>
<span id="L2479"><span class="lineNum">    2479</span>              :   }</span>
<span id="L2480"><span class="lineNum">    2480</span>              : </span>
<span id="L2481"><span class="lineNum">    2481</span>              :   /* Get property */</span>
<span id="L2482"><span class="lineNum">    2482</span> <span class="tlaGNC">          18 :   g_object_get (G_OBJECT (elem-&gt;element), property_name, pvalue, NULL);</span></span>
<span id="L2483"><span class="lineNum">    2483</span>              : </span>
<span id="L2484"><span class="lineNum">    2484</span> <span class="tlaGNC">          42 :   handle_exit (elem_h);</span></span>
<span id="L2485"><span class="lineNum">    2485</span>              : }</span>
<span id="L2486"><span class="lineNum">    2486</span>              : </span>
<span id="L2487"><span class="lineNum">    2487</span>              : /**</span>
<span id="L2488"><span class="lineNum">    2488</span>              :  * @brief Sets the boolean value of element's property in NNStreamer pipelines.</span>
<span id="L2489"><span class="lineNum">    2489</span>              :  */</span>
<span id="L2490"><span class="lineNum">    2490</span>              : int</span>
<span id="L2491"><span class="lineNum">    2491</span> <span class="tlaGNC">          11 : ml_pipeline_element_set_property_bool (ml_pipeline_element_h elem_h,</span></span>
<span id="L2492"><span class="lineNum">    2492</span>              :     const char *property_name, const int32_t value)</span>
<span id="L2493"><span class="lineNum">    2493</span>              : {</span>
<span id="L2494"><span class="lineNum">    2494</span> <span class="tlaGNC">          11 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2495"><span class="lineNum">    2495</span> <span class="tlaGNC">          11 :       GINT_TO_POINTER (value), G_TYPE_BOOLEAN);</span></span>
<span id="L2496"><span class="lineNum">    2496</span>              : }</span>
<span id="L2497"><span class="lineNum">    2497</span>              : </span>
<span id="L2498"><span class="lineNum">    2498</span>              : /**</span>
<span id="L2499"><span class="lineNum">    2499</span>              :  * @brief Sets the string value of element's property in NNStreamer pipelines.</span>
<span id="L2500"><span class="lineNum">    2500</span>              :  */</span>
<span id="L2501"><span class="lineNum">    2501</span>              : int</span>
<span id="L2502"><span class="lineNum">    2502</span> <span class="tlaGNC">           6 : ml_pipeline_element_set_property_string (ml_pipeline_element_h elem_h,</span></span>
<span id="L2503"><span class="lineNum">    2503</span>              :     const char *property_name, const char *value)</span>
<span id="L2504"><span class="lineNum">    2504</span>              : {</span>
<span id="L2505"><span class="lineNum">    2505</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2506"><span class="lineNum">    2506</span>              :       (gpointer) value, G_TYPE_STRING);</span>
<span id="L2507"><span class="lineNum">    2507</span>              : }</span>
<span id="L2508"><span class="lineNum">    2508</span>              : </span>
<span id="L2509"><span class="lineNum">    2509</span>              : /**</span>
<span id="L2510"><span class="lineNum">    2510</span>              :  * @brief Sets the integer value of element's property in NNStreamer pipelines.</span>
<span id="L2511"><span class="lineNum">    2511</span>              :  */</span>
<span id="L2512"><span class="lineNum">    2512</span>              : int</span>
<span id="L2513"><span class="lineNum">    2513</span> <span class="tlaGNC">          12 : ml_pipeline_element_set_property_int32 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2514"><span class="lineNum">    2514</span>              :     const char *property_name, const int32_t value)</span>
<span id="L2515"><span class="lineNum">    2515</span>              : {</span>
<span id="L2516"><span class="lineNum">    2516</span> <span class="tlaGNC">          12 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2517"><span class="lineNum">    2517</span> <span class="tlaGNC">          12 :       GINT_TO_POINTER (value), G_TYPE_INT);</span></span>
<span id="L2518"><span class="lineNum">    2518</span>              : }</span>
<span id="L2519"><span class="lineNum">    2519</span>              : </span>
<span id="L2520"><span class="lineNum">    2520</span>              : /**</span>
<span id="L2521"><span class="lineNum">    2521</span>              :  * @brief Sets the integer 64bit value of element's property in NNStreamer pipelines.</span>
<span id="L2522"><span class="lineNum">    2522</span>              :  */</span>
<span id="L2523"><span class="lineNum">    2523</span>              : int</span>
<span id="L2524"><span class="lineNum">    2524</span> <span class="tlaGNC">          10 : ml_pipeline_element_set_property_int64 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2525"><span class="lineNum">    2525</span>              :     const char *property_name, const int64_t value)</span>
<span id="L2526"><span class="lineNum">    2526</span>              : {</span>
<span id="L2527"><span class="lineNum">    2527</span> <span class="tlaGNC">          10 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2528"><span class="lineNum">    2528</span>              :       (gpointer) (&amp;value), G_TYPE_INT64);</span>
<span id="L2529"><span class="lineNum">    2529</span>              : }</span>
<span id="L2530"><span class="lineNum">    2530</span>              : </span>
<span id="L2531"><span class="lineNum">    2531</span>              : /**</span>
<span id="L2532"><span class="lineNum">    2532</span>              :  * @brief Sets the unsigned integer value of element's property in NNStreamer pipelines.</span>
<span id="L2533"><span class="lineNum">    2533</span>              :  */</span>
<span id="L2534"><span class="lineNum">    2534</span>              : int</span>
<span id="L2535"><span class="lineNum">    2535</span> <span class="tlaGNC">          12 : ml_pipeline_element_set_property_uint32 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2536"><span class="lineNum">    2536</span>              :     const char *property_name, const uint32_t value)</span>
<span id="L2537"><span class="lineNum">    2537</span>              : {</span>
<span id="L2538"><span class="lineNum">    2538</span> <span class="tlaGNC">          12 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2539"><span class="lineNum">    2539</span> <span class="tlaGNC">          12 :       GUINT_TO_POINTER (value), G_TYPE_UINT);</span></span>
<span id="L2540"><span class="lineNum">    2540</span>              : }</span>
<span id="L2541"><span class="lineNum">    2541</span>              : </span>
<span id="L2542"><span class="lineNum">    2542</span>              : /**</span>
<span id="L2543"><span class="lineNum">    2543</span>              :  * @brief Sets the unsigned integer 64bit value of element's property in NNStreamer pipelines.</span>
<span id="L2544"><span class="lineNum">    2544</span>              :  */</span>
<span id="L2545"><span class="lineNum">    2545</span>              : int</span>
<span id="L2546"><span class="lineNum">    2546</span> <span class="tlaGNC">          10 : ml_pipeline_element_set_property_uint64 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2547"><span class="lineNum">    2547</span>              :     const char *property_name, const uint64_t value)</span>
<span id="L2548"><span class="lineNum">    2548</span>              : {</span>
<span id="L2549"><span class="lineNum">    2549</span> <span class="tlaGNC">          10 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2550"><span class="lineNum">    2550</span>              :       (gpointer) (&amp;value), G_TYPE_UINT64);</span>
<span id="L2551"><span class="lineNum">    2551</span>              : }</span>
<span id="L2552"><span class="lineNum">    2552</span>              : </span>
<span id="L2553"><span class="lineNum">    2553</span>              : /**</span>
<span id="L2554"><span class="lineNum">    2554</span>              :  * @brief Sets the floating point value of element's property in NNStreamer pipelines.</span>
<span id="L2555"><span class="lineNum">    2555</span>              :  */</span>
<span id="L2556"><span class="lineNum">    2556</span>              : int</span>
<span id="L2557"><span class="lineNum">    2557</span> <span class="tlaGNC">          10 : ml_pipeline_element_set_property_double (ml_pipeline_element_h elem_h,</span></span>
<span id="L2558"><span class="lineNum">    2558</span>              :     const char *property_name, const double value)</span>
<span id="L2559"><span class="lineNum">    2559</span>              : {</span>
<span id="L2560"><span class="lineNum">    2560</span> <span class="tlaGNC">          10 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2561"><span class="lineNum">    2561</span>              :       (gpointer) (&amp;value), G_TYPE_DOUBLE);</span>
<span id="L2562"><span class="lineNum">    2562</span>              : }</span>
<span id="L2563"><span class="lineNum">    2563</span>              : </span>
<span id="L2564"><span class="lineNum">    2564</span>              : /**</span>
<span id="L2565"><span class="lineNum">    2565</span>              :  * @brief Sets the enumeration value of element's property in NNStreamer pipelines.</span>
<span id="L2566"><span class="lineNum">    2566</span>              :  */</span>
<span id="L2567"><span class="lineNum">    2567</span>              : int</span>
<span id="L2568"><span class="lineNum">    2568</span> <span class="tlaGNC">          12 : ml_pipeline_element_set_property_enum (ml_pipeline_element_h elem_h,</span></span>
<span id="L2569"><span class="lineNum">    2569</span>              :     const char *property_name, const uint32_t value)</span>
<span id="L2570"><span class="lineNum">    2570</span>              : {</span>
<span id="L2571"><span class="lineNum">    2571</span> <span class="tlaGNC">          12 :   return ml_pipeline_element_set_property (elem_h, property_name,</span></span>
<span id="L2572"><span class="lineNum">    2572</span> <span class="tlaGNC">          12 :       GUINT_TO_POINTER (value), G_TYPE_ENUM);</span></span>
<span id="L2573"><span class="lineNum">    2573</span>              : }</span>
<span id="L2574"><span class="lineNum">    2574</span>              : </span>
<span id="L2575"><span class="lineNum">    2575</span>              : /**</span>
<span id="L2576"><span class="lineNum">    2576</span>              :  * @brief Gets the boolean value of element's property in NNStreamer pipelines.</span>
<span id="L2577"><span class="lineNum">    2577</span>              :  */</span>
<span id="L2578"><span class="lineNum">    2578</span>              : int</span>
<span id="L2579"><span class="lineNum">    2579</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_bool (ml_pipeline_element_h elem_h,</span></span>
<span id="L2580"><span class="lineNum">    2580</span>              :     const char *property_name, int32_t * value)</span>
<span id="L2581"><span class="lineNum">    2581</span>              : {</span>
<span id="L2582"><span class="lineNum">    2582</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2583"><span class="lineNum">    2583</span>              :       G_TYPE_BOOLEAN, (gpointer) value);</span>
<span id="L2584"><span class="lineNum">    2584</span>              : }</span>
<span id="L2585"><span class="lineNum">    2585</span>              : </span>
<span id="L2586"><span class="lineNum">    2586</span>              : /**</span>
<span id="L2587"><span class="lineNum">    2587</span>              :  * @brief Gets the string value of element's property in NNStreamer pipelines.</span>
<span id="L2588"><span class="lineNum">    2588</span>              :  */</span>
<span id="L2589"><span class="lineNum">    2589</span>              : int</span>
<span id="L2590"><span class="lineNum">    2590</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_string (ml_pipeline_element_h elem_h,</span></span>
<span id="L2591"><span class="lineNum">    2591</span>              :     const char *property_name, char **value)</span>
<span id="L2592"><span class="lineNum">    2592</span>              : {</span>
<span id="L2593"><span class="lineNum">    2593</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2594"><span class="lineNum">    2594</span>              :       G_TYPE_STRING, (gpointer) value);</span>
<span id="L2595"><span class="lineNum">    2595</span>              : }</span>
<span id="L2596"><span class="lineNum">    2596</span>              : </span>
<span id="L2597"><span class="lineNum">    2597</span>              : /**</span>
<span id="L2598"><span class="lineNum">    2598</span>              :  * @brief Gets the integer value of element's property in NNStreamer pipelines.</span>
<span id="L2599"><span class="lineNum">    2599</span>              :  */</span>
<span id="L2600"><span class="lineNum">    2600</span>              : int</span>
<span id="L2601"><span class="lineNum">    2601</span> <span class="tlaGNC">           7 : ml_pipeline_element_get_property_int32 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2602"><span class="lineNum">    2602</span>              :     const char *property_name, int32_t * value)</span>
<span id="L2603"><span class="lineNum">    2603</span>              : {</span>
<span id="L2604"><span class="lineNum">    2604</span> <span class="tlaGNC">           7 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2605"><span class="lineNum">    2605</span>              :       G_TYPE_INT, (gpointer) value);</span>
<span id="L2606"><span class="lineNum">    2606</span>              : }</span>
<span id="L2607"><span class="lineNum">    2607</span>              : </span>
<span id="L2608"><span class="lineNum">    2608</span>              : /**</span>
<span id="L2609"><span class="lineNum">    2609</span>              :  * @brief Gets the integer 64bit value of element's property in NNStreamer pipelines.</span>
<span id="L2610"><span class="lineNum">    2610</span>              :  */</span>
<span id="L2611"><span class="lineNum">    2611</span>              : int</span>
<span id="L2612"><span class="lineNum">    2612</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_int64 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2613"><span class="lineNum">    2613</span>              :     const char *property_name, int64_t * value)</span>
<span id="L2614"><span class="lineNum">    2614</span>              : {</span>
<span id="L2615"><span class="lineNum">    2615</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2616"><span class="lineNum">    2616</span>              :       G_TYPE_INT64, (gpointer) value);</span>
<span id="L2617"><span class="lineNum">    2617</span>              : }</span>
<span id="L2618"><span class="lineNum">    2618</span>              : </span>
<span id="L2619"><span class="lineNum">    2619</span>              : /**</span>
<span id="L2620"><span class="lineNum">    2620</span>              :  * @brief Gets the unsigned integer value of element's property in NNStreamer pipelines.</span>
<span id="L2621"><span class="lineNum">    2621</span>              :  */</span>
<span id="L2622"><span class="lineNum">    2622</span>              : int</span>
<span id="L2623"><span class="lineNum">    2623</span> <span class="tlaGNC">           7 : ml_pipeline_element_get_property_uint32 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2624"><span class="lineNum">    2624</span>              :     const char *property_name, uint32_t * value)</span>
<span id="L2625"><span class="lineNum">    2625</span>              : {</span>
<span id="L2626"><span class="lineNum">    2626</span> <span class="tlaGNC">           7 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2627"><span class="lineNum">    2627</span>              :       G_TYPE_UINT, (gpointer) value);</span>
<span id="L2628"><span class="lineNum">    2628</span>              : }</span>
<span id="L2629"><span class="lineNum">    2629</span>              : </span>
<span id="L2630"><span class="lineNum">    2630</span>              : /**</span>
<span id="L2631"><span class="lineNum">    2631</span>              :  * @brief Gets the unsigned integer 64bit value of element's property in NNStreamer pipelines.</span>
<span id="L2632"><span class="lineNum">    2632</span>              :  */</span>
<span id="L2633"><span class="lineNum">    2633</span>              : int</span>
<span id="L2634"><span class="lineNum">    2634</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_uint64 (ml_pipeline_element_h elem_h,</span></span>
<span id="L2635"><span class="lineNum">    2635</span>              :     const char *property_name, uint64_t * value)</span>
<span id="L2636"><span class="lineNum">    2636</span>              : {</span>
<span id="L2637"><span class="lineNum">    2637</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2638"><span class="lineNum">    2638</span>              :       G_TYPE_UINT64, (gpointer) value);</span>
<span id="L2639"><span class="lineNum">    2639</span>              : }</span>
<span id="L2640"><span class="lineNum">    2640</span>              : </span>
<span id="L2641"><span class="lineNum">    2641</span>              : /**</span>
<span id="L2642"><span class="lineNum">    2642</span>              :  * @brief Gets the floating point value of element's property in NNStreamer pipelines.</span>
<span id="L2643"><span class="lineNum">    2643</span>              :  */</span>
<span id="L2644"><span class="lineNum">    2644</span>              : int</span>
<span id="L2645"><span class="lineNum">    2645</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_double (ml_pipeline_element_h elem_h,</span></span>
<span id="L2646"><span class="lineNum">    2646</span>              :     const char *property_name, double *value)</span>
<span id="L2647"><span class="lineNum">    2647</span>              : {</span>
<span id="L2648"><span class="lineNum">    2648</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2649"><span class="lineNum">    2649</span>              :       G_TYPE_DOUBLE, (gpointer) value);</span>
<span id="L2650"><span class="lineNum">    2650</span>              : }</span>
<span id="L2651"><span class="lineNum">    2651</span>              : </span>
<span id="L2652"><span class="lineNum">    2652</span>              : /**</span>
<span id="L2653"><span class="lineNum">    2653</span>              :  * @brief Gets the enumeration value of element's property in NNStreamer pipelines.</span>
<span id="L2654"><span class="lineNum">    2654</span>              :  */</span>
<span id="L2655"><span class="lineNum">    2655</span>              : int</span>
<span id="L2656"><span class="lineNum">    2656</span> <span class="tlaGNC">           6 : ml_pipeline_element_get_property_enum (ml_pipeline_element_h elem_h,</span></span>
<span id="L2657"><span class="lineNum">    2657</span>              :     const char *property_name, uint32_t * value)</span>
<span id="L2658"><span class="lineNum">    2658</span>              : {</span>
<span id="L2659"><span class="lineNum">    2659</span> <span class="tlaGNC">           6 :   return ml_pipeline_element_get_property (elem_h, property_name,</span></span>
<span id="L2660"><span class="lineNum">    2660</span>              :       G_TYPE_ENUM, (gpointer) value);</span>
<span id="L2661"><span class="lineNum">    2661</span>              : }</span>
<span id="L2662"><span class="lineNum">    2662</span>              : </span>
<span id="L2663"><span class="lineNum">    2663</span>              : /**</span>
<span id="L2664"><span class="lineNum">    2664</span>              :  * @brief Gets the element of pipeline itself (GstElement).</span>
<span id="L2665"><span class="lineNum">    2665</span>              :  */</span>
<span id="L2666"><span class="lineNum">    2666</span>              : GstElement *</span>
<span id="L2667"><span class="lineNum">    2667</span> <span class="tlaUNC tlaBgUNC">           0 : _ml_pipeline_get_gst_pipeline (ml_pipeline_h pipe)</span></span>
<span id="L2668"><span class="lineNum">    2668</span>              : {</span>
<span id="L2669"><span class="lineNum">    2669</span> <span class="tlaUNC">           0 :   ml_pipeline *p = (ml_pipeline *) pipe;</span></span>
<span id="L2670"><span class="lineNum">    2670</span> <span class="tlaUNC">           0 :   GstElement *element = NULL;</span></span>
<span id="L2671"><span class="lineNum">    2671</span>              : </span>
<span id="L2672"><span class="lineNum">    2672</span> <span class="tlaUNC">           0 :   if (p) {</span></span>
<span id="L2673"><span class="lineNum">    2673</span> <span class="tlaUNC">           0 :     g_mutex_lock (&amp;p-&gt;lock);</span></span>
<span id="L2674"><span class="lineNum">    2674</span>              : </span>
<span id="L2675"><span class="lineNum">    2675</span> <span class="tlaUNC">           0 :     element = p-&gt;element;</span></span>
<span id="L2676"><span class="lineNum">    2676</span> <span class="tlaUNC">           0 :     if (element)</span></span>
<span id="L2677"><span class="lineNum">    2677</span> <span class="tlaUNC">           0 :       gst_object_ref (element);</span></span>
<span id="L2678"><span class="lineNum">    2678</span>              : </span>
<span id="L2679"><span class="lineNum">    2679</span> <span class="tlaUNC">           0 :     g_mutex_unlock (&amp;p-&gt;lock);</span></span>
<span id="L2680"><span class="lineNum">    2680</span>              :   }</span>
<span id="L2681"><span class="lineNum">    2681</span>              : </span>
<span id="L2682"><span class="lineNum">    2682</span> <span class="tlaUNC">           0 :   return element;</span></span>
<span id="L2683"><span class="lineNum">    2683</span>              : }</span>
<span id="L2684"><span class="lineNum">    2684</span>              : </span>
<span id="L2685"><span class="lineNum">    2685</span>              : /**</span>
<span id="L2686"><span class="lineNum">    2686</span>              :  * @brief Gets the element in pipeline (GstElement).</span>
<span id="L2687"><span class="lineNum">    2687</span>              :  */</span>
<span id="L2688"><span class="lineNum">    2688</span>              : GstElement *</span>
<span id="L2689"><span class="lineNum">    2689</span> <span class="tlaUNC">           0 : _ml_pipeline_get_gst_element (ml_pipeline_element_h handle)</span></span>
<span id="L2690"><span class="lineNum">    2690</span>              : {</span>
<span id="L2691"><span class="lineNum">    2691</span> <span class="tlaUNC">           0 :   ml_pipeline_common_elem *e = (ml_pipeline_common_elem *) handle;</span></span>
<span id="L2692"><span class="lineNum">    2692</span> <span class="tlaUNC">           0 :   GstElement *element = NULL;</span></span>
<span id="L2693"><span class="lineNum">    2693</span>              : </span>
<span id="L2694"><span class="lineNum">    2694</span> <span class="tlaUNC">           0 :   if (e &amp;&amp; e-&gt;element) {</span></span>
<span id="L2695"><span class="lineNum">    2695</span> <span class="tlaUNC">           0 :     ml_pipeline_element *elem = e-&gt;element;</span></span>
<span id="L2696"><span class="lineNum">    2696</span>              : </span>
<span id="L2697"><span class="lineNum">    2697</span> <span class="tlaUNC">           0 :     g_mutex_lock (&amp;elem-&gt;lock);</span></span>
<span id="L2698"><span class="lineNum">    2698</span>              : </span>
<span id="L2699"><span class="lineNum">    2699</span> <span class="tlaUNC">           0 :     element = elem-&gt;element;</span></span>
<span id="L2700"><span class="lineNum">    2700</span> <span class="tlaUNC">           0 :     if (element)</span></span>
<span id="L2701"><span class="lineNum">    2701</span> <span class="tlaUNC">           0 :       gst_object_ref (element);</span></span>
<span id="L2702"><span class="lineNum">    2702</span>              : </span>
<span id="L2703"><span class="lineNum">    2703</span> <span class="tlaUNC">           0 :     g_mutex_unlock (&amp;elem-&gt;lock);</span></span>
<span id="L2704"><span class="lineNum">    2704</span>              :   }</span>
<span id="L2705"><span class="lineNum">    2705</span>              : </span>
<span id="L2706"><span class="lineNum">    2706</span> <span class="tlaUNC">           0 :   return element;</span></span>
<span id="L2707"><span class="lineNum">    2707</span>              : }</span>
<span id="L2708"><span class="lineNum">    2708</span>              : </span>
<span id="L2709"><span class="lineNum">    2709</span>              : /**</span>
<span id="L2710"><span class="lineNum">    2710</span>              :  * @brief Increases ref count of custom-easy filter.</span>
<span id="L2711"><span class="lineNum">    2711</span>              :  */</span>
<span id="L2712"><span class="lineNum">    2712</span>              : static void</span>
<span id="L2713"><span class="lineNum">    2713</span> <span class="tlaGNC tlaBgGNC">           3 : ml_pipeline_custom_filter_ref (ml_custom_easy_filter_h custom)</span></span>
<span id="L2714"><span class="lineNum">    2714</span>              : {</span>
<span id="L2715"><span class="lineNum">    2715</span> <span class="tlaGNC">           3 :   ml_custom_filter_s *c = (ml_custom_filter_s *) custom;</span></span>
<span id="L2716"><span class="lineNum">    2716</span>              : </span>
<span id="L2717"><span class="lineNum">    2717</span> <span class="tlaGNC">           3 :   if (c) {</span></span>
<span id="L2718"><span class="lineNum">    2718</span> <span class="tlaGNC">           3 :     g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2719"><span class="lineNum">    2719</span> <span class="tlaGNC">           3 :     c-&gt;ref_count++;</span></span>
<span id="L2720"><span class="lineNum">    2720</span> <span class="tlaGNC">           3 :     g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2721"><span class="lineNum">    2721</span>              :   }</span>
<span id="L2722"><span class="lineNum">    2722</span> <span class="tlaGNC">           3 : }</span></span>
<span id="L2723"><span class="lineNum">    2723</span>              : </span>
<span id="L2724"><span class="lineNum">    2724</span>              : /**</span>
<span id="L2725"><span class="lineNum">    2725</span>              :  * @brief Decreases ref count of custom-easy filter.</span>
<span id="L2726"><span class="lineNum">    2726</span>              :  */</span>
<span id="L2727"><span class="lineNum">    2727</span>              : static void</span>
<span id="L2728"><span class="lineNum">    2728</span> <span class="tlaGNC">           3 : ml_pipeline_custom_filter_unref (ml_custom_easy_filter_h custom)</span></span>
<span id="L2729"><span class="lineNum">    2729</span>              : {</span>
<span id="L2730"><span class="lineNum">    2730</span> <span class="tlaGNC">           3 :   ml_custom_filter_s *c = (ml_custom_filter_s *) custom;</span></span>
<span id="L2731"><span class="lineNum">    2731</span>              : </span>
<span id="L2732"><span class="lineNum">    2732</span> <span class="tlaGNC">           3 :   if (!c)</span></span>
<span id="L2733"><span class="lineNum">    2733</span> <span class="tlaUNC tlaBgUNC">           0 :     return;</span></span>
<span id="L2734"><span class="lineNum">    2734</span>              : </span>
<span id="L2735"><span class="lineNum">    2735</span> <span class="tlaGNC tlaBgGNC">           3 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2736"><span class="lineNum">    2736</span> <span class="tlaGNC">           3 :   if (c-&gt;ref_count &gt; 0)</span></span>
<span id="L2737"><span class="lineNum">    2737</span> <span class="tlaGNC">           3 :     c-&gt;ref_count--;</span></span>
<span id="L2738"><span class="lineNum">    2738</span> <span class="tlaGNC">           3 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2739"><span class="lineNum">    2739</span>              : }</span>
<span id="L2740"><span class="lineNum">    2740</span>              : </span>
<span id="L2741"><span class="lineNum">    2741</span>              : /**</span>
<span id="L2742"><span class="lineNum">    2742</span>              :  * @brief Releases custom filter handle.</span>
<span id="L2743"><span class="lineNum">    2743</span>              :  */</span>
<span id="L2744"><span class="lineNum">    2744</span>              : static void</span>
<span id="L2745"><span class="lineNum">    2745</span> <span class="tlaGNC">           4 : ml_pipeline_custom_free_handle (ml_custom_filter_s * custom)</span></span>
<span id="L2746"><span class="lineNum">    2746</span>              : {</span>
<span id="L2747"><span class="lineNum">    2747</span> <span class="tlaGNC">           4 :   if (custom) {</span></span>
<span id="L2748"><span class="lineNum">    2748</span> <span class="tlaGNC">           4 :     g_mutex_lock (&amp;custom-&gt;lock);</span></span>
<span id="L2749"><span class="lineNum">    2749</span>              : </span>
<span id="L2750"><span class="lineNum">    2750</span> <span class="tlaGNC">           4 :     g_free (custom-&gt;name);</span></span>
<span id="L2751"><span class="lineNum">    2751</span> <span class="tlaGNC">           4 :     ml_tensors_info_destroy (custom-&gt;in_info);</span></span>
<span id="L2752"><span class="lineNum">    2752</span> <span class="tlaGNC">           4 :     ml_tensors_info_destroy (custom-&gt;out_info);</span></span>
<span id="L2753"><span class="lineNum">    2753</span>              : </span>
<span id="L2754"><span class="lineNum">    2754</span> <span class="tlaGNC">           4 :     g_mutex_unlock (&amp;custom-&gt;lock);</span></span>
<span id="L2755"><span class="lineNum">    2755</span> <span class="tlaGNC">           4 :     g_mutex_clear (&amp;custom-&gt;lock);</span></span>
<span id="L2756"><span class="lineNum">    2756</span>              : </span>
<span id="L2757"><span class="lineNum">    2757</span> <span class="tlaGNC">           4 :     g_free (custom);</span></span>
<span id="L2758"><span class="lineNum">    2758</span>              :   }</span>
<span id="L2759"><span class="lineNum">    2759</span> <span class="tlaGNC">           4 : }</span></span>
<span id="L2760"><span class="lineNum">    2760</span>              : </span>
<span id="L2761"><span class="lineNum">    2761</span>              : /**</span>
<span id="L2762"><span class="lineNum">    2762</span>              :  * @brief Invoke callback for custom-easy filter.</span>
<span id="L2763"><span class="lineNum">    2763</span>              :  */</span>
<span id="L2764"><span class="lineNum">    2764</span>              : static int</span>
<span id="L2765"><span class="lineNum">    2765</span> <span class="tlaGNC">           5 : ml_pipeline_custom_invoke (void *data, const GstTensorFilterProperties * prop,</span></span>
<span id="L2766"><span class="lineNum">    2766</span>              :     const GstTensorMemory * in, GstTensorMemory * out)</span>
<span id="L2767"><span class="lineNum">    2767</span>              : {</span>
<span id="L2768"><span class="lineNum">    2768</span>              :   int status;</span>
<span id="L2769"><span class="lineNum">    2769</span>              :   ml_custom_filter_s *c;</span>
<span id="L2770"><span class="lineNum">    2770</span>              :   ml_tensors_data_h in_data, out_data;</span>
<span id="L2771"><span class="lineNum">    2771</span>              :   ml_tensors_data_s *_data;</span>
<span id="L2772"><span class="lineNum">    2772</span>              :   guint i;</span>
<span id="L2773"><span class="lineNum">    2773</span>              : </span>
<span id="L2774"><span class="lineNum">    2774</span> <span class="tlaGNC">           5 :   in_data = out_data = NULL;</span></span>
<span id="L2775"><span class="lineNum">    2775</span> <span class="tlaGNC">           5 :   c = (ml_custom_filter_s *) data;</span></span>
<span id="L2776"><span class="lineNum">    2776</span>              : </span>
<span id="L2777"><span class="lineNum">    2777</span>              :   /* internal error? */</span>
<span id="L2778"><span class="lineNum">    2778</span> <span class="tlaGNC">           5 :   if (!c || !c-&gt;cb)</span></span>
<span id="L2779"><span class="lineNum">    2779</span> <span class="tlaGNC">           5 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2780"><span class="lineNum">    2780</span>              :         &quot;Internal error of callback function, ml_pipeline_custom_invoke. Its internal data structure is broken.&quot;);</span>
<span id="L2781"><span class="lineNum">    2781</span>              : </span>
<span id="L2782"><span class="lineNum">    2782</span> <span class="tlaGNC">           5 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2783"><span class="lineNum">    2783</span>              : </span>
<span id="L2784"><span class="lineNum">    2784</span>              :   /* prepare invoke */</span>
<span id="L2785"><span class="lineNum">    2785</span> <span class="tlaGNC">           5 :   status = _ml_tensors_data_create_no_alloc (c-&gt;in_info, &amp;in_data);</span></span>
<span id="L2786"><span class="lineNum">    2786</span> <span class="tlaGNC">           5 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L2787"><span class="lineNum">    2787</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue (&quot;_ml_tensors_data_create_no_alloc has failed.&quot;);</span></span>
<span id="L2788"><span class="lineNum">    2788</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L2789"><span class="lineNum">    2789</span>              :   }</span>
<span id="L2790"><span class="lineNum">    2790</span>              : </span>
<span id="L2791"><span class="lineNum">    2791</span> <span class="tlaGNC tlaBgGNC">           5 :   _data = (ml_tensors_data_s *) in_data;</span></span>
<span id="L2792"><span class="lineNum">    2792</span> <span class="tlaGNC">          10 :   for (i = 0; i &lt; _data-&gt;num_tensors; i++)</span></span>
<span id="L2793"><span class="lineNum">    2793</span> <span class="tlaGNC">           5 :     _data-&gt;tensors[i].data = in[i].data;</span></span>
<span id="L2794"><span class="lineNum">    2794</span>              : </span>
<span id="L2795"><span class="lineNum">    2795</span> <span class="tlaGNC">           5 :   status = _ml_tensors_data_create_no_alloc (c-&gt;out_info, &amp;out_data);</span></span>
<span id="L2796"><span class="lineNum">    2796</span> <span class="tlaGNC">           5 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L2797"><span class="lineNum">    2797</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue (&quot;_ml_tensors_data_create_no_alloc has failed.&quot;);</span></span>
<span id="L2798"><span class="lineNum">    2798</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L2799"><span class="lineNum">    2799</span>              :   }</span>
<span id="L2800"><span class="lineNum">    2800</span>              : </span>
<span id="L2801"><span class="lineNum">    2801</span> <span class="tlaGNC tlaBgGNC">           5 :   _data = (ml_tensors_data_s *) out_data;</span></span>
<span id="L2802"><span class="lineNum">    2802</span> <span class="tlaGNC">          10 :   for (i = 0; i &lt; _data-&gt;num_tensors; i++)</span></span>
<span id="L2803"><span class="lineNum">    2803</span> <span class="tlaGNC">           5 :     _data-&gt;tensors[i].data = out[i].data;</span></span>
<span id="L2804"><span class="lineNum">    2804</span>              : </span>
<span id="L2805"><span class="lineNum">    2805</span>              :   /* call invoke callback */</span>
<span id="L2806"><span class="lineNum">    2806</span> <span class="tlaGNC">           5 :   status = c-&gt;cb (in_data, out_data, c-&gt;pdata);</span></span>
<span id="L2807"><span class="lineNum">    2807</span>              : </span>
<span id="L2808"><span class="lineNum">    2808</span> <span class="tlaGNC">           5 : done:</span></span>
<span id="L2809"><span class="lineNum">    2809</span> <span class="tlaGNC">           5 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2810"><span class="lineNum">    2810</span>              :   /* NOTE: DO NOT free tensor data */</span>
<span id="L2811"><span class="lineNum">    2811</span> <span class="tlaGNC">           5 :   _ml_tensors_data_destroy_internal (in_data, FALSE);</span></span>
<span id="L2812"><span class="lineNum">    2812</span> <span class="tlaGNC">           5 :   _ml_tensors_data_destroy_internal (out_data, FALSE);</span></span>
<span id="L2813"><span class="lineNum">    2813</span>              : </span>
<span id="L2814"><span class="lineNum">    2814</span> <span class="tlaGNC">           5 :   return status;</span></span>
<span id="L2815"><span class="lineNum">    2815</span>              : }</span>
<span id="L2816"><span class="lineNum">    2816</span>              : </span>
<span id="L2817"><span class="lineNum">    2817</span>              : /**</span>
<span id="L2818"><span class="lineNum">    2818</span>              :  * @brief Registers a custom filter.</span>
<span id="L2819"><span class="lineNum">    2819</span>              :  */</span>
<span id="L2820"><span class="lineNum">    2820</span>              : int</span>
<span id="L2821"><span class="lineNum">    2821</span> <span class="tlaGNC">          11 : ml_pipeline_custom_easy_filter_register (const char *name,</span></span>
<span id="L2822"><span class="lineNum">    2822</span>              :     const ml_tensors_info_h in, const ml_tensors_info_h out,</span>
<span id="L2823"><span class="lineNum">    2823</span>              :     ml_custom_easy_invoke_cb cb, void *user_data,</span>
<span id="L2824"><span class="lineNum">    2824</span>              :     ml_custom_easy_filter_h * custom)</span>
<span id="L2825"><span class="lineNum">    2825</span>              : {</span>
<span id="L2826"><span class="lineNum">    2826</span> <span class="tlaGNC">          11 :   int status = ML_ERROR_NONE;</span></span>
<span id="L2827"><span class="lineNum">    2827</span>              :   ml_custom_filter_s *c;</span>
<span id="L2828"><span class="lineNum">    2828</span>              :   GstTensorsInfo in_info, out_info;</span>
<span id="L2829"><span class="lineNum">    2829</span>              : </span>
<span id="L2830"><span class="lineNum">    2830</span> <span class="tlaGNC">          22 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L2831"><span class="lineNum">    2831</span>              : </span>
<span id="L2832"><span class="lineNum">    2832</span> <span class="tlaGNC">          11 :   if (!name)</span></span>
<span id="L2833"><span class="lineNum">    2833</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2834"><span class="lineNum">    2834</span>              :         &quot;The parameter, name (const char *), is NULL. It should be a valid string of the filter name.&quot;);</span>
<span id="L2835"><span class="lineNum">    2835</span> <span class="tlaGNC">          10 :   if (!cb)</span></span>
<span id="L2836"><span class="lineNum">    2836</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2837"><span class="lineNum">    2837</span>              :         &quot;The parameter, cb (ml_custom_easy_invoke_cb), is NULL. It should be a valid call-back struct containing function pointer and its related data.&quot;);</span>
<span id="L2838"><span class="lineNum">    2838</span> <span class="tlaGNC">           9 :   if (!custom)</span></span>
<span id="L2839"><span class="lineNum">    2839</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2840"><span class="lineNum">    2840</span>              :         &quot;The parameter, custom (ml_custom_easy_filter_h *), is NULL. It should be a valid pointer of ml_custom_easy_filter. E.g., ml_custom_easy_filter_h custom; ml_pipeline_custom_easy_filter_register (..., &amp;custom);&quot;);</span>
<span id="L2841"><span class="lineNum">    2841</span>              : </span>
<span id="L2842"><span class="lineNum">    2842</span>              :   /* init null */</span>
<span id="L2843"><span class="lineNum">    2843</span> <span class="tlaGNC">           8 :   *custom = NULL;</span></span>
<span id="L2844"><span class="lineNum">    2844</span>              : </span>
<span id="L2845"><span class="lineNum">    2845</span> <span class="tlaGNC">           8 :   if (!ml_tensors_info_is_valid (in))</span></span>
<span id="L2846"><span class="lineNum">    2846</span> <span class="tlaGNC">           2 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2847"><span class="lineNum">    2847</span>              :         &quot;The parameter, in (const ml_tensors_info_h), is not valid. ml_tensors_info_is_valid(in) has returned FALSE. Please check if its cloned/fetched from a valid object or if you have configured it properly.&quot;);</span>
<span id="L2848"><span class="lineNum">    2848</span> <span class="tlaGNC">           6 :   if (!ml_tensors_info_is_valid (out))</span></span>
<span id="L2849"><span class="lineNum">    2849</span> <span class="tlaGNC">           2 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2850"><span class="lineNum">    2850</span>              :         &quot;The parameter, out (const ml_tensors_info_h), is not valid. ml_tensors_info_is_valid(in) has returned FALSE. Please check if its cloned/fetched from a valid object or if you have configured it properly.&quot;);</span>
<span id="L2851"><span class="lineNum">    2851</span>              : </span>
<span id="L2852"><span class="lineNum">    2852</span>              :   /* create and init custom handle */</span>
<span id="L2853"><span class="lineNum">    2853</span> <span class="tlaGNC">           4 :   if ((c = g_new0 (ml_custom_filter_s, 1)) == NULL)</span></span>
<span id="L2854"><span class="lineNum">    2854</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_OUT_OF_MEMORY,</span></span>
<span id="L2855"><span class="lineNum">    2855</span>              :         &quot;Cannot allocate memory. Out of memory?&quot;);</span>
<span id="L2856"><span class="lineNum">    2856</span>              : </span>
<span id="L2857"><span class="lineNum">    2857</span> <span class="tlaGNC tlaBgGNC">           4 :   g_mutex_init (&amp;c-&gt;lock);</span></span>
<span id="L2858"><span class="lineNum">    2858</span>              : </span>
<span id="L2859"><span class="lineNum">    2859</span>              :   /** no need to acquire c-&gt;lock as its created locally */</span>
<span id="L2860"><span class="lineNum">    2860</span> <span class="tlaGNC">           4 :   c-&gt;name = g_strdup (name);</span></span>
<span id="L2861"><span class="lineNum">    2861</span> <span class="tlaGNC">           4 :   c-&gt;ref_count = 0;</span></span>
<span id="L2862"><span class="lineNum">    2862</span> <span class="tlaGNC">           4 :   c-&gt;cb = cb;</span></span>
<span id="L2863"><span class="lineNum">    2863</span> <span class="tlaGNC">           4 :   c-&gt;pdata = user_data;</span></span>
<span id="L2864"><span class="lineNum">    2864</span> <span class="tlaGNC">           4 :   ml_tensors_info_create_extended (&amp;c-&gt;in_info);</span></span>
<span id="L2865"><span class="lineNum">    2865</span> <span class="tlaGNC">           4 :   ml_tensors_info_create_extended (&amp;c-&gt;out_info);</span></span>
<span id="L2866"><span class="lineNum">    2866</span>              : </span>
<span id="L2867"><span class="lineNum">    2867</span> <span class="tlaGNC">           4 :   status = ml_tensors_info_clone (c-&gt;in_info, in);</span></span>
<span id="L2868"><span class="lineNum">    2868</span> <span class="tlaGNC">           4 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L2869"><span class="lineNum">    2869</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L2870"><span class="lineNum">    2870</span>              :         (&quot;ml_tensors_info_clone has failed with %d. Cannot fetch input tensor-info (metadata).&quot;,</span>
<span id="L2871"><span class="lineNum">    2871</span>              :         status);</span>
<span id="L2872"><span class="lineNum">    2872</span> <span class="tlaUNC">           0 :     goto exit;</span></span>
<span id="L2873"><span class="lineNum">    2873</span>              :   }</span>
<span id="L2874"><span class="lineNum">    2874</span>              : </span>
<span id="L2875"><span class="lineNum">    2875</span> <span class="tlaGNC tlaBgGNC">           4 :   status = ml_tensors_info_clone (c-&gt;out_info, out);</span></span>
<span id="L2876"><span class="lineNum">    2876</span> <span class="tlaGNC">           4 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L2877"><span class="lineNum">    2877</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L2878"><span class="lineNum">    2878</span>              :         (&quot;ml_tensors_info_clone has filed with %d. Cannot fetch output tensor-info (metadata).&quot;,</span>
<span id="L2879"><span class="lineNum">    2879</span>              :         status);</span>
<span id="L2880"><span class="lineNum">    2880</span> <span class="tlaUNC">           0 :     goto exit;</span></span>
<span id="L2881"><span class="lineNum">    2881</span>              :   }</span>
<span id="L2882"><span class="lineNum">    2882</span>              : </span>
<span id="L2883"><span class="lineNum">    2883</span>              :   /* register custom filter */</span>
<span id="L2884"><span class="lineNum">    2884</span> <span class="tlaGNC tlaBgGNC">           4 :   _ml_tensors_info_copy_from_ml (&amp;in_info, c-&gt;in_info);</span></span>
<span id="L2885"><span class="lineNum">    2885</span> <span class="tlaGNC">           4 :   _ml_tensors_info_copy_from_ml (&amp;out_info, c-&gt;out_info);</span></span>
<span id="L2886"><span class="lineNum">    2886</span>              : </span>
<span id="L2887"><span class="lineNum">    2887</span> <span class="tlaGNC">           4 :   status = NNS_custom_easy_register (name, ml_pipeline_custom_invoke, c,</span></span>
<span id="L2888"><span class="lineNum">    2888</span>              :       &amp;in_info, &amp;out_info);</span>
<span id="L2889"><span class="lineNum">    2889</span> <span class="tlaGNC">           4 :   if (status != 0) {</span></span>
<span id="L2890"><span class="lineNum">    2890</span> <span class="tlaGNC">           1 :     char buf[255] = { 0 };</span></span>
<span id="L2891"><span class="lineNum">    2891</span> <span class="tlaGNC">           1 :     if (status == -EINVAL) {</span></span>
<span id="L2892"><span class="lineNum">    2892</span> <span class="tlaGNC">           1 :       status = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2893"><span class="lineNum">    2893</span> <span class="tlaGNC">           1 :       strncpy (buf, &quot;invalid parameters are given.&quot;, 254);</span></span>
<span id="L2894"><span class="lineNum">    2894</span> <span class="tlaUNC tlaBgUNC">           0 :     } else if (status == -ENOMEM) {</span></span>
<span id="L2895"><span class="lineNum">    2895</span> <span class="tlaUNC">           0 :       status = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L2896"><span class="lineNum">    2896</span> <span class="tlaUNC">           0 :       strncpy (buf, &quot;out of memory. cannot allocate.&quot;, 254);</span></span>
<span id="L2897"><span class="lineNum">    2897</span>              :     } else {</span>
<span id="L2898"><span class="lineNum">    2898</span> <span class="tlaUNC">           0 :       status = ML_ERROR_UNKNOWN;</span></span>
<span id="L2899"><span class="lineNum">    2899</span> <span class="tlaUNC">           0 :       strncpy (buf, &quot;unknown error.&quot;, 254);</span></span>
<span id="L2900"><span class="lineNum">    2900</span>              :     }</span>
<span id="L2901"><span class="lineNum">    2901</span> <span class="tlaGNC tlaBgGNC">           1 :     _ml_error_report</span></span>
<span id="L2902"><span class="lineNum">    2902</span>              :         (&quot;Failed to register custom filter %s with NNStreamer API, NNS_custom_easy_register(). It has returned %d, which means '%s'.&quot;,</span>
<span id="L2903"><span class="lineNum">    2903</span>              :         name, status, buf);</span>
<span id="L2904"><span class="lineNum">    2904</span>              :   }</span>
<span id="L2905"><span class="lineNum">    2905</span>              : </span>
<span id="L2906"><span class="lineNum">    2906</span> <span class="tlaGNC">           3 : exit:</span></span>
<span id="L2907"><span class="lineNum">    2907</span> <span class="tlaGNC">           4 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L2908"><span class="lineNum">    2908</span> <span class="tlaGNC">           3 :     pipe_custom_add_data (PIPE_CUSTOM_TYPE_FILTER, name, c);</span></span>
<span id="L2909"><span class="lineNum">    2909</span> <span class="tlaGNC">           3 :     *custom = c;</span></span>
<span id="L2910"><span class="lineNum">    2910</span>              :   } else {</span>
<span id="L2911"><span class="lineNum">    2911</span> <span class="tlaGNC">           1 :     ml_pipeline_custom_free_handle (c);</span></span>
<span id="L2912"><span class="lineNum">    2912</span>              :   }</span>
<span id="L2913"><span class="lineNum">    2913</span>              : </span>
<span id="L2914"><span class="lineNum">    2914</span> <span class="tlaGNC">           4 :   return status;</span></span>
<span id="L2915"><span class="lineNum">    2915</span>              : }</span>
<span id="L2916"><span class="lineNum">    2916</span>              : </span>
<span id="L2917"><span class="lineNum">    2917</span>              : /**</span>
<span id="L2918"><span class="lineNum">    2918</span>              :  * @brief Unregisters the custom filter.</span>
<span id="L2919"><span class="lineNum">    2919</span>              :  */</span>
<span id="L2920"><span class="lineNum">    2920</span>              : int</span>
<span id="L2921"><span class="lineNum">    2921</span> <span class="tlaGNC">           6 : ml_pipeline_custom_easy_filter_unregister (ml_custom_easy_filter_h custom)</span></span>
<span id="L2922"><span class="lineNum">    2922</span>              : {</span>
<span id="L2923"><span class="lineNum">    2923</span>              :   ml_custom_filter_s *c;</span>
<span id="L2924"><span class="lineNum">    2924</span> <span class="tlaGNC">           6 :   int status = ML_ERROR_NONE;</span></span>
<span id="L2925"><span class="lineNum">    2925</span>              : </span>
<span id="L2926"><span class="lineNum">    2926</span> <span class="tlaGNC">           6 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L2927"><span class="lineNum">    2927</span>              : </span>
<span id="L2928"><span class="lineNum">    2928</span> <span class="tlaGNC">           6 :   if (!custom)</span></span>
<span id="L2929"><span class="lineNum">    2929</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L2930"><span class="lineNum">    2930</span>              :         &quot;The parameter, custom (ml_custom_easy_filter_h), is NULL. It should be a valid ml_custom_easy_filter_h instance, usually created by ml_pipeline_custom_easy_filter_register().&quot;);</span>
<span id="L2931"><span class="lineNum">    2931</span>              : </span>
<span id="L2932"><span class="lineNum">    2932</span> <span class="tlaGNC">           5 :   c = (ml_custom_filter_s *) custom;</span></span>
<span id="L2933"><span class="lineNum">    2933</span> <span class="tlaGNC">           5 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2934"><span class="lineNum">    2934</span>              : </span>
<span id="L2935"><span class="lineNum">    2935</span> <span class="tlaGNC">           5 :   if (c-&gt;ref_count &gt; 0) {</span></span>
<span id="L2936"><span class="lineNum">    2936</span> <span class="tlaGNC">           2 :     _ml_error_report</span></span>
<span id="L2937"><span class="lineNum">    2937</span>              :         (&quot;Failed to unregister custom filter %s, it is used in the pipeline. Its reference counter value is %u.&quot;,</span>
<span id="L2938"><span class="lineNum">    2938</span>              :         c-&gt;name, c-&gt;ref_count);</span>
<span id="L2939"><span class="lineNum">    2939</span> <span class="tlaGNC">           2 :     status = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2940"><span class="lineNum">    2940</span> <span class="tlaGNC">           2 :     goto done;</span></span>
<span id="L2941"><span class="lineNum">    2941</span>              :   }</span>
<span id="L2942"><span class="lineNum">    2942</span>              : </span>
<span id="L2943"><span class="lineNum">    2943</span> <span class="tlaGNC">           3 :   status = NNS_custom_easy_unregister (c-&gt;name);</span></span>
<span id="L2944"><span class="lineNum">    2944</span> <span class="tlaGNC">           3 :   if (status != 0) {</span></span>
<span id="L2945"><span class="lineNum">    2945</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L2946"><span class="lineNum">    2946</span>              :         (&quot;Failed to unregister custom filter %s. It is possible that this is already unregistered or not registered.&quot;,</span>
<span id="L2947"><span class="lineNum">    2947</span>              :         c-&gt;name);</span>
<span id="L2948"><span class="lineNum">    2948</span> <span class="tlaUNC">           0 :     status = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L2949"><span class="lineNum">    2949</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L2950"><span class="lineNum">    2950</span>              :   }</span>
<span id="L2951"><span class="lineNum">    2951</span>              : </span>
<span id="L2952"><span class="lineNum">    2952</span> <span class="tlaGNC tlaBgGNC">           3 : done:</span></span>
<span id="L2953"><span class="lineNum">    2953</span> <span class="tlaGNC">           5 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2954"><span class="lineNum">    2954</span>              : </span>
<span id="L2955"><span class="lineNum">    2955</span> <span class="tlaGNC">           5 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L2956"><span class="lineNum">    2956</span> <span class="tlaGNC">           3 :     pipe_custom_remove_data (PIPE_CUSTOM_TYPE_FILTER, c-&gt;name);</span></span>
<span id="L2957"><span class="lineNum">    2957</span> <span class="tlaGNC">           3 :     ml_pipeline_custom_free_handle (c);</span></span>
<span id="L2958"><span class="lineNum">    2958</span>              :   }</span>
<span id="L2959"><span class="lineNum">    2959</span>              : </span>
<span id="L2960"><span class="lineNum">    2960</span> <span class="tlaGNC">           5 :   return status;</span></span>
<span id="L2961"><span class="lineNum">    2961</span>              : }</span>
<span id="L2962"><span class="lineNum">    2962</span>              : </span>
<span id="L2963"><span class="lineNum">    2963</span>              : /**</span>
<span id="L2964"><span class="lineNum">    2964</span>              :  * @brief Increases ref count of tensor_if custom condition.</span>
<span id="L2965"><span class="lineNum">    2965</span>              :  */</span>
<span id="L2966"><span class="lineNum">    2966</span>              : static void</span>
<span id="L2967"><span class="lineNum">    2967</span> <span class="tlaGNC">           3 : ml_pipeline_if_custom_ref (ml_pipeline_if_h custom)</span></span>
<span id="L2968"><span class="lineNum">    2968</span>              : {</span>
<span id="L2969"><span class="lineNum">    2969</span> <span class="tlaGNC">           3 :   ml_if_custom_s *c = (ml_if_custom_s *) custom;</span></span>
<span id="L2970"><span class="lineNum">    2970</span>              : </span>
<span id="L2971"><span class="lineNum">    2971</span> <span class="tlaGNC">           3 :   if (c) {</span></span>
<span id="L2972"><span class="lineNum">    2972</span> <span class="tlaGNC">           3 :     g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2973"><span class="lineNum">    2973</span> <span class="tlaGNC">           3 :     c-&gt;ref_count++;</span></span>
<span id="L2974"><span class="lineNum">    2974</span> <span class="tlaGNC">           3 :     g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2975"><span class="lineNum">    2975</span>              :   }</span>
<span id="L2976"><span class="lineNum">    2976</span> <span class="tlaGNC">           3 : }</span></span>
<span id="L2977"><span class="lineNum">    2977</span>              : </span>
<span id="L2978"><span class="lineNum">    2978</span>              : /**</span>
<span id="L2979"><span class="lineNum">    2979</span>              :  * @brief Decreases ref count of tensor_if custom condition.</span>
<span id="L2980"><span class="lineNum">    2980</span>              :  */</span>
<span id="L2981"><span class="lineNum">    2981</span>              : static void</span>
<span id="L2982"><span class="lineNum">    2982</span> <span class="tlaGNC">           3 : ml_pipeline_if_custom_unref (ml_pipeline_if_h custom)</span></span>
<span id="L2983"><span class="lineNum">    2983</span>              : {</span>
<span id="L2984"><span class="lineNum">    2984</span> <span class="tlaGNC">           3 :   ml_if_custom_s *c = (ml_if_custom_s *) custom;</span></span>
<span id="L2985"><span class="lineNum">    2985</span>              : </span>
<span id="L2986"><span class="lineNum">    2986</span> <span class="tlaGNC">           3 :   if (c) {</span></span>
<span id="L2987"><span class="lineNum">    2987</span> <span class="tlaGNC">           3 :     g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L2988"><span class="lineNum">    2988</span> <span class="tlaGNC">           3 :     if (c-&gt;ref_count &gt; 0)</span></span>
<span id="L2989"><span class="lineNum">    2989</span> <span class="tlaGNC">           3 :       c-&gt;ref_count--;</span></span>
<span id="L2990"><span class="lineNum">    2990</span> <span class="tlaGNC">           3 :     g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L2991"><span class="lineNum">    2991</span>              :   }</span>
<span id="L2992"><span class="lineNum">    2992</span> <span class="tlaGNC">           3 : }</span></span>
<span id="L2993"><span class="lineNum">    2993</span>              : </span>
<span id="L2994"><span class="lineNum">    2994</span>              : /**</span>
<span id="L2995"><span class="lineNum">    2995</span>              :  * @brief Callback for tensor_if custom condition.</span>
<span id="L2996"><span class="lineNum">    2996</span>              :  */</span>
<span id="L2997"><span class="lineNum">    2997</span>              : static gboolean</span>
<span id="L2998"><span class="lineNum">    2998</span> <span class="tlaGNC">          10 : ml_pipeline_if_custom (const GstTensorsInfo * info,</span></span>
<span id="L2999"><span class="lineNum">    2999</span>              :     const GstTensorMemory * input, void *data, gboolean * result)</span>
<span id="L3000"><span class="lineNum">    3000</span>              : {</span>
<span id="L3001"><span class="lineNum">    3001</span> <span class="tlaGNC">          10 :   int status = 0;</span></span>
<span id="L3002"><span class="lineNum">    3002</span>              :   guint i;</span>
<span id="L3003"><span class="lineNum">    3003</span>              :   ml_if_custom_s *c;</span>
<span id="L3004"><span class="lineNum">    3004</span> <span class="tlaGNC">          10 :   ml_tensors_data_h in_data = NULL;</span></span>
<span id="L3005"><span class="lineNum">    3005</span>              :   ml_tensors_data_s *_data;</span>
<span id="L3006"><span class="lineNum">    3006</span> <span class="tlaGNC">          10 :   ml_tensors_info_h ml_info = NULL;</span></span>
<span id="L3007"><span class="lineNum">    3007</span> <span class="tlaGNC">          10 :   gboolean ret = FALSE;</span></span>
<span id="L3008"><span class="lineNum">    3008</span>              : </span>
<span id="L3009"><span class="lineNum">    3009</span> <span class="tlaGNC">          10 :   c = (ml_if_custom_s *) data;</span></span>
<span id="L3010"><span class="lineNum">    3010</span>              : </span>
<span id="L3011"><span class="lineNum">    3011</span>              :   /* internal error? */</span>
<span id="L3012"><span class="lineNum">    3012</span> <span class="tlaGNC">          10 :   if (!c || !c-&gt;cb)</span></span>
<span id="L3013"><span class="lineNum">    3013</span> <span class="tlaGNC">          10 :     _ml_error_report_return (FALSE,</span></span>
<span id="L3014"><span class="lineNum">    3014</span>              :         &quot;Internal error: the parameter, data, is not valid. App thread might have touched internal data structure.&quot;);</span>
<span id="L3015"><span class="lineNum">    3015</span>              : </span>
<span id="L3016"><span class="lineNum">    3016</span> <span class="tlaGNC">          10 :   status = _ml_tensors_info_create_from_gst (&amp;ml_info, info);</span></span>
<span id="L3017"><span class="lineNum">    3017</span> <span class="tlaGNC">          10 :   if (status != ML_ERROR_NONE)</span></span>
<span id="L3018"><span class="lineNum">    3018</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return_continue (FALSE,</span></span>
<span id="L3019"><span class="lineNum">    3019</span>              :         &quot;Cannot create tensors-info from the parameter, info (const GstTensorsInfo). _ml_tensors_info_create_from_gst has returned %d.&quot;,</span>
<span id="L3020"><span class="lineNum">    3020</span>              :         status);</span>
<span id="L3021"><span class="lineNum">    3021</span> <span class="tlaGNC tlaBgGNC">          10 :   status = _ml_tensors_data_create_no_alloc (ml_info, &amp;in_data);</span></span>
<span id="L3022"><span class="lineNum">    3022</span> <span class="tlaGNC">          10 :   if (status != ML_ERROR_NONE) {</span></span>
<span id="L3023"><span class="lineNum">    3023</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_continue</span></span>
<span id="L3024"><span class="lineNum">    3024</span>              :         (&quot;Cannot create data entry from the given metadata, info (const GstTensorMemory, although we could create tensor-info from info. _ml_tensors_data_create_no_alloc() has returned %d.&quot;,</span>
<span id="L3025"><span class="lineNum">    3025</span>              :         status);</span>
<span id="L3026"><span class="lineNum">    3026</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L3027"><span class="lineNum">    3027</span>              :   }</span>
<span id="L3028"><span class="lineNum">    3028</span>              : </span>
<span id="L3029"><span class="lineNum">    3029</span> <span class="tlaGNC tlaBgGNC">          10 :   _data = (ml_tensors_data_s *) in_data;</span></span>
<span id="L3030"><span class="lineNum">    3030</span> <span class="tlaGNC">          20 :   for (i = 0; i &lt; _data-&gt;num_tensors; i++)</span></span>
<span id="L3031"><span class="lineNum">    3031</span> <span class="tlaGNC">          10 :     _data-&gt;tensors[i].data = input[i].data;</span></span>
<span id="L3032"><span class="lineNum">    3032</span>              : </span>
<span id="L3033"><span class="lineNum">    3033</span>              :   /* call invoke callback */</span>
<span id="L3034"><span class="lineNum">    3034</span> <span class="tlaGNC">          10 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L3035"><span class="lineNum">    3035</span> <span class="tlaGNC">          10 :   status = c-&gt;cb (in_data, ml_info, result, c-&gt;pdata);</span></span>
<span id="L3036"><span class="lineNum">    3036</span> <span class="tlaGNC">          10 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L3037"><span class="lineNum">    3037</span>              : </span>
<span id="L3038"><span class="lineNum">    3038</span> <span class="tlaGNC">          10 :   ret = (status == ML_ERROR_NONE);</span></span>
<span id="L3039"><span class="lineNum">    3039</span> <span class="tlaGNC">          10 :   if (!ret)</span></span>
<span id="L3040"><span class="lineNum">    3040</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report</span></span>
<span id="L3041"><span class="lineNum">    3041</span>              :         (&quot;The callback function of if-statement has returned error: %d.&quot;,</span>
<span id="L3042"><span class="lineNum">    3042</span>              :         status);</span>
<span id="L3043"><span class="lineNum">    3043</span>              : </span>
<span id="L3044"><span class="lineNum">    3044</span> <span class="tlaGNC tlaBgGNC">          10 : done:</span></span>
<span id="L3045"><span class="lineNum">    3045</span> <span class="tlaGNC">          10 :   ml_tensors_info_destroy (ml_info);</span></span>
<span id="L3046"><span class="lineNum">    3046</span> <span class="tlaGNC">          10 :   _ml_tensors_data_destroy_internal (in_data, FALSE);</span></span>
<span id="L3047"><span class="lineNum">    3047</span>              : </span>
<span id="L3048"><span class="lineNum">    3048</span> <span class="tlaGNC">          10 :   return ret;</span></span>
<span id="L3049"><span class="lineNum">    3049</span>              : }</span>
<span id="L3050"><span class="lineNum">    3050</span>              : </span>
<span id="L3051"><span class="lineNum">    3051</span>              : /**</span>
<span id="L3052"><span class="lineNum">    3052</span>              :  * @brief Releases tensor_if custom condition.</span>
<span id="L3053"><span class="lineNum">    3053</span>              :  */</span>
<span id="L3054"><span class="lineNum">    3054</span>              : static void</span>
<span id="L3055"><span class="lineNum">    3055</span> <span class="tlaGNC">           4 : ml_pipeline_if_custom_free (ml_if_custom_s * custom)</span></span>
<span id="L3056"><span class="lineNum">    3056</span>              : {</span>
<span id="L3057"><span class="lineNum">    3057</span> <span class="tlaGNC">           4 :   if (custom) {</span></span>
<span id="L3058"><span class="lineNum">    3058</span> <span class="tlaGNC">           4 :     g_mutex_lock (&amp;custom-&gt;lock);</span></span>
<span id="L3059"><span class="lineNum">    3059</span>              : </span>
<span id="L3060"><span class="lineNum">    3060</span> <span class="tlaGNC">           4 :     g_free (custom-&gt;name);</span></span>
<span id="L3061"><span class="lineNum">    3061</span>              : </span>
<span id="L3062"><span class="lineNum">    3062</span> <span class="tlaGNC">           4 :     g_mutex_unlock (&amp;custom-&gt;lock);</span></span>
<span id="L3063"><span class="lineNum">    3063</span> <span class="tlaGNC">           4 :     g_mutex_clear (&amp;custom-&gt;lock);</span></span>
<span id="L3064"><span class="lineNum">    3064</span>              : </span>
<span id="L3065"><span class="lineNum">    3065</span> <span class="tlaGNC">           4 :     g_free (custom);</span></span>
<span id="L3066"><span class="lineNum">    3066</span>              :   }</span>
<span id="L3067"><span class="lineNum">    3067</span> <span class="tlaGNC">           4 : }</span></span>
<span id="L3068"><span class="lineNum">    3068</span>              : </span>
<span id="L3069"><span class="lineNum">    3069</span>              : /**</span>
<span id="L3070"><span class="lineNum">    3070</span>              :  * @brief Registers the tensor_if custom callback.</span>
<span id="L3071"><span class="lineNum">    3071</span>              :  */</span>
<span id="L3072"><span class="lineNum">    3072</span>              : int</span>
<span id="L3073"><span class="lineNum">    3073</span> <span class="tlaGNC">           7 : ml_pipeline_tensor_if_custom_register (const char *name,</span></span>
<span id="L3074"><span class="lineNum">    3074</span>              :     ml_pipeline_if_custom_cb cb, void *user_data, ml_pipeline_if_h * if_custom)</span>
<span id="L3075"><span class="lineNum">    3075</span>              : {</span>
<span id="L3076"><span class="lineNum">    3076</span> <span class="tlaGNC">           7 :   int status = ML_ERROR_NONE;</span></span>
<span id="L3077"><span class="lineNum">    3077</span>              :   ml_if_custom_s *c;</span>
<span id="L3078"><span class="lineNum">    3078</span>              : </span>
<span id="L3079"><span class="lineNum">    3079</span> <span class="tlaGNC">           7 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L3080"><span class="lineNum">    3080</span>              : </span>
<span id="L3081"><span class="lineNum">    3081</span> <span class="tlaGNC">           7 :   if (!name)</span></span>
<span id="L3082"><span class="lineNum">    3082</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L3083"><span class="lineNum">    3083</span>              :         &quot;The parameter, name (const char *), is NULL. It should be a valid string of the tensor_if element in your pipeline.&quot;);</span>
<span id="L3084"><span class="lineNum">    3084</span> <span class="tlaGNC">           6 :   if (!cb)</span></span>
<span id="L3085"><span class="lineNum">    3085</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L3086"><span class="lineNum">    3086</span>              :         &quot;The parameter, cb (ml_pipeline_if_custom_cb callback function pointer), is NULL. It should be a valid function pointer that determines if the 'if' statement is TRUE or FALSE from the given tensor data frame.&quot;);</span>
<span id="L3087"><span class="lineNum">    3087</span> <span class="tlaGNC">           5 :   if (!if_custom)</span></span>
<span id="L3088"><span class="lineNum">    3088</span> <span class="tlaGNC">           1 :     _ml_error_report_return (ML_ERROR_INVALID_PARAMETER,</span></span>
<span id="L3089"><span class="lineNum">    3089</span>              :         &quot;The parameter, if_custom (ml_pipeline_if_h *), is NULL. It should be a valid pointer to the pipeline-if handle instance. E.g., ml_pipeline_if_h h; ml_pipeline_tensor_if_custom_register (..., &amp;h);&quot;);</span>
<span id="L3090"><span class="lineNum">    3090</span>              : </span>
<span id="L3091"><span class="lineNum">    3091</span>              :   /* init null */</span>
<span id="L3092"><span class="lineNum">    3092</span> <span class="tlaGNC">           4 :   *if_custom = NULL;</span></span>
<span id="L3093"><span class="lineNum">    3093</span>              : </span>
<span id="L3094"><span class="lineNum">    3094</span>              :   /* create and init custom handle */</span>
<span id="L3095"><span class="lineNum">    3095</span> <span class="tlaGNC">           4 :   if ((c = g_try_new0 (ml_if_custom_s, 1)) == NULL)</span></span>
<span id="L3096"><span class="lineNum">    3096</span> <span class="tlaUNC tlaBgUNC">           0 :     _ml_error_report_return (ML_ERROR_OUT_OF_MEMORY,</span></span>
<span id="L3097"><span class="lineNum">    3097</span>              :         &quot;Cannot allocate memory. Out of memory?&quot;);</span>
<span id="L3098"><span class="lineNum">    3098</span>              : </span>
<span id="L3099"><span class="lineNum">    3099</span> <span class="tlaGNC tlaBgGNC">           4 :   g_mutex_init (&amp;c-&gt;lock);</span></span>
<span id="L3100"><span class="lineNum">    3100</span>              : </span>
<span id="L3101"><span class="lineNum">    3101</span> <span class="tlaGNC">           4 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L3102"><span class="lineNum">    3102</span> <span class="tlaGNC">           4 :   c-&gt;name = g_strdup (name);</span></span>
<span id="L3103"><span class="lineNum">    3103</span> <span class="tlaGNC">           4 :   c-&gt;ref_count = 0;</span></span>
<span id="L3104"><span class="lineNum">    3104</span> <span class="tlaGNC">           4 :   c-&gt;cb = cb;</span></span>
<span id="L3105"><span class="lineNum">    3105</span> <span class="tlaGNC">           4 :   c-&gt;pdata = user_data;</span></span>
<span id="L3106"><span class="lineNum">    3106</span>              : </span>
<span id="L3107"><span class="lineNum">    3107</span> <span class="tlaGNC">           4 :   status = nnstreamer_if_custom_register (name, ml_pipeline_if_custom, c);</span></span>
<span id="L3108"><span class="lineNum">    3108</span> <span class="tlaGNC">           4 :   if (status != 0) {</span></span>
<span id="L3109"><span class="lineNum">    3109</span> <span class="tlaGNC">           1 :     if (status == -ENOMEM) {</span></span>
<span id="L3110"><span class="lineNum">    3110</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L3111"><span class="lineNum">    3111</span>              :           (&quot;Failed to register tensor_if custom condition %s because nnstreamer_if_custom_register has failed to allocate memory. Out of memory?&quot;,</span>
<span id="L3112"><span class="lineNum">    3112</span>              :           name);</span>
<span id="L3113"><span class="lineNum">    3113</span> <span class="tlaUNC">           0 :       status = ML_ERROR_OUT_OF_MEMORY;</span></span>
<span id="L3114"><span class="lineNum">    3114</span> <span class="tlaGNC tlaBgGNC">           1 :     } else if (status == -EINVAL) {</span></span>
<span id="L3115"><span class="lineNum">    3115</span> <span class="tlaGNC">           1 :       _ml_error_report</span></span>
<span id="L3116"><span class="lineNum">    3116</span>              :           (&quot;Failed to register tensor_if custom condition %s because nnstreamer_if_custom_register has reported that an invalid parameter is given to the API call. Please check if the given name is 0-length or duplicated (already registered), memory is full, or the name is not allowed ('any', 'auto' are not allowed).&quot;,</span>
<span id="L3117"><span class="lineNum">    3117</span>              :           name);</span>
<span id="L3118"><span class="lineNum">    3118</span> <span class="tlaGNC">           1 :       status = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L3119"><span class="lineNum">    3119</span>              :     } else {</span>
<span id="L3120"><span class="lineNum">    3120</span> <span class="tlaUNC tlaBgUNC">           0 :       _ml_error_report</span></span>
<span id="L3121"><span class="lineNum">    3121</span>              :           (&quot;Failed to register tensor_if custom condition %s because nnstreamer_if_custom_register has returned unknown error.&quot;,</span>
<span id="L3122"><span class="lineNum">    3122</span>              :           name);</span>
<span id="L3123"><span class="lineNum">    3123</span> <span class="tlaUNC">           0 :       status = ML_ERROR_UNKNOWN;</span></span>
<span id="L3124"><span class="lineNum">    3124</span>              :     }</span>
<span id="L3125"><span class="lineNum">    3125</span>              :   }</span>
<span id="L3126"><span class="lineNum">    3126</span> <span class="tlaGNC tlaBgGNC">           4 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L3127"><span class="lineNum">    3127</span>              : </span>
<span id="L3128"><span class="lineNum">    3128</span> <span class="tlaGNC">           4 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L3129"><span class="lineNum">    3129</span> <span class="tlaGNC">           3 :     pipe_custom_add_data (PIPE_CUSTOM_TYPE_IF, name, c);</span></span>
<span id="L3130"><span class="lineNum">    3130</span> <span class="tlaGNC">           3 :     *if_custom = c;</span></span>
<span id="L3131"><span class="lineNum">    3131</span>              :   } else {</span>
<span id="L3132"><span class="lineNum">    3132</span> <span class="tlaGNC">           1 :     ml_pipeline_if_custom_free (c);</span></span>
<span id="L3133"><span class="lineNum">    3133</span>              :   }</span>
<span id="L3134"><span class="lineNum">    3134</span>              : </span>
<span id="L3135"><span class="lineNum">    3135</span> <span class="tlaGNC">           4 :   return status;</span></span>
<span id="L3136"><span class="lineNum">    3136</span>              : }</span>
<span id="L3137"><span class="lineNum">    3137</span>              : </span>
<span id="L3138"><span class="lineNum">    3138</span>              : /**</span>
<span id="L3139"><span class="lineNum">    3139</span>              :  * @brief Unregisters the tensor_if custom callback.</span>
<span id="L3140"><span class="lineNum">    3140</span>              :  */</span>
<span id="L3141"><span class="lineNum">    3141</span>              : int</span>
<span id="L3142"><span class="lineNum">    3142</span> <span class="tlaGNC">           6 : ml_pipeline_tensor_if_custom_unregister (ml_pipeline_if_h if_custom)</span></span>
<span id="L3143"><span class="lineNum">    3143</span>              : {</span>
<span id="L3144"><span class="lineNum">    3144</span>              :   ml_if_custom_s *c;</span>
<span id="L3145"><span class="lineNum">    3145</span> <span class="tlaGNC">           6 :   int status = ML_ERROR_NONE;</span></span>
<span id="L3146"><span class="lineNum">    3146</span>              : </span>
<span id="L3147"><span class="lineNum">    3147</span> <span class="tlaGNC">           6 :   check_feature_state (ML_FEATURE_INFERENCE);</span></span>
<span id="L3148"><span class="lineNum">    3148</span>              : </span>
<span id="L3149"><span class="lineNum">    3149</span> <span class="tlaGNC">           6 :   if (!if_custom)</span></span>
<span id="L3150"><span class="lineNum">    3150</span> <span class="tlaGNC">           1 :     return ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L3151"><span class="lineNum">    3151</span>              : </span>
<span id="L3152"><span class="lineNum">    3152</span> <span class="tlaGNC">           5 :   c = (ml_if_custom_s *) if_custom;</span></span>
<span id="L3153"><span class="lineNum">    3153</span> <span class="tlaGNC">           5 :   g_mutex_lock (&amp;c-&gt;lock);</span></span>
<span id="L3154"><span class="lineNum">    3154</span>              : </span>
<span id="L3155"><span class="lineNum">    3155</span> <span class="tlaGNC">           5 :   if (c-&gt;ref_count &gt; 0) {</span></span>
<span id="L3156"><span class="lineNum">    3156</span> <span class="tlaGNC">           2 :     _ml_error_report</span></span>
<span id="L3157"><span class="lineNum">    3157</span>              :         (&quot;Failed to unregister custom condition %s, it is used in the pipeline.&quot;,</span>
<span id="L3158"><span class="lineNum">    3158</span>              :         c-&gt;name);</span>
<span id="L3159"><span class="lineNum">    3159</span> <span class="tlaGNC">           2 :     status = ML_ERROR_INVALID_PARAMETER;</span></span>
<span id="L3160"><span class="lineNum">    3160</span> <span class="tlaGNC">           2 :     goto done;</span></span>
<span id="L3161"><span class="lineNum">    3161</span>              :   }</span>
<span id="L3162"><span class="lineNum">    3162</span>              : </span>
<span id="L3163"><span class="lineNum">    3163</span> <span class="tlaGNC">           3 :   status = nnstreamer_if_custom_unregister (c-&gt;name);</span></span>
<span id="L3164"><span class="lineNum">    3164</span> <span class="tlaGNC">           3 :   if (status != 0) {</span></span>
<span id="L3165"><span class="lineNum">    3165</span> <span class="tlaUNC tlaBgUNC">           0 :     if (status == -EINVAL)</span></span>
<span id="L3166"><span class="lineNum">    3166</span> <span class="tlaUNC">           0 :       _ml_error_report</span></span>
<span id="L3167"><span class="lineNum">    3167</span>              :           (&quot;Failed to unregister tensor_if custom condition %s. It appears that it is already unregistered or not yet registered.&quot;,</span>
<span id="L3168"><span class="lineNum">    3168</span>              :           c-&gt;name);</span>
<span id="L3169"><span class="lineNum">    3169</span>              :     else</span>
<span id="L3170"><span class="lineNum">    3170</span> <span class="tlaUNC">           0 :       _ml_error_report</span></span>
<span id="L3171"><span class="lineNum">    3171</span>              :           (&quot;Failed to unregister tensor_if custom condition %s with unknown reason. Internal error?&quot;,</span>
<span id="L3172"><span class="lineNum">    3172</span>              :           c-&gt;name);</span>
<span id="L3173"><span class="lineNum">    3173</span> <span class="tlaUNC">           0 :     status = ML_ERROR_STREAMS_PIPE;</span></span>
<span id="L3174"><span class="lineNum">    3174</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L3175"><span class="lineNum">    3175</span>              :   }</span>
<span id="L3176"><span class="lineNum">    3176</span>              : </span>
<span id="L3177"><span class="lineNum">    3177</span> <span class="tlaGNC tlaBgGNC">           3 : done:</span></span>
<span id="L3178"><span class="lineNum">    3178</span> <span class="tlaGNC">           5 :   g_mutex_unlock (&amp;c-&gt;lock);</span></span>
<span id="L3179"><span class="lineNum">    3179</span>              : </span>
<span id="L3180"><span class="lineNum">    3180</span> <span class="tlaGNC">           5 :   if (status == ML_ERROR_NONE) {</span></span>
<span id="L3181"><span class="lineNum">    3181</span> <span class="tlaGNC">           3 :     pipe_custom_remove_data (PIPE_CUSTOM_TYPE_IF, c-&gt;name);</span></span>
<span id="L3182"><span class="lineNum">    3182</span> <span class="tlaGNC">           3 :     ml_pipeline_if_custom_free (c);</span></span>
<span id="L3183"><span class="lineNum">    3183</span>              :   }</span>
<span id="L3184"><span class="lineNum">    3184</span>              : </span>
<span id="L3185"><span class="lineNum">    3185</span> <span class="tlaGNC">           5 :   return status;</span></span>
<span id="L3186"><span class="lineNum">    3186</span>              : }</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>

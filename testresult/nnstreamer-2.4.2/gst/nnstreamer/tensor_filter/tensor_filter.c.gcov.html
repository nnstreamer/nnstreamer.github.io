<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - nnstreamer 2.4.2-0 nnstreamer/nnstreamer#794ad8e5a6f4596fe39aecfda4643ba05330c614 - nnstreamer-2.4.2/gst/nnstreamer/tensor_filter/tensor_filter.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">nnstreamer-2.4.2/gst/nnstreamer/tensor_filter</a> - tensor_filter.c<span style="font-size: 80%;"> (source / <a href="tensor_filter.c.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">nnstreamer 2.4.2-0 nnstreamer/nnstreamer#794ad8e5a6f4596fe39aecfda4643ba05330c614</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryMed">80.1&nbsp;%</td>
            <td class="headerCovTableEntry">755</td>
            <td class="headerCovTableEntry">605</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-07-02 05:39:02</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">97.4&nbsp;%</td>
            <td class="headerCovTableEntry">38</td>
            <td class="headerCovTableEntry">37</td>
          </tr>
                  <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /**</span>
<span id="L2"><span class="lineNum">       2</span>              :  * GStreamer Tensor_Filter</span>
<span id="L3"><span class="lineNum">       3</span>              :  * Copyright (C) 2005 Thomas Vander Stichele &lt;thomas@apestaart.org&gt;</span>
<span id="L4"><span class="lineNum">       4</span>              :  * Copyright (C) 2005 Ronald S. Bultje &lt;rbultje@ronald.bitfreak.net&gt;</span>
<span id="L5"><span class="lineNum">       5</span>              :  * Copyright (C) 2018 MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;</span>
<span id="L6"><span class="lineNum">       6</span>              :  *</span>
<span id="L7"><span class="lineNum">       7</span>              :  * This library is free software; you can redistribute it and/or</span>
<span id="L8"><span class="lineNum">       8</span>              :  * modify it under the terms of the GNU Library General Public</span>
<span id="L9"><span class="lineNum">       9</span>              :  * License as published by the Free Software Foundation;</span>
<span id="L10"><span class="lineNum">      10</span>              :  * version 2.1 of the License.</span>
<span id="L11"><span class="lineNum">      11</span>              :  *</span>
<span id="L12"><span class="lineNum">      12</span>              :  * This library is distributed in the hope that it will be useful,</span>
<span id="L13"><span class="lineNum">      13</span>              :  * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span id="L14"><span class="lineNum">      14</span>              :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span id="L15"><span class="lineNum">      15</span>              :  * Library General Public License for more details.</span>
<span id="L16"><span class="lineNum">      16</span>              :  *</span>
<span id="L17"><span class="lineNum">      17</span>              :  */</span>
<span id="L18"><span class="lineNum">      18</span>              : /**</span>
<span id="L19"><span class="lineNum">      19</span>              :  * @file        tensor_filter.c</span>
<span id="L20"><span class="lineNum">      20</span>              :  * @date        24 May 2018</span>
<span id="L21"><span class="lineNum">      21</span>              :  * @brief       GStreamer plugin to use general neural network frameworks as filters</span>
<span id="L22"><span class="lineNum">      22</span>              :  * @see         http://github.com/nnstreamer/nnstreamer</span>
<span id="L23"><span class="lineNum">      23</span>              :  * @author      MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;</span>
<span id="L24"><span class="lineNum">      24</span>              :  * @bug         No known bugs except for NYI items</span>
<span id="L25"><span class="lineNum">      25</span>              :  * @todo  set priority among properties</span>
<span id="L26"><span class="lineNum">      26</span>              :  * @todo  logic for dynamic properties(like model change)</span>
<span id="L27"><span class="lineNum">      27</span>              :  *</span>
<span id="L28"><span class="lineNum">      28</span>              :  * This is the main plugin for per-NN-framework plugins.</span>
<span id="L29"><span class="lineNum">      29</span>              :  * Specific implementations for each NN framework must be written</span>
<span id="L30"><span class="lineNum">      30</span>              :  * in each framework specific files; e.g., tensor_filter_tensorflow_lite.c</span>
<span id="L31"><span class="lineNum">      31</span>              :  *</span>
<span id="L32"><span class="lineNum">      32</span>              :  */</span>
<span id="L33"><span class="lineNum">      33</span>              : </span>
<span id="L34"><span class="lineNum">      34</span>              : /**</span>
<span id="L35"><span class="lineNum">      35</span>              :  * SECTION:element-tensor_filter</span>
<span id="L36"><span class="lineNum">      36</span>              :  *</span>
<span id="L37"><span class="lineNum">      37</span>              :  * A plugin that invokes neural network models and their framework or</span>
<span id="L38"><span class="lineNum">      38</span>              :  * an independent shared object implementing tensor_filter_custom.h.</span>
<span id="L39"><span class="lineNum">      39</span>              :  * The input and output are always in the format of other/tensor or</span>
<span id="L40"><span class="lineNum">      40</span>              :  * other/tensors.</span>
<span id="L41"><span class="lineNum">      41</span>              :  *</span>
<span id="L42"><span class="lineNum">      42</span>              :  * &lt;refsect2&gt;</span>
<span id="L43"><span class="lineNum">      43</span>              :  * &lt;title&gt;Example launch line&lt;/title&gt;</span>
<span id="L44"><span class="lineNum">      44</span>              :  * |[</span>
<span id="L45"><span class="lineNum">      45</span>              :  * gst-launch -v -m fakesrc ! tensor_filter framework=tensorflow-lite, model=./inception_v3.pb, input=3:224:224, output=1000 ! fakesink silent=TRUE</span>
<span id="L46"><span class="lineNum">      46</span>              :  * ]|</span>
<span id="L47"><span class="lineNum">      47</span>              :  * &lt;/refsect2&gt;</span>
<span id="L48"><span class="lineNum">      48</span>              :  *</span>
<span id="L49"><span class="lineNum">      49</span>              :  * If input is other/tensor C array input[1][224][224][3] and</span>
<span id="L50"><span class="lineNum">      50</span>              :  * output is other/tensor C array output[1][1][1][1000]</span>
<span id="L51"><span class="lineNum">      51</span>              :  *</span>
<span id="L52"><span class="lineNum">      52</span>              :  * The current QoS policy: In a nnstreamer pipeline, the QoS is currently satisfied</span>
<span id="L53"><span class="lineNum">      53</span>              :  * by adjusting a input or output framerate, initiated by 'tensor_rate' element.</span>
<span id="L54"><span class="lineNum">      54</span>              :  * When 'tensor_filter' receives a throttling QoS event from the 'tensor_rate' element,</span>
<span id="L55"><span class="lineNum">      55</span>              :  * it compares the average processing latency and throttling delay, and takes the</span>
<span id="L56"><span class="lineNum">      56</span>              :  * maximum value as the threshold to drop incoming frames by checking a buffer timestamp.</span>
<span id="L57"><span class="lineNum">      57</span>              :  * In this way, 'tensor filter' can avoid unnecessary calculation and adjust a framerate,</span>
<span id="L58"><span class="lineNum">      58</span>              :  * effectively reducing resource utilizations.</span>
<span id="L59"><span class="lineNum">      59</span>              :  * Even in the case of receiving QoS events from multiple downstream pipelines (e.g., tee),</span>
<span id="L60"><span class="lineNum">      60</span>              :  * 'tensor_filter' takes the minimum value as the throttling delay for downstream pipeline</span>
<span id="L61"><span class="lineNum">      61</span>              :  * with more tight QoS requirement. Lastly, 'tensor_filter' also sends QoS events to</span>
<span id="L62"><span class="lineNum">      62</span>              :  * upstream elements (e.g., tensor_converter, tensor_src) to possibly reduce incoming</span>
<span id="L63"><span class="lineNum">      63</span>              :  * framerates, which is a better solution than dropping framerates.</span>
<span id="L64"><span class="lineNum">      64</span>              :  */</span>
<span id="L65"><span class="lineNum">      65</span>              : </span>
<span id="L66"><span class="lineNum">      66</span>              : #ifdef HAVE_CONFIG_H</span>
<span id="L67"><span class="lineNum">      67</span>              : #include &lt;config.h&gt;</span>
<span id="L68"><span class="lineNum">      68</span>              : #endif</span>
<span id="L69"><span class="lineNum">      69</span>              : </span>
<span id="L70"><span class="lineNum">      70</span>              : #include &lt;string.h&gt;</span>
<span id="L71"><span class="lineNum">      71</span>              : #include &lt;nnstreamer_util.h&gt;</span>
<span id="L72"><span class="lineNum">      72</span>              : </span>
<span id="L73"><span class="lineNum">      73</span>              : #include &quot;tensor_filter.h&quot;</span>
<span id="L74"><span class="lineNum">      74</span>              : </span>
<span id="L75"><span class="lineNum">      75</span>              : /** @todo rename &amp; move this to better location */</span>
<span id="L76"><span class="lineNum">      76</span>              : #define EVENT_NAME_UPDATE_MODEL &quot;evt_update_model&quot;</span>
<span id="L77"><span class="lineNum">      77</span>              : </span>
<span id="L78"><span class="lineNum">      78</span>              : GST_DEBUG_CATEGORY_STATIC (gst_tensor_filter_debug);</span>
<span id="L79"><span class="lineNum">      79</span>              : #define GST_CAT_DEFAULT gst_tensor_filter_debug</span>
<span id="L80"><span class="lineNum">      80</span>              : </span>
<span id="L81"><span class="lineNum">      81</span>              : /**</span>
<span id="L82"><span class="lineNum">      82</span>              :  * @brief Default caps string for both sink and source pad.</span>
<span id="L83"><span class="lineNum">      83</span>              :  */</span>
<span id="L84"><span class="lineNum">      84</span>              : #define CAPS_STRING GST_TENSOR_CAP_DEFAULT &quot;;&quot; GST_TENSORS_CAP_MAKE (&quot;{ static, flexible }&quot;)</span>
<span id="L85"><span class="lineNum">      85</span>              : </span>
<span id="L86"><span class="lineNum">      86</span>              : /**</span>
<span id="L87"><span class="lineNum">      87</span>              :  * @brief The capabilities of the inputs</span>
<span id="L88"><span class="lineNum">      88</span>              :  */</span>
<span id="L89"><span class="lineNum">      89</span>              : static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,</span>
<span id="L90"><span class="lineNum">      90</span>              :     GST_PAD_SINK,</span>
<span id="L91"><span class="lineNum">      91</span>              :     GST_PAD_ALWAYS,</span>
<span id="L92"><span class="lineNum">      92</span>              :     GST_STATIC_CAPS (CAPS_STRING));</span>
<span id="L93"><span class="lineNum">      93</span>              : </span>
<span id="L94"><span class="lineNum">      94</span>              : /**</span>
<span id="L95"><span class="lineNum">      95</span>              :  * @brief The capabilities of the outputs</span>
<span id="L96"><span class="lineNum">      96</span>              :  */</span>
<span id="L97"><span class="lineNum">      97</span>              : static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,</span>
<span id="L98"><span class="lineNum">      98</span>              :     GST_PAD_SRC,</span>
<span id="L99"><span class="lineNum">      99</span>              :     GST_PAD_ALWAYS,</span>
<span id="L100"><span class="lineNum">     100</span>              :     GST_STATIC_CAPS (CAPS_STRING));</span>
<span id="L101"><span class="lineNum">     101</span>              : </span>
<span id="L102"><span class="lineNum">     102</span>              : #define gst_tensor_filter_parent_class parent_class</span>
<span id="L103"><span class="lineNum">     103</span> <span class="tlaGNC tlaBgGNC">        2033 : G_DEFINE_TYPE (GstTensorFilter, gst_tensor_filter, GST_TYPE_BASE_TRANSFORM);</span></span>
<span id="L104"><span class="lineNum">     104</span>              : </span>
<span id="L105"><span class="lineNum">     105</span>              : /**</span>
<span id="L106"><span class="lineNum">     106</span>              :  * @brief Headroom (extra duration) added to actual latency estimate reported</span>
<span id="L107"><span class="lineNum">     107</span>              :  *        to LATENCY query, to limit number of updates when tracking the</span>
<span id="L108"><span class="lineNum">     108</span>              :  *        maximum value - arbitrarily set to 5%.</span>
<span id="L109"><span class="lineNum">     109</span>              :  */</span>
<span id="L110"><span class="lineNum">     110</span>              : #define LATENCY_REPORT_HEADROOM 0.05</span>
<span id="L111"><span class="lineNum">     111</span>              : </span>
<span id="L112"><span class="lineNum">     112</span>              : /**</span>
<span id="L113"><span class="lineNum">     113</span>              :  * @brief Threshold deciding when tracking latency estimate that current</span>
<span id="L114"><span class="lineNum">     114</span>              :  *        value is sufficiently lower than reported value so that a</span>
<span id="L115"><span class="lineNum">     115</span>              :  *        notification update is necessary - arbitrarily set to 25%.</span>
<span id="L116"><span class="lineNum">     116</span>              :  */</span>
<span id="L117"><span class="lineNum">     117</span>              : #define LATENCY_REPORT_THRESHOLD 0.25</span>
<span id="L118"><span class="lineNum">     118</span>              : </span>
<span id="L119"><span class="lineNum">     119</span>              : /* GObject vmethod implementations */</span>
<span id="L120"><span class="lineNum">     120</span>              : static void gst_tensor_filter_set_property (GObject * object, guint prop_id,</span>
<span id="L121"><span class="lineNum">     121</span>              :     const GValue * value, GParamSpec * pspec);</span>
<span id="L122"><span class="lineNum">     122</span>              : static void gst_tensor_filter_get_property (GObject * object, guint prop_id,</span>
<span id="L123"><span class="lineNum">     123</span>              :     GValue * value, GParamSpec * pspec);</span>
<span id="L124"><span class="lineNum">     124</span>              : static void gst_tensor_filter_finalize (GObject * object);</span>
<span id="L125"><span class="lineNum">     125</span>              : </span>
<span id="L126"><span class="lineNum">     126</span>              : /* GstBaseTransform vmethod implementations */</span>
<span id="L127"><span class="lineNum">     127</span>              : static GstFlowReturn gst_tensor_filter_transform (GstBaseTransform * trans,</span>
<span id="L128"><span class="lineNum">     128</span>              :     GstBuffer * inbuf, GstBuffer * outbuf);</span>
<span id="L129"><span class="lineNum">     129</span>              : static GstCaps *gst_tensor_filter_transform_caps (GstBaseTransform * trans,</span>
<span id="L130"><span class="lineNum">     130</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * filter);</span>
<span id="L131"><span class="lineNum">     131</span>              : static GstCaps *gst_tensor_filter_fixate_caps (GstBaseTransform * trans,</span>
<span id="L132"><span class="lineNum">     132</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);</span>
<span id="L133"><span class="lineNum">     133</span>              : static gboolean gst_tensor_filter_set_caps (GstBaseTransform * trans,</span>
<span id="L134"><span class="lineNum">     134</span>              :     GstCaps * incaps, GstCaps * outcaps);</span>
<span id="L135"><span class="lineNum">     135</span>              : static gboolean gst_tensor_filter_query (GstBaseTransform * trans,</span>
<span id="L136"><span class="lineNum">     136</span>              :     GstPadDirection direction, GstQuery * query);</span>
<span id="L137"><span class="lineNum">     137</span>              : static gboolean gst_tensor_filter_transform_size (GstBaseTransform * trans,</span>
<span id="L138"><span class="lineNum">     138</span>              :     GstPadDirection direction, GstCaps * caps, gsize size,</span>
<span id="L139"><span class="lineNum">     139</span>              :     GstCaps * othercaps, gsize * othersize);</span>
<span id="L140"><span class="lineNum">     140</span>              : static gboolean gst_tensor_filter_start (GstBaseTransform * trans);</span>
<span id="L141"><span class="lineNum">     141</span>              : static gboolean gst_tensor_filter_stop (GstBaseTransform * trans);</span>
<span id="L142"><span class="lineNum">     142</span>              : static gboolean gst_tensor_filter_sink_event (GstBaseTransform * trans,</span>
<span id="L143"><span class="lineNum">     143</span>              :     GstEvent * event);</span>
<span id="L144"><span class="lineNum">     144</span>              : static gboolean gst_tensor_filter_src_event (GstBaseTransform * trans,</span>
<span id="L145"><span class="lineNum">     145</span>              :     GstEvent * event);</span>
<span id="L146"><span class="lineNum">     146</span>              : </span>
<span id="L147"><span class="lineNum">     147</span>              : /**</span>
<span id="L148"><span class="lineNum">     148</span>              :  * @brief Internal data structure for tensor_filter transform data.</span>
<span id="L149"><span class="lineNum">     149</span>              :  */</span>
<span id="L150"><span class="lineNum">     150</span>              : typedef struct _FilterTransformData</span>
<span id="L151"><span class="lineNum">     151</span>              : {</span>
<span id="L152"><span class="lineNum">     152</span>              :   GstMemory *mem[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L153"><span class="lineNum">     153</span>              :   GstMapInfo info[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L154"><span class="lineNum">     154</span>              :   GstTensorMetaInfo meta[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L155"><span class="lineNum">     155</span>              :   guint num_tensors;</span>
<span id="L156"><span class="lineNum">     156</span>              :   GstTensorMemory tensors[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L157"><span class="lineNum">     157</span>              : </span>
<span id="L158"><span class="lineNum">     158</span>              :   gboolean is_flexible;</span>
<span id="L159"><span class="lineNum">     159</span>              :   gboolean allocate_in_invoke;</span>
<span id="L160"><span class="lineNum">     160</span>              : } FilterTransformData;</span>
<span id="L161"><span class="lineNum">     161</span>              : </span>
<span id="L162"><span class="lineNum">     162</span>              : /**</span>
<span id="L163"><span class="lineNum">     163</span>              :  * @brief initialize the tensor_filter's class</span>
<span id="L164"><span class="lineNum">     164</span>              :  */</span>
<span id="L165"><span class="lineNum">     165</span>              : static void</span>
<span id="L166"><span class="lineNum">     166</span> <span class="tlaGNC">         128 : gst_tensor_filter_class_init (GstTensorFilterClass * klass)</span></span>
<span id="L167"><span class="lineNum">     167</span>              : {</span>
<span id="L168"><span class="lineNum">     168</span>              :   GObjectClass *gobject_class;</span>
<span id="L169"><span class="lineNum">     169</span>              :   GstElementClass *gstelement_class;</span>
<span id="L170"><span class="lineNum">     170</span>              :   GstBaseTransformClass *trans_class;</span>
<span id="L171"><span class="lineNum">     171</span>              : </span>
<span id="L172"><span class="lineNum">     172</span> <span class="tlaGNC">         128 :   GST_DEBUG_CATEGORY_INIT (gst_tensor_filter_debug, &quot;tensor_filter&quot;, 0,</span></span>
<span id="L173"><span class="lineNum">     173</span>              :       &quot;Tensor filter to invoke neural network model&quot;);</span>
<span id="L174"><span class="lineNum">     174</span>              : </span>
<span id="L175"><span class="lineNum">     175</span> <span class="tlaGNC">         128 :   trans_class = (GstBaseTransformClass *) klass;</span></span>
<span id="L176"><span class="lineNum">     176</span> <span class="tlaGNC">         128 :   gstelement_class = (GstElementClass *) trans_class;</span></span>
<span id="L177"><span class="lineNum">     177</span> <span class="tlaGNC">         128 :   gobject_class = (GObjectClass *) gstelement_class;</span></span>
<span id="L178"><span class="lineNum">     178</span>              : </span>
<span id="L179"><span class="lineNum">     179</span> <span class="tlaGNC">         128 :   gobject_class-&gt;set_property = gst_tensor_filter_set_property;</span></span>
<span id="L180"><span class="lineNum">     180</span> <span class="tlaGNC">         128 :   gobject_class-&gt;get_property = gst_tensor_filter_get_property;</span></span>
<span id="L181"><span class="lineNum">     181</span> <span class="tlaGNC">         128 :   gobject_class-&gt;finalize = gst_tensor_filter_finalize;</span></span>
<span id="L182"><span class="lineNum">     182</span>              : </span>
<span id="L183"><span class="lineNum">     183</span> <span class="tlaGNC">         128 :   gst_tensor_filter_install_properties (gobject_class);</span></span>
<span id="L184"><span class="lineNum">     184</span>              : </span>
<span id="L185"><span class="lineNum">     185</span> <span class="tlaGNC">         128 :   gst_element_class_set_details_simple (gstelement_class,</span></span>
<span id="L186"><span class="lineNum">     186</span>              :       &quot;TensorFilter&quot;,</span>
<span id="L187"><span class="lineNum">     187</span>              :       &quot;Filter/Tensor&quot;,</span>
<span id="L188"><span class="lineNum">     188</span>              :       &quot;Handles NN Frameworks (e.g., tensorflow) as Media Filters with other/tensor type stream&quot;,</span>
<span id="L189"><span class="lineNum">     189</span>              :       &quot;MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;&quot;);</span>
<span id="L190"><span class="lineNum">     190</span>              : </span>
<span id="L191"><span class="lineNum">     191</span> <span class="tlaGNC">         128 :   gst_element_class_add_pad_template (gstelement_class,</span></span>
<span id="L192"><span class="lineNum">     192</span>              :       gst_static_pad_template_get (&amp;src_factory));</span>
<span id="L193"><span class="lineNum">     193</span> <span class="tlaGNC">         128 :   gst_element_class_add_pad_template (gstelement_class,</span></span>
<span id="L194"><span class="lineNum">     194</span>              :       gst_static_pad_template_get (&amp;sink_factory));</span>
<span id="L195"><span class="lineNum">     195</span>              : </span>
<span id="L196"><span class="lineNum">     196</span>              :   /* Refer: https://gstreamer.freedesktop.org/documentation/design/element-transform.html */</span>
<span id="L197"><span class="lineNum">     197</span> <span class="tlaGNC">         128 :   trans_class-&gt;passthrough_on_same_caps = FALSE;</span></span>
<span id="L198"><span class="lineNum">     198</span>              : </span>
<span id="L199"><span class="lineNum">     199</span>              :   /* Processing units */</span>
<span id="L200"><span class="lineNum">     200</span> <span class="tlaGNC">         128 :   trans_class-&gt;transform = GST_DEBUG_FUNCPTR (gst_tensor_filter_transform);</span></span>
<span id="L201"><span class="lineNum">     201</span>              : </span>
<span id="L202"><span class="lineNum">     202</span>              :   /* Negotiation units */</span>
<span id="L203"><span class="lineNum">     203</span> <span class="tlaGNC">         128 :   trans_class-&gt;transform_caps =</span></span>
<span id="L204"><span class="lineNum">     204</span> <span class="tlaGNC">         128 :       GST_DEBUG_FUNCPTR (gst_tensor_filter_transform_caps);</span></span>
<span id="L205"><span class="lineNum">     205</span> <span class="tlaGNC">         128 :   trans_class-&gt;fixate_caps = GST_DEBUG_FUNCPTR (gst_tensor_filter_fixate_caps);</span></span>
<span id="L206"><span class="lineNum">     206</span> <span class="tlaGNC">         128 :   trans_class-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_tensor_filter_set_caps);</span></span>
<span id="L207"><span class="lineNum">     207</span>              : </span>
<span id="L208"><span class="lineNum">     208</span>              :   /* Allocation units */</span>
<span id="L209"><span class="lineNum">     209</span> <span class="tlaGNC">         128 :   trans_class-&gt;transform_size =</span></span>
<span id="L210"><span class="lineNum">     210</span> <span class="tlaGNC">         128 :       GST_DEBUG_FUNCPTR (gst_tensor_filter_transform_size);</span></span>
<span id="L211"><span class="lineNum">     211</span>              : </span>
<span id="L212"><span class="lineNum">     212</span>              :   /* setup events */</span>
<span id="L213"><span class="lineNum">     213</span> <span class="tlaGNC">         128 :   trans_class-&gt;sink_event = GST_DEBUG_FUNCPTR (gst_tensor_filter_sink_event);</span></span>
<span id="L214"><span class="lineNum">     214</span> <span class="tlaGNC">         128 :   trans_class-&gt;src_event = GST_DEBUG_FUNCPTR (gst_tensor_filter_src_event);</span></span>
<span id="L215"><span class="lineNum">     215</span>              : </span>
<span id="L216"><span class="lineNum">     216</span>              :   /* start/stop to call open/close */</span>
<span id="L217"><span class="lineNum">     217</span> <span class="tlaGNC">         128 :   trans_class-&gt;start = GST_DEBUG_FUNCPTR (gst_tensor_filter_start);</span></span>
<span id="L218"><span class="lineNum">     218</span> <span class="tlaGNC">         128 :   trans_class-&gt;stop = GST_DEBUG_FUNCPTR (gst_tensor_filter_stop);</span></span>
<span id="L219"><span class="lineNum">     219</span>              : </span>
<span id="L220"><span class="lineNum">     220</span>              :   /* Queries */</span>
<span id="L221"><span class="lineNum">     221</span> <span class="tlaGNC">         128 :   trans_class-&gt;query = GST_DEBUG_FUNCPTR (gst_tensor_filter_query);</span></span>
<span id="L222"><span class="lineNum">     222</span> <span class="tlaGNC">         128 : }</span></span>
<span id="L223"><span class="lineNum">     223</span>              : </span>
<span id="L224"><span class="lineNum">     224</span>              : /**</span>
<span id="L225"><span class="lineNum">     225</span>              :  * @brief initialize the new element</span>
<span id="L226"><span class="lineNum">     226</span>              :  * instantiate pads and add them to element</span>
<span id="L227"><span class="lineNum">     227</span>              :  * set pad callback functions</span>
<span id="L228"><span class="lineNum">     228</span>              :  * initialize instance structure</span>
<span id="L229"><span class="lineNum">     229</span>              :  */</span>
<span id="L230"><span class="lineNum">     230</span>              : static void</span>
<span id="L231"><span class="lineNum">     231</span> <span class="tlaGNC">         256 : gst_tensor_filter_init (GstTensorFilter * self)</span></span>
<span id="L232"><span class="lineNum">     232</span>              : {</span>
<span id="L233"><span class="lineNum">     233</span> <span class="tlaGNC">         256 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L234"><span class="lineNum">     234</span>              : </span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC">         256 :   gst_tensor_filter_common_init_property (priv);</span></span>
<span id="L236"><span class="lineNum">     236</span>              :   /* init qos properties */</span>
<span id="L237"><span class="lineNum">     237</span> <span class="tlaGNC">         256 :   self-&gt;prev_ts = GST_CLOCK_TIME_NONE;</span></span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">         256 :   self-&gt;throttling_delay = 0;</span></span>
<span id="L239"><span class="lineNum">     239</span> <span class="tlaGNC">         256 :   self-&gt;throttling_accum = 0;</span></span>
<span id="L240"><span class="lineNum">     240</span> <span class="tlaGNC">         256 : }</span></span>
<span id="L241"><span class="lineNum">     241</span>              : </span>
<span id="L242"><span class="lineNum">     242</span>              : /**</span>
<span id="L243"><span class="lineNum">     243</span>              :  * @brief Function to finalize instance.</span>
<span id="L244"><span class="lineNum">     244</span>              :  */</span>
<span id="L245"><span class="lineNum">     245</span>              : static void</span>
<span id="L246"><span class="lineNum">     246</span> <span class="tlaGNC">         215 : gst_tensor_filter_finalize (GObject * object)</span></span>
<span id="L247"><span class="lineNum">     247</span>              : {</span>
<span id="L248"><span class="lineNum">     248</span>              :   GstTensorFilter *self;</span>
<span id="L249"><span class="lineNum">     249</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L250"><span class="lineNum">     250</span>              : </span>
<span id="L251"><span class="lineNum">     251</span> <span class="tlaGNC">         215 :   self = GST_TENSOR_FILTER (object);</span></span>
<span id="L252"><span class="lineNum">     252</span> <span class="tlaGNC">         215 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L253"><span class="lineNum">     253</span>              : </span>
<span id="L254"><span class="lineNum">     254</span> <span class="tlaGNC">         215 :   if (priv-&gt;prop.suspend != 0) {</span></span>
<span id="L255"><span class="lineNum">     255</span> <span class="tlaGNC">           1 :     GST_OBJECT_LOCK (self);</span></span>
<span id="L256"><span class="lineNum">     256</span> <span class="tlaGNC">           1 :     nnstreamer_watchdog_destroy (priv-&gt;watchdog_h);</span></span>
<span id="L257"><span class="lineNum">     257</span> <span class="tlaGNC">           1 :     priv-&gt;watchdog_h = NULL;</span></span>
<span id="L258"><span class="lineNum">     258</span> <span class="tlaGNC">           1 :     GST_OBJECT_UNLOCK (self);</span></span>
<span id="L259"><span class="lineNum">     259</span>              :   }</span>
<span id="L260"><span class="lineNum">     260</span>              : </span>
<span id="L261"><span class="lineNum">     261</span> <span class="tlaGNC">         215 :   gst_tensor_filter_common_close_fw (priv);</span></span>
<span id="L262"><span class="lineNum">     262</span> <span class="tlaGNC">         215 :   gst_tensor_filter_common_free_property (priv);</span></span>
<span id="L263"><span class="lineNum">     263</span>              : </span>
<span id="L264"><span class="lineNum">     264</span> <span class="tlaGNC">         215 :   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);</span></span>
<span id="L265"><span class="lineNum">     265</span> <span class="tlaGNC">         215 : }</span></span>
<span id="L266"><span class="lineNum">     266</span>              : </span>
<span id="L267"><span class="lineNum">     267</span>              : /**</span>
<span id="L268"><span class="lineNum">     268</span>              :  * @brief Calculate tensor buffer size.</span>
<span id="L269"><span class="lineNum">     269</span>              :  * @param self &quot;this&quot; pointer</span>
<span id="L270"><span class="lineNum">     270</span>              :  * @param index index of tensors</span>
<span id="L271"><span class="lineNum">     271</span>              :  * @return tensor buffer size</span>
<span id="L272"><span class="lineNum">     272</span>              :  */</span>
<span id="L273"><span class="lineNum">     273</span>              : static gsize</span>
<span id="L274"><span class="lineNum">     274</span> <span class="tlaGNC">       44965 : gst_tensor_filter_get_tensor_size (GstTensorFilter * self, guint index,</span></span>
<span id="L275"><span class="lineNum">     275</span>              :     gboolean is_input)</span>
<span id="L276"><span class="lineNum">     276</span>              : {</span>
<span id="L277"><span class="lineNum">     277</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L278"><span class="lineNum">     278</span>              :   GstTensorsInfo *info;</span>
<span id="L279"><span class="lineNum">     279</span>              : </span>
<span id="L280"><span class="lineNum">     280</span> <span class="tlaGNC">       44965 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L281"><span class="lineNum">     281</span> <span class="tlaGNC">       44965 :   if (is_input)</span></span>
<span id="L282"><span class="lineNum">     282</span> <span class="tlaGNC">       22528 :     info = &amp;priv-&gt;prop.input_meta;</span></span>
<span id="L283"><span class="lineNum">     283</span>              :   else</span>
<span id="L284"><span class="lineNum">     284</span> <span class="tlaGNC">       22437 :     info = &amp;priv-&gt;prop.output_meta;</span></span>
<span id="L285"><span class="lineNum">     285</span>              : </span>
<span id="L286"><span class="lineNum">     286</span>              :   /* Internal Logic Error: out of bound */</span>
<span id="L287"><span class="lineNum">     287</span> <span class="tlaGNC">       44965 :   if (index &gt;= info-&gt;num_tensors) {</span></span>
<span id="L288"><span class="lineNum">     288</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L289"><span class="lineNum">     289</span>              :         (&quot;tensor_filter's core has inconsistent data. Please report to https://github.com/nnstreamer/nnstreamer/issues . The index argument (%u) of tensors is greater-than or equal-to the number of tensors (%u)&quot;,</span>
<span id="L290"><span class="lineNum">     290</span>              :             index, info-&gt;num_tensors));</span>
<span id="L291"><span class="lineNum">     291</span> <span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L292"><span class="lineNum">     292</span>              :   }</span>
<span id="L293"><span class="lineNum">     293</span>              : </span>
<span id="L294"><span class="lineNum">     294</span> <span class="tlaGNC tlaBgGNC">       44965 :   return gst_tensor_info_get_size (gst_tensors_info_get_nth_info (info, index));</span></span>
<span id="L295"><span class="lineNum">     295</span>              : }</span>
<span id="L296"><span class="lineNum">     296</span>              : </span>
<span id="L297"><span class="lineNum">     297</span>              : /**</span>
<span id="L298"><span class="lineNum">     298</span>              :  * @brief Setter for tensor_filter properties.</span>
<span id="L299"><span class="lineNum">     299</span>              :  */</span>
<span id="L300"><span class="lineNum">     300</span>              : static void</span>
<span id="L301"><span class="lineNum">     301</span> <span class="tlaGNC">         741 : gst_tensor_filter_set_property (GObject * object, guint prop_id,</span></span>
<span id="L302"><span class="lineNum">     302</span>              :     const GValue * value, GParamSpec * pspec)</span>
<span id="L303"><span class="lineNum">     303</span>              : {</span>
<span id="L304"><span class="lineNum">     304</span>              :   GstTensorFilter *self;</span>
<span id="L305"><span class="lineNum">     305</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L306"><span class="lineNum">     306</span>              : </span>
<span id="L307"><span class="lineNum">     307</span> <span class="tlaGNC">         741 :   self = GST_TENSOR_FILTER (object);</span></span>
<span id="L308"><span class="lineNum">     308</span> <span class="tlaGNC">         741 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L309"><span class="lineNum">     309</span>              : </span>
<span id="L310"><span class="lineNum">     310</span> <span class="tlaGNC">         741 :   silent_debug (self, &quot;Setting property for prop %d.\n&quot;, prop_id);</span></span>
<span id="L311"><span class="lineNum">     311</span>              : </span>
<span id="L312"><span class="lineNum">     312</span> <span class="tlaGNC">         741 :   if (prop_id == PROP_CONFIG) {</span></span>
<span id="L313"><span class="lineNum">     313</span> <span class="tlaGNC">           4 :     g_free (priv-&gt;config_path);</span></span>
<span id="L314"><span class="lineNum">     314</span> <span class="tlaGNC">           4 :     priv-&gt;config_path = g_strdup (g_value_get_string (value));</span></span>
<span id="L315"><span class="lineNum">     315</span> <span class="tlaGNC">           4 :     gst_tensor_parse_config_file (priv-&gt;config_path, object);</span></span>
<span id="L316"><span class="lineNum">     316</span> <span class="tlaGNC">           4 :     return;</span></span>
<span id="L317"><span class="lineNum">     317</span>              :   }</span>
<span id="L318"><span class="lineNum">     318</span>              : </span>
<span id="L319"><span class="lineNum">     319</span> <span class="tlaGNC">         737 :   if (!gst_tensor_filter_common_set_property (priv, prop_id, value, pspec))</span></span>
<span id="L320"><span class="lineNum">     320</span> <span class="tlaUNC tlaBgUNC">           0 :     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);</span></span>
<span id="L321"><span class="lineNum">     321</span>              : }</span>
<span id="L322"><span class="lineNum">     322</span>              : </span>
<span id="L323"><span class="lineNum">     323</span>              : /**</span>
<span id="L324"><span class="lineNum">     324</span>              :  * @brief Getter for tensor_filter properties.</span>
<span id="L325"><span class="lineNum">     325</span>              :  */</span>
<span id="L326"><span class="lineNum">     326</span>              : static void</span>
<span id="L327"><span class="lineNum">     327</span> <span class="tlaGNC tlaBgGNC">          83 : gst_tensor_filter_get_property (GObject * object, guint prop_id,</span></span>
<span id="L328"><span class="lineNum">     328</span>              :     GValue * value, GParamSpec * pspec)</span>
<span id="L329"><span class="lineNum">     329</span>              : {</span>
<span id="L330"><span class="lineNum">     330</span>              :   GstTensorFilter *self;</span>
<span id="L331"><span class="lineNum">     331</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L332"><span class="lineNum">     332</span>              : </span>
<span id="L333"><span class="lineNum">     333</span> <span class="tlaGNC">          83 :   self = GST_TENSOR_FILTER (object);</span></span>
<span id="L334"><span class="lineNum">     334</span> <span class="tlaGNC">          83 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L335"><span class="lineNum">     335</span>              : </span>
<span id="L336"><span class="lineNum">     336</span> <span class="tlaGNC">          83 :   silent_debug (self, &quot;Getting property for prop %d.\n&quot;, prop_id);</span></span>
<span id="L337"><span class="lineNum">     337</span>              : </span>
<span id="L338"><span class="lineNum">     338</span> <span class="tlaGNC">          83 :   if (prop_id == PROP_CONFIG) {</span></span>
<span id="L339"><span class="lineNum">     339</span> <span class="tlaUNC tlaBgUNC">           0 :     g_value_set_string (value, priv-&gt;config_path ? priv-&gt;config_path : &quot;&quot;);</span></span>
<span id="L340"><span class="lineNum">     340</span> <span class="tlaUNC">           0 :     return;</span></span>
<span id="L341"><span class="lineNum">     341</span>              :   }</span>
<span id="L342"><span class="lineNum">     342</span>              : </span>
<span id="L343"><span class="lineNum">     343</span> <span class="tlaGNC tlaBgGNC">          83 :   if (!gst_tensor_filter_common_get_property (priv, prop_id, value, pspec))</span></span>
<span id="L344"><span class="lineNum">     344</span> <span class="tlaUNC tlaBgUNC">           0 :     G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);</span></span>
<span id="L345"><span class="lineNum">     345</span>              : }</span>
<span id="L346"><span class="lineNum">     346</span>              : </span>
<span id="L347"><span class="lineNum">     347</span>              : /**</span>
<span id="L348"><span class="lineNum">     348</span>              :  * @brief Free the data allocated for tensor transform</span>
<span id="L349"><span class="lineNum">     349</span>              :  * @details default function for tensor filter framework if not provided by the</span>
<span id="L350"><span class="lineNum">     350</span>              :  *          framework. The data is in GPtrArray - first element is private data</span>
<span id="L351"><span class="lineNum">     351</span>              :  *          of framework and second element is the data to be freed.</span>
<span id="L352"><span class="lineNum">     352</span>              :  */</span>
<span id="L353"><span class="lineNum">     353</span>              : static void</span>
<span id="L354"><span class="lineNum">     354</span> <span class="tlaGNC tlaBgGNC">          27 : gst_tensor_filter_destroy_notify (void *data)</span></span>
<span id="L355"><span class="lineNum">     355</span>              : {</span>
<span id="L356"><span class="lineNum">     356</span> <span class="tlaGNC">          27 :   GPtrArray *array = (GPtrArray *) data;</span></span>
<span id="L357"><span class="lineNum">     357</span> <span class="tlaGNC">          27 :   GstTensorFilter *self = (GstTensorFilter *) g_ptr_array_index (array, 0);</span></span>
<span id="L358"><span class="lineNum">     358</span> <span class="tlaGNC">          27 :   void *tensor_data = (void *) g_ptr_array_index (array, 1);</span></span>
<span id="L359"><span class="lineNum">     359</span> <span class="tlaGNC">          27 :   g_ptr_array_free (array, TRUE);</span></span>
<span id="L360"><span class="lineNum">     360</span>              : </span>
<span id="L361"><span class="lineNum">     361</span> <span class="tlaGNC">          27 :   gst_tensor_filter_destroy_notify_util (&amp;self-&gt;priv, tensor_data);</span></span>
<span id="L362"><span class="lineNum">     362</span> <span class="tlaGNC">          27 : }</span></span>
<span id="L363"><span class="lineNum">     363</span>              : </span>
<span id="L364"><span class="lineNum">     364</span>              : /**</span>
<span id="L365"><span class="lineNum">     365</span>              :  * @brief Allocate new memory block from given data.</span>
<span id="L366"><span class="lineNum">     366</span>              :  * @details tensor-filter should send event to sub-plugin when memory is freed.</span>
<span id="L367"><span class="lineNum">     367</span>              :  */</span>
<span id="L368"><span class="lineNum">     368</span>              : static GstMemory *</span>
<span id="L369"><span class="lineNum">     369</span> <span class="tlaGNC">          27 : gst_tensor_filter_get_wrapped_mem (GstTensorFilter * self, gpointer data,</span></span>
<span id="L370"><span class="lineNum">     370</span>              :     gsize size)</span>
<span id="L371"><span class="lineNum">     371</span>              : {</span>
<span id="L372"><span class="lineNum">     372</span> <span class="tlaGNC">          27 :   GPtrArray *data_array = g_ptr_array_new ();</span></span>
<span id="L373"><span class="lineNum">     373</span>              : </span>
<span id="L374"><span class="lineNum">     374</span> <span class="tlaGNC">          27 :   g_ptr_array_add (data_array, (gpointer) self);</span></span>
<span id="L375"><span class="lineNum">     375</span> <span class="tlaGNC">          27 :   g_ptr_array_add (data_array, (gpointer) data);</span></span>
<span id="L376"><span class="lineNum">     376</span>              : </span>
<span id="L377"><span class="lineNum">     377</span> <span class="tlaGNC">          27 :   return gst_memory_new_wrapped (0, data, size, 0, size, (gpointer) data_array,</span></span>
<span id="L378"><span class="lineNum">     378</span>              :       gst_tensor_filter_destroy_notify);</span>
<span id="L379"><span class="lineNum">     379</span>              : }</span>
<span id="L380"><span class="lineNum">     380</span>              : </span>
<span id="L381"><span class="lineNum">     381</span>              : /**</span>
<span id="L382"><span class="lineNum">     382</span>              :  * @brief Prepare statistics for performance profiling (e.g, latency, throughput)</span>
<span id="L383"><span class="lineNum">     383</span>              :  */</span>
<span id="L384"><span class="lineNum">     384</span>              : static void</span>
<span id="L385"><span class="lineNum">     385</span> <span class="tlaGNC">         160 : prepare_statistics (GstTensorFilterPrivate * priv)</span></span>
<span id="L386"><span class="lineNum">     386</span>              : {</span>
<span id="L387"><span class="lineNum">     387</span> <span class="tlaGNC">         160 :   priv-&gt;stat.latest_invoke_time = g_get_real_time ();</span></span>
<span id="L388"><span class="lineNum">     388</span> <span class="tlaGNC">         160 : }</span></span>
<span id="L389"><span class="lineNum">     389</span>              : </span>
<span id="L390"><span class="lineNum">     390</span>              : /**</span>
<span id="L391"><span class="lineNum">     391</span>              :  * @brief Helper function to accumulate latencies</span>
<span id="L392"><span class="lineNum">     392</span>              :  */</span>
<span id="L393"><span class="lineNum">     393</span>              : static void</span>
<span id="L394"><span class="lineNum">     394</span> <span class="tlaGNC">        1462 : accumulate_latency (void *data, void *user_data)</span></span>
<span id="L395"><span class="lineNum">     395</span>              : {</span>
<span id="L396"><span class="lineNum">     396</span> <span class="tlaGNC">        1462 :   gint64 *latency = data;</span></span>
<span id="L397"><span class="lineNum">     397</span> <span class="tlaGNC">        1462 :   gint64 *total_latency = user_data;</span></span>
<span id="L398"><span class="lineNum">     398</span>              : </span>
<span id="L399"><span class="lineNum">     399</span> <span class="tlaGNC">        1462 :   *total_latency += *latency;</span></span>
<span id="L400"><span class="lineNum">     400</span> <span class="tlaGNC">        1462 : }</span></span>
<span id="L401"><span class="lineNum">     401</span>              : </span>
<span id="L402"><span class="lineNum">     402</span>              : #define THRESHOLD_DROP_OLD  (2000)</span>
<span id="L403"><span class="lineNum">     403</span>              : #define THRESHOLD_CACHE_OLD (1000)</span>
<span id="L404"><span class="lineNum">     404</span>              : </span>
<span id="L405"><span class="lineNum">     405</span>              : /**</span>
<span id="L406"><span class="lineNum">     406</span>              :  * @brief Record statistics for performance profiling (e.g, latency, throughput)</span>
<span id="L407"><span class="lineNum">     407</span>              :  */</span>
<span id="L408"><span class="lineNum">     408</span>              : static void</span>
<span id="L409"><span class="lineNum">     409</span> <span class="tlaGNC">         160 : record_statistics (GstTensorFilterPrivate * priv)</span></span>
<span id="L410"><span class="lineNum">     410</span>              : {</span>
<span id="L411"><span class="lineNum">     411</span> <span class="tlaGNC">         160 :   gint64 end_time = g_get_real_time ();</span></span>
<span id="L412"><span class="lineNum">     412</span>              :   gint64 *latency;</span>
<span id="L413"><span class="lineNum">     413</span> <span class="tlaGNC">         160 :   GQueue *recent_latencies = priv-&gt;stat.recent_latencies;</span></span>
<span id="L414"><span class="lineNum">     414</span>              : </span>
<span id="L415"><span class="lineNum">     415</span>              :   /* ignore first measurements that may be off */</span>
<span id="L416"><span class="lineNum">     416</span> <span class="tlaGNC">         160 :   if (priv-&gt;stat.latency_ignore_count) {</span></span>
<span id="L417"><span class="lineNum">     417</span> <span class="tlaGNC">           3 :     priv-&gt;stat.latency_ignore_count--;</span></span>
<span id="L418"><span class="lineNum">     418</span> <span class="tlaGNC">           3 :     return;</span></span>
<span id="L419"><span class="lineNum">     419</span>              :   }</span>
<span id="L420"><span class="lineNum">     420</span>              : </span>
<span id="L421"><span class="lineNum">     421</span> <span class="tlaGNC">         157 :   latency = g_new (gint64, 1);</span></span>
<span id="L422"><span class="lineNum">     422</span> <span class="tlaGNC">         157 :   *latency = end_time - priv-&gt;stat.latest_invoke_time;</span></span>
<span id="L423"><span class="lineNum">     423</span> <span class="tlaGNC">         157 :   priv-&gt;stat.total_invoke_latency += *latency;</span></span>
<span id="L424"><span class="lineNum">     424</span> <span class="tlaGNC">         157 :   priv-&gt;stat.total_invoke_num += 1;</span></span>
<span id="L425"><span class="lineNum">     425</span>              : </span>
<span id="L426"><span class="lineNum">     426</span> <span class="tlaGNC">         157 :   if (g_queue_get_length (recent_latencies) == GST_TF_STAT_MAX_RECENT)</span></span>
<span id="L427"><span class="lineNum">     427</span> <span class="tlaGNC">         138 :     g_free (g_queue_pop_head (recent_latencies));</span></span>
<span id="L428"><span class="lineNum">     428</span> <span class="tlaGNC">         157 :   g_queue_push_tail (recent_latencies, latency);</span></span>
<span id="L429"><span class="lineNum">     429</span>              : </span>
<span id="L430"><span class="lineNum">     430</span>              :   /* the queue should have at least one element */</span>
<span id="L431"><span class="lineNum">     431</span> <span class="tlaGNC">         157 :   g_assert (g_queue_get_length (recent_latencies) != 0);</span></span>
<span id="L432"><span class="lineNum">     432</span>              : </span>
<span id="L433"><span class="lineNum">     433</span> <span class="tlaGNC">         157 :   if (priv-&gt;latency_mode &gt; 0 || priv-&gt;latency_reporting) {</span></span>
<span id="L434"><span class="lineNum">     434</span> <span class="tlaGNC">         157 :     gint64 avg_latency = 0;</span></span>
<span id="L435"><span class="lineNum">     435</span>              : </span>
<span id="L436"><span class="lineNum">     436</span> <span class="tlaGNC">         157 :     g_queue_foreach (recent_latencies, accumulate_latency, &amp;avg_latency);</span></span>
<span id="L437"><span class="lineNum">     437</span> <span class="tlaGNC">         157 :     avg_latency /= g_queue_get_length (recent_latencies);</span></span>
<span id="L438"><span class="lineNum">     438</span>              : </span>
<span id="L439"><span class="lineNum">     439</span>              :     /* check integer overflow */</span>
<span id="L440"><span class="lineNum">     440</span> <span class="tlaGNC">         157 :     if (avg_latency &lt;= INT32_MAX)</span></span>
<span id="L441"><span class="lineNum">     441</span> <span class="tlaGNC">         157 :       priv-&gt;prop.latency = (gint) avg_latency;</span></span>
<span id="L442"><span class="lineNum">     442</span>              :     else</span>
<span id="L443"><span class="lineNum">     443</span> <span class="tlaUNC tlaBgUNC">           0 :       priv-&gt;prop.latency = -1;</span></span>
<span id="L444"><span class="lineNum">     444</span>              : </span>
<span id="L445"><span class="lineNum">     445</span> <span class="tlaGNC tlaBgGNC">         157 :     ml_logi (&quot;[%s] Invoke took %.3f ms&quot;, TF_MODELNAME (&amp;(priv-&gt;prop)),</span></span>
<span id="L446"><span class="lineNum">     446</span>              :         (*latency) / 1000.0);</span>
<span id="L447"><span class="lineNum">     447</span>              :   }</span>
<span id="L448"><span class="lineNum">     448</span>              : </span>
<span id="L449"><span class="lineNum">     449</span> <span class="tlaGNC">         157 :   if (priv-&gt;throughput_mode &gt; 0) {</span></span>
<span id="L450"><span class="lineNum">     450</span> <span class="tlaGNC">           3 :     gint throughput_int = -1;</span></span>
<span id="L451"><span class="lineNum">     451</span>              : </span>
<span id="L452"><span class="lineNum">     452</span> <span class="tlaGNC">           3 :     if (priv-&gt;stat.total_invoke_latency != 0) {</span></span>
<span id="L453"><span class="lineNum">     453</span> <span class="tlaGNC">           3 :       gdouble throughput =</span></span>
<span id="L454"><span class="lineNum">     454</span> <span class="tlaGNC">           3 :           (gdouble) (priv-&gt;stat.total_invoke_num * G_USEC_PER_SEC * 1000) /</span></span>
<span id="L455"><span class="lineNum">     455</span> <span class="tlaGNC">           3 :           priv-&gt;stat.total_invoke_latency;</span></span>
<span id="L456"><span class="lineNum">     456</span>              : </span>
<span id="L457"><span class="lineNum">     457</span>              :       /* check integer overflow */</span>
<span id="L458"><span class="lineNum">     458</span> <span class="tlaGNC">           3 :       if (throughput &lt;= INT32_MAX)</span></span>
<span id="L459"><span class="lineNum">     459</span> <span class="tlaGNC">           3 :         throughput_int = (gint) throughput;</span></span>
<span id="L460"><span class="lineNum">     460</span>              :     }</span>
<span id="L461"><span class="lineNum">     461</span>              : </span>
<span id="L462"><span class="lineNum">     462</span>              :     /* note that it's a 1000x larger value than actual throughput */</span>
<span id="L463"><span class="lineNum">     463</span> <span class="tlaGNC">           3 :     priv-&gt;prop.throughput = throughput_int;</span></span>
<span id="L464"><span class="lineNum">     464</span>              : </span>
<span id="L465"><span class="lineNum">     465</span> <span class="tlaGNC">           3 :     ml_logi (&quot;[%s] Throughput: %.2f FPS&quot;, TF_MODELNAME (&amp;(priv-&gt;prop)),</span></span>
<span id="L466"><span class="lineNum">     466</span>              :         throughput_int / 1000.0);</span>
<span id="L467"><span class="lineNum">     467</span>              :   }</span>
<span id="L468"><span class="lineNum">     468</span>              : </span>
<span id="L469"><span class="lineNum">     469</span>              :   /**</span>
<span id="L470"><span class="lineNum">     470</span>              :    * statistics values are monotonously increasing.</span>
<span id="L471"><span class="lineNum">     471</span>              :    * to avoid potential overflow, let's cache old values and subtract them</span>
<span id="L472"><span class="lineNum">     472</span>              :    * from the statistics if some threshold is exceeded.</span>
<span id="L473"><span class="lineNum">     473</span>              :    */</span>
<span id="L474"><span class="lineNum">     474</span> <span class="tlaGNC">         157 :   if (priv-&gt;stat.total_invoke_num &gt; THRESHOLD_DROP_OLD) {</span></span>
<span id="L475"><span class="lineNum">     475</span> <span class="tlaUNC tlaBgUNC">           0 :     priv-&gt;stat.total_invoke_latency -= priv-&gt;stat.old_total_invoke_latency;</span></span>
<span id="L476"><span class="lineNum">     476</span> <span class="tlaUNC">           0 :     priv-&gt;stat.total_invoke_num -= priv-&gt;stat.old_total_invoke_num;</span></span>
<span id="L477"><span class="lineNum">     477</span>              :     /* drop cached values */</span>
<span id="L478"><span class="lineNum">     478</span> <span class="tlaUNC">           0 :     priv-&gt;stat.old_total_invoke_latency = 0;</span></span>
<span id="L479"><span class="lineNum">     479</span> <span class="tlaUNC">           0 :     priv-&gt;stat.old_total_invoke_num = 0;</span></span>
<span id="L480"><span class="lineNum">     480</span> <span class="tlaGNC tlaBgGNC">         157 :   } else if (priv-&gt;stat.total_invoke_num &gt; THRESHOLD_CACHE_OLD) {</span></span>
<span id="L481"><span class="lineNum">     481</span>              :     /* cache old values if they are not yet set */</span>
<span id="L482"><span class="lineNum">     482</span> <span class="tlaUNC tlaBgUNC">           0 :     if (priv-&gt;stat.old_total_invoke_num == 0) {</span></span>
<span id="L483"><span class="lineNum">     483</span> <span class="tlaUNC">           0 :       priv-&gt;stat.old_total_invoke_latency = priv-&gt;stat.total_invoke_latency;</span></span>
<span id="L484"><span class="lineNum">     484</span> <span class="tlaUNC">           0 :       priv-&gt;stat.old_total_invoke_num = priv-&gt;stat.total_invoke_num;</span></span>
<span id="L485"><span class="lineNum">     485</span>              :     }</span>
<span id="L486"><span class="lineNum">     486</span>              :   }</span>
<span id="L487"><span class="lineNum">     487</span>              : }</span>
<span id="L488"><span class="lineNum">     488</span>              : </span>
<span id="L489"><span class="lineNum">     489</span>              : /**</span>
<span id="L490"><span class="lineNum">     490</span>              :  * @brief Track estimated latency and notify pipeline when it changes.</span>
<span id="L491"><span class="lineNum">     491</span>              :  *        Latency estimates may be a bit jittery. On the principle we want to</span>
<span id="L492"><span class="lineNum">     492</span>              :  *        inform pipeline with the latency from longest inference.</span>
<span id="L493"><span class="lineNum">     493</span>              :  *        However, first inference may take much longer, or model filter</span>
<span id="L494"><span class="lineNum">     494</span>              :  *        configuration may change. Therefore any change of more than 10%</span>
<span id="L495"><span class="lineNum">     495</span>              :  *        (arbitrary value) to a lower latency is also reported to pipeline.</span>
<span id="L496"><span class="lineNum">     496</span>              :  *        Notification is done sending LATENCY message to bus. Upon receipt,</span>
<span id="L497"><span class="lineNum">     497</span>              :  *        application will initiate a pipeline latency probe via LATENCY query.</span>
<span id="L498"><span class="lineNum">     498</span>              :  */</span>
<span id="L499"><span class="lineNum">     499</span>              : static void</span>
<span id="L500"><span class="lineNum">     500</span> <span class="tlaGNC tlaBgGNC">         160 : track_latency (GstTensorFilter * self)</span></span>
<span id="L501"><span class="lineNum">     501</span>              : {</span>
<span id="L502"><span class="lineNum">     502</span> <span class="tlaGNC">         160 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L503"><span class="lineNum">     503</span>              :   gint64 estimated, reported;</span>
<span id="L504"><span class="lineNum">     504</span>              :   gdouble deviation;</span>
<span id="L505"><span class="lineNum">     505</span>              : </span>
<span id="L506"><span class="lineNum">     506</span> <span class="tlaGNC">         160 :   GST_OBJECT_LOCK (self);</span></span>
<span id="L507"><span class="lineNum">     507</span> <span class="tlaGNC">         160 :   estimated = priv-&gt;prop.latency * GST_USECOND;</span></span>
<span id="L508"><span class="lineNum">     508</span> <span class="tlaGNC">         160 :   reported = priv-&gt;latency_reported;</span></span>
<span id="L509"><span class="lineNum">     509</span> <span class="tlaGNC">         160 :   GST_OBJECT_UNLOCK (self);</span></span>
<span id="L510"><span class="lineNum">     510</span>              : </span>
<span id="L511"><span class="lineNum">     511</span> <span class="tlaGNC">         160 :   if ((priv-&gt;latency_reporting) &amp;&amp; (estimated &gt; 0)) {</span></span>
<span id="L512"><span class="lineNum">     512</span> <span class="tlaGNC">           6 :     if (reported &gt; 0)</span></span>
<span id="L513"><span class="lineNum">     513</span> <span class="tlaGNC">           1 :       deviation = (gdouble) ABS (estimated - reported) / reported;</span></span>
<span id="L514"><span class="lineNum">     514</span>              :     else</span>
<span id="L515"><span class="lineNum">     515</span> <span class="tlaGNC">           5 :       deviation = 0;</span></span>
<span id="L516"><span class="lineNum">     516</span>              : </span>
<span id="L517"><span class="lineNum">     517</span> <span class="tlaGNC">           6 :     if ((estimated &gt; reported) || (deviation &gt; LATENCY_REPORT_THRESHOLD)) {</span></span>
<span id="L518"><span class="lineNum">     518</span> <span class="tlaGNC">           5 :       ml_logd</span></span>
<span id="L519"><span class="lineNum">     519</span>              :           (&quot;[%s] latency reported:%&quot; G_GINT64_FORMAT &quot; estimated:%&quot;</span>
<span id="L520"><span class="lineNum">     520</span>              :           G_GINT64_FORMAT &quot; deviation:%.4f&quot;, TF_MODELNAME (&amp;(priv-&gt;prop)),</span>
<span id="L521"><span class="lineNum">     521</span>              :           reported, estimated, deviation);</span>
<span id="L522"><span class="lineNum">     522</span>              : </span>
<span id="L523"><span class="lineNum">     523</span> <span class="tlaGNC">           5 :       gst_element_post_message (GST_ELEMENT_CAST (self),</span></span>
<span id="L524"><span class="lineNum">     524</span>              :           gst_message_new_latency (GST_OBJECT_CAST (self)));</span>
<span id="L525"><span class="lineNum">     525</span>              :     }</span>
<span id="L526"><span class="lineNum">     526</span>              :   }</span>
<span id="L527"><span class="lineNum">     527</span> <span class="tlaGNC">         160 : }</span></span>
<span id="L528"><span class="lineNum">     528</span>              : </span>
<span id="L529"><span class="lineNum">     529</span>              : /**</span>
<span id="L530"><span class="lineNum">     530</span>              :  * @brief Check throttling delay and send qos overflow event to upstream elements</span>
<span id="L531"><span class="lineNum">     531</span>              :  */</span>
<span id="L532"><span class="lineNum">     532</span>              : static gboolean</span>
<span id="L533"><span class="lineNum">     533</span> <span class="tlaGNC">       22211 : gst_tensor_filter_check_throttling_delay (GstBaseTransform * trans,</span></span>
<span id="L534"><span class="lineNum">     534</span>              :     GstBuffer * inbuf)</span>
<span id="L535"><span class="lineNum">     535</span>              : {</span>
<span id="L536"><span class="lineNum">     536</span>              :   GstTensorFilter *self;</span>
<span id="L537"><span class="lineNum">     537</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L538"><span class="lineNum">     538</span>              : </span>
<span id="L539"><span class="lineNum">     539</span> <span class="tlaGNC">       22211 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L540"><span class="lineNum">     540</span> <span class="tlaGNC">       22211 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L541"><span class="lineNum">     541</span>              : </span>
<span id="L542"><span class="lineNum">     542</span> <span class="tlaGNC">       22211 :   GST_OBJECT_LOCK (trans);</span></span>
<span id="L543"><span class="lineNum">     543</span>              : </span>
<span id="L544"><span class="lineNum">     544</span> <span class="tlaGNC">       22211 :   if (self-&gt;throttling_delay != 0) {</span></span>
<span id="L545"><span class="lineNum">     545</span> <span class="tlaGNC">         297 :     GstClockTime curr_ts = GST_BUFFER_PTS (inbuf);</span></span>
<span id="L546"><span class="lineNum">     546</span> <span class="tlaGNC">         297 :     GstClockTime prev_ts = self-&gt;prev_ts;</span></span>
<span id="L547"><span class="lineNum">     547</span>              : </span>
<span id="L548"><span class="lineNum">     548</span> <span class="tlaGNC">         297 :     self-&gt;prev_ts = curr_ts;</span></span>
<span id="L549"><span class="lineNum">     549</span>              : </span>
<span id="L550"><span class="lineNum">     550</span> <span class="tlaGNC">         297 :     if (GST_CLOCK_TIME_IS_VALID (prev_ts)) {</span></span>
<span id="L551"><span class="lineNum">     551</span> <span class="tlaGNC">         296 :       GstClockTimeDiff diff = curr_ts - prev_ts;</span></span>
<span id="L552"><span class="lineNum">     552</span>              :       GstClockTimeDiff delay;</span>
<span id="L553"><span class="lineNum">     553</span>              : </span>
<span id="L554"><span class="lineNum">     554</span> <span class="tlaGNC">         296 :       self-&gt;throttling_accum += diff;</span></span>
<span id="L555"><span class="lineNum">     555</span>              : </span>
<span id="L556"><span class="lineNum">     556</span>              :       /* check whether the average latency is longer than throttling delay */</span>
<span id="L557"><span class="lineNum">     557</span> <span class="tlaGNC">         296 :       delay = MAX (priv-&gt;prop.latency * 1000, self-&gt;throttling_delay);</span></span>
<span id="L558"><span class="lineNum">     558</span>              : </span>
<span id="L559"><span class="lineNum">     559</span> <span class="tlaGNC">         296 :       if (self-&gt;throttling_accum &lt; delay) {</span></span>
<span id="L560"><span class="lineNum">     560</span> <span class="tlaGNC">         148 :         GstClockTimeDiff duration = GST_BUFFER_DURATION (inbuf);        /* original */</span></span>
<span id="L561"><span class="lineNum">     561</span> <span class="tlaGNC">         148 :         gdouble avg_rate = gst_guint64_to_gdouble (duration) /</span></span>
<span id="L562"><span class="lineNum">     562</span> <span class="tlaGNC">         148 :             gst_guint64_to_gdouble (delay);</span></span>
<span id="L563"><span class="lineNum">     563</span>              : </span>
<span id="L564"><span class="lineNum">     564</span>              :         /**</span>
<span id="L565"><span class="lineNum">     565</span>              :          * Send qos overflow event to upstream elements.</span>
<span id="L566"><span class="lineNum">     566</span>              :          * Upstream elements (e.g., tensor_src, tensor_converter) may handle this.</span>
<span id="L567"><span class="lineNum">     567</span>              :          */</span>
<span id="L568"><span class="lineNum">     568</span> <span class="tlaGNC">         148 :         GstPad *sinkpad = GST_BASE_TRANSFORM_SINK_PAD (&amp;self-&gt;element);</span></span>
<span id="L569"><span class="lineNum">     569</span> <span class="tlaGNC">         296 :         GstEvent *event = gst_event_new_qos (GST_QOS_TYPE_OVERFLOW,</span></span>
<span id="L570"><span class="lineNum">     570</span> <span class="tlaGNC">         148 :             avg_rate, (self-&gt;throttling_accum - delay), curr_ts);</span></span>
<span id="L571"><span class="lineNum">     571</span>              : </span>
<span id="L572"><span class="lineNum">     572</span> <span class="tlaGNC">         148 :         gst_pad_push_event (sinkpad, event);</span></span>
<span id="L573"><span class="lineNum">     573</span>              : </span>
<span id="L574"><span class="lineNum">     574</span> <span class="tlaGNC">         148 :         GST_OBJECT_UNLOCK (trans);</span></span>
<span id="L575"><span class="lineNum">     575</span> <span class="tlaGNC">         148 :         return TRUE;</span></span>
<span id="L576"><span class="lineNum">     576</span>              :       }</span>
<span id="L577"><span class="lineNum">     577</span>              : </span>
<span id="L578"><span class="lineNum">     578</span> <span class="tlaGNC">         148 :       self-&gt;throttling_accum = 0;</span></span>
<span id="L579"><span class="lineNum">     579</span>              :     }</span>
<span id="L580"><span class="lineNum">     580</span>              :   }</span>
<span id="L581"><span class="lineNum">     581</span>              : </span>
<span id="L582"><span class="lineNum">     582</span> <span class="tlaGNC">       22063 :   GST_OBJECT_UNLOCK (trans);</span></span>
<span id="L583"><span class="lineNum">     583</span> <span class="tlaGNC">       22063 :   return FALSE;</span></span>
<span id="L584"><span class="lineNum">     584</span>              : }</span>
<span id="L585"><span class="lineNum">     585</span>              : </span>
<span id="L586"><span class="lineNum">     586</span>              : /**</span>
<span id="L587"><span class="lineNum">     587</span>              :  * @brief Check input parameters for gst_tensor_filter_transform ();</span>
<span id="L588"><span class="lineNum">     588</span>              :  */</span>
<span id="L589"><span class="lineNum">     589</span>              : static GstFlowReturn</span>
<span id="L590"><span class="lineNum">     590</span> <span class="tlaGNC">       22211 : _gst_tensor_filter_transform_validate (GstBaseTransform * trans,</span></span>
<span id="L591"><span class="lineNum">     591</span>              :     GstBuffer * inbuf, GstBuffer * outbuf)</span>
<span id="L592"><span class="lineNum">     592</span>              : {</span>
<span id="L593"><span class="lineNum">     593</span> <span class="tlaGNC">       22211 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L594"><span class="lineNum">     594</span> <span class="tlaGNC">       22211 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L595"><span class="lineNum">     595</span> <span class="tlaGNC">       22211 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L596"><span class="lineNum">     596</span>              : </span>
<span id="L597"><span class="lineNum">     597</span> <span class="tlaGNC">       22211 :   if (G_UNLIKELY (!priv-&gt;configured)) {</span></span>
<span id="L598"><span class="lineNum">     598</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, TYPE_NOT_FOUND,</span></span>
<span id="L599"><span class="lineNum">     599</span>              :         (&quot;The tensor_filter instance is not configured (pad caps not negotiated). Property info (framework = '%s', framework_opened = %d, model[0] = '%s', num-models = %d, custom_properties = '%s'.&quot;,</span>
<span id="L600"><span class="lineNum">     600</span>              :             prop ? prop-&gt;fwname : &quot;property info is NULL.&quot;,</span>
<span id="L601"><span class="lineNum">     601</span>              :             prop ? prop-&gt;fw_opened : -1,</span>
<span id="L602"><span class="lineNum">     602</span>              :             prop ? TF_MODELNAME (prop) : &quot;property info is NULL.&quot;,</span>
<span id="L603"><span class="lineNum">     603</span>              :             prop ? prop-&gt;num_models : -1,</span>
<span id="L604"><span class="lineNum">     604</span>              :             prop ? prop-&gt;custom_properties : &quot;property info is NULL.&quot;));</span>
<span id="L605"><span class="lineNum">     605</span> <span class="tlaUNC">           0 :     return GST_FLOW_NOT_NEGOTIATED;</span></span>
<span id="L606"><span class="lineNum">     606</span>              :   }</span>
<span id="L607"><span class="lineNum">     607</span> <span class="tlaGNC tlaBgGNC">       22211 :   if (G_UNLIKELY (!priv-&gt;fw)) {</span></span>
<span id="L608"><span class="lineNum">     608</span>              :     /**</span>
<span id="L609"><span class="lineNum">     609</span>              :       * This is fatal; if framework is not configured until this stage,</span>
<span id="L610"><span class="lineNum">     610</span>              :       * it means that an extension is missing or not configured.</span>
<span id="L611"><span class="lineNum">     611</span>              :       * We need readable messages for non-developers</span>
<span id="L612"><span class="lineNum">     612</span>              :       */</span>
<span id="L613"><span class="lineNum">     613</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L614"><span class="lineNum">     614</span>              :         (&quot;Framework (filter subplugin) is not found or not configured: 'framework=%s'. Please check if the given framework name is correct and the given model path is consistent with the intended framework especially if 'framework=auto' is given. Please refer to the warning messages created when the framework property is set.&quot;,</span>
<span id="L615"><span class="lineNum">     615</span>              :             priv-&gt;prop.fwname));</span>
<span id="L616"><span class="lineNum">     616</span> <span class="tlaUNC">           0 :     ml_logf</span></span>
<span id="L617"><span class="lineNum">     617</span>              :         (&quot;\nA corresponding nnstreamer extension (tensor_filter subplugin) is not installed or the framework property of tensor_filter is incorrect: [%s] is not found.\n\n&quot;,</span>
<span id="L618"><span class="lineNum">     618</span>              :         prop-&gt;fwname);</span>
<span id="L619"><span class="lineNum">     619</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L620"><span class="lineNum">     620</span>              :   }</span>
<span id="L621"><span class="lineNum">     621</span> <span class="tlaGNC tlaBgGNC">       22211 :   if (G_UNLIKELY (!priv-&gt;fw-&gt;run_without_model) &amp;&amp;</span></span>
<span id="L622"><span class="lineNum">     622</span> <span class="tlaGNC">       22121 :       G_UNLIKELY (!(prop-&gt;model_files &amp;&amp;</span></span>
<span id="L623"><span class="lineNum">     623</span>              :               prop-&gt;num_models &gt; 0 &amp;&amp; prop-&gt;model_files[0]))) {</span>
<span id="L624"><span class="lineNum">     624</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L625"><span class="lineNum">     625</span>              :         (&quot;For the framework='%s', its model filepath is not provided and this framework requires a model file. Thus, we cannot proceed with tensor_filter for inferences. Please provide a valid model file path.&quot;,</span>
<span id="L626"><span class="lineNum">     626</span>              :             prop-&gt;fwname));</span>
<span id="L627"><span class="lineNum">     627</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L628"><span class="lineNum">     628</span>              :   }</span>
<span id="L629"><span class="lineNum">     629</span> <span class="tlaGNC tlaBgGNC">       22211 :   if ((GST_TF_FW_V0 (priv-&gt;fw) &amp;&amp; G_UNLIKELY (!priv-&gt;fw-&gt;invoke_NN)) ||</span></span>
<span id="L630"><span class="lineNum">     630</span> <span class="tlaGNC">       22211 :       (GST_TF_FW_V1 (priv-&gt;fw) &amp;&amp; G_UNLIKELY (!priv-&gt;fw-&gt;invoke))) {</span></span>
<span id="L631"><span class="lineNum">     631</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L632"><span class="lineNum">     632</span>              :         (&quot;The tensor-filter subplugin for the framework='%s' does not have its mandatory methods (or callback functions). It appears that your subplugin implementation of '%s' is not completed. There is no 'invoke_NN (v1)' or 'invoke (v2)' methods available.&quot;,</span>
<span id="L633"><span class="lineNum">     633</span>              :             prop-&gt;fwname, prop-&gt;fwname));</span>
<span id="L634"><span class="lineNum">     634</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L635"><span class="lineNum">     635</span>              :   }</span>
<span id="L636"><span class="lineNum">     636</span>              : </span>
<span id="L637"><span class="lineNum">     637</span> <span class="tlaGNC tlaBgGNC">       22211 :   silent_debug (self, &quot;Invoking %s with %s model\n&quot;, prop-&gt;fwname,</span></span>
<span id="L638"><span class="lineNum">     638</span>              :       GST_STR_NULL (prop-&gt;model_files[0]));</span>
<span id="L639"><span class="lineNum">     639</span>              : </span>
<span id="L640"><span class="lineNum">     640</span>              :   /* skip input data when throttling delay is set */</span>
<span id="L641"><span class="lineNum">     641</span> <span class="tlaGNC">       22211 :   if (gst_tensor_filter_check_throttling_delay (trans, inbuf))</span></span>
<span id="L642"><span class="lineNum">     642</span> <span class="tlaGNC">         148 :     return GST_BASE_TRANSFORM_FLOW_DROPPED;</span></span>
<span id="L643"><span class="lineNum">     643</span>              : </span>
<span id="L644"><span class="lineNum">     644</span> <span class="tlaGNC">       22063 :   if (!outbuf) {</span></span>
<span id="L645"><span class="lineNum">     645</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L646"><span class="lineNum">     646</span>              :         (&quot;The output buffer for the instance of tensor-filter subplugin (%s / %s) is null. Cannot proceed.&quot;,</span>
<span id="L647"><span class="lineNum">     647</span>              :             prop-&gt;fwname, TF_MODELNAME (prop)));</span>
<span id="L648"><span class="lineNum">     648</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L649"><span class="lineNum">     649</span>              :   }</span>
<span id="L650"><span class="lineNum">     650</span> <span class="tlaGNC tlaBgGNC">       22063 :   if (gst_buffer_get_size (outbuf) != 0) {</span></span>
<span id="L651"><span class="lineNum">     651</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, FAILED,</span></span>
<span id="L652"><span class="lineNum">     652</span>              :         (&quot;The output buffer for the instance of tensor-filter subplugin (%s / %s) already has a content (buffer size = %zu). It should be 0.&quot;,</span>
<span id="L653"><span class="lineNum">     653</span>              :             prop-&gt;fwname, TF_MODELNAME (prop), gst_buffer_get_size (outbuf)));</span>
<span id="L654"><span class="lineNum">     654</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L655"><span class="lineNum">     655</span>              :   }</span>
<span id="L656"><span class="lineNum">     656</span>              : </span>
<span id="L657"><span class="lineNum">     657</span> <span class="tlaGNC tlaBgGNC">       22063 :   return GST_FLOW_OK;</span></span>
<span id="L658"><span class="lineNum">     658</span>              : }</span>
<span id="L659"><span class="lineNum">     659</span>              : </span>
<span id="L660"><span class="lineNum">     660</span>              : /**</span>
<span id="L661"><span class="lineNum">     661</span>              :  * @brief Internal function to release mem and unmap info with index.</span>
<span id="L662"><span class="lineNum">     662</span>              :  */</span>
<span id="L663"><span class="lineNum">     663</span>              : static void</span>
<span id="L664"><span class="lineNum">     664</span> <span class="tlaGNC">           4 : _gst_tensor_filter_release_mem_until_idx (FilterTransformData * trans_data,</span></span>
<span id="L665"><span class="lineNum">     665</span>              :     guint end_index)</span>
<span id="L666"><span class="lineNum">     666</span>              : {</span>
<span id="L667"><span class="lineNum">     667</span>              :   guint i;</span>
<span id="L668"><span class="lineNum">     668</span>              : </span>
<span id="L669"><span class="lineNum">     669</span> <span class="tlaGNC">           9 :   for (i = 0; i &lt; end_index; i++) {</span></span>
<span id="L670"><span class="lineNum">     670</span> <span class="tlaGNC">           5 :     if (trans_data-&gt;mem[i]) {</span></span>
<span id="L671"><span class="lineNum">     671</span> <span class="tlaGNC">           4 :       gst_memory_unmap (trans_data-&gt;mem[i], &amp;trans_data-&gt;info[i]);</span></span>
<span id="L672"><span class="lineNum">     672</span> <span class="tlaGNC">           4 :       gst_memory_unref (trans_data-&gt;mem[i]);</span></span>
<span id="L673"><span class="lineNum">     673</span>              :     }</span>
<span id="L674"><span class="lineNum">     674</span>              :   }</span>
<span id="L675"><span class="lineNum">     675</span> <span class="tlaGNC">           4 : }</span></span>
<span id="L676"><span class="lineNum">     676</span>              : </span>
<span id="L677"><span class="lineNum">     677</span>              : /**</span>
<span id="L678"><span class="lineNum">     678</span>              :  * @brief Internal function to convert tensor meta and get header size of flexible tensor.</span>
<span id="L679"><span class="lineNum">     679</span>              :  */</span>
<span id="L680"><span class="lineNum">     680</span>              : static gsize</span>
<span id="L681"><span class="lineNum">     681</span> <span class="tlaGNC">       22531 : _gst_tensor_filter_convert_meta (FilterTransformData * trans_data,</span></span>
<span id="L682"><span class="lineNum">     682</span>              :     GstTensorsInfo * info, guint idx)</span>
<span id="L683"><span class="lineNum">     683</span>              : {</span>
<span id="L684"><span class="lineNum">     684</span> <span class="tlaGNC">       22531 :   gsize header_size = 0;</span></span>
<span id="L685"><span class="lineNum">     685</span>              :   GstTensorMetaInfo *_meta;</span>
<span id="L686"><span class="lineNum">     686</span>              :   GstTensorInfo *_info;</span>
<span id="L687"><span class="lineNum">     687</span>              : </span>
<span id="L688"><span class="lineNum">     688</span> <span class="tlaGNC">       22531 :   if (trans_data-&gt;is_flexible) {</span></span>
<span id="L689"><span class="lineNum">     689</span> <span class="tlaGNC">          31 :     _meta = &amp;trans_data-&gt;meta[idx];</span></span>
<span id="L690"><span class="lineNum">     690</span> <span class="tlaGNC">          31 :     _info = gst_tensors_info_get_nth_info (info, idx);</span></span>
<span id="L691"><span class="lineNum">     691</span>              : </span>
<span id="L692"><span class="lineNum">     692</span> <span class="tlaGNC">          31 :     gst_tensor_meta_info_parse_header (_meta, trans_data-&gt;info[idx].data);</span></span>
<span id="L693"><span class="lineNum">     693</span> <span class="tlaGNC">          31 :     header_size = gst_tensor_meta_info_get_header_size (_meta);</span></span>
<span id="L694"><span class="lineNum">     694</span> <span class="tlaGNC">          31 :     gst_tensor_meta_info_convert (_meta, _info);</span></span>
<span id="L695"><span class="lineNum">     695</span>              :   }</span>
<span id="L696"><span class="lineNum">     696</span>              : </span>
<span id="L697"><span class="lineNum">     697</span> <span class="tlaGNC">       22531 :   return header_size;</span></span>
<span id="L698"><span class="lineNum">     698</span>              : }</span>
<span id="L699"><span class="lineNum">     699</span>              : </span>
<span id="L700"><span class="lineNum">     700</span>              : /**</span>
<span id="L701"><span class="lineNum">     701</span>              :  * @brief Internal function to get input tensors.</span>
<span id="L702"><span class="lineNum">     702</span>              :  */</span>
<span id="L703"><span class="lineNum">     703</span>              : static FilterTransformData *</span>
<span id="L704"><span class="lineNum">     704</span> <span class="tlaGNC">       22063 : _gst_tensor_filter_transform_get_all_input_data (GstBaseTransform * trans,</span></span>
<span id="L705"><span class="lineNum">     705</span>              :     GstBuffer * buf)</span>
<span id="L706"><span class="lineNum">     706</span>              : {</span>
<span id="L707"><span class="lineNum">     707</span> <span class="tlaGNC">       22063 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L708"><span class="lineNum">     708</span> <span class="tlaGNC">       22063 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L709"><span class="lineNum">     709</span> <span class="tlaGNC">       22063 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L710"><span class="lineNum">     710</span>              :   guint i;</span>
<span id="L711"><span class="lineNum">     711</span>              :   gsize hsize;</span>
<span id="L712"><span class="lineNum">     712</span> <span class="tlaGNC">       22063 :   FilterTransformData *trans_data = NULL;</span></span>
<span id="L713"><span class="lineNum">     713</span>              : </span>
<span id="L714"><span class="lineNum">     714</span> <span class="tlaGNC">       22063 :   trans_data = g_new0 (FilterTransformData, 1);</span></span>
<span id="L715"><span class="lineNum">     715</span>              : </span>
<span id="L716"><span class="lineNum">     716</span> <span class="tlaGNC">       22063 :   if (!trans_data) {</span></span>
<span id="L717"><span class="lineNum">     717</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge</span></span>
<span id="L718"><span class="lineNum">     718</span>              :         (&quot;Failed to allocate memory for internal data of tensor filter transform input data.&quot;);</span>
<span id="L719"><span class="lineNum">     719</span> <span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L720"><span class="lineNum">     720</span>              :   }</span>
<span id="L721"><span class="lineNum">     721</span>              : </span>
<span id="L722"><span class="lineNum">     722</span> <span class="tlaGNC tlaBgGNC">       22063 :   trans_data-&gt;num_tensors = gst_tensor_buffer_get_count (buf);</span></span>
<span id="L723"><span class="lineNum">     723</span> <span class="tlaGNC">       22063 :   trans_data-&gt;is_flexible =</span></span>
<span id="L724"><span class="lineNum">     724</span> <span class="tlaGNC">       22063 :       gst_tensor_pad_caps_is_flexible (GST_BASE_TRANSFORM_SINK_PAD (trans));</span></span>
<span id="L725"><span class="lineNum">     725</span>              : </span>
<span id="L726"><span class="lineNum">     726</span> <span class="tlaGNC">       44594 :   for (i = 0; i &lt; trans_data-&gt;num_tensors; i++) {</span></span>
<span id="L727"><span class="lineNum">     727</span> <span class="tlaGNC">       22531 :     trans_data-&gt;mem[i] = gst_tensor_buffer_get_nth_memory (buf, i);</span></span>
<span id="L728"><span class="lineNum">     728</span> <span class="tlaGNC">       22531 :     if (!gst_memory_map (trans_data-&gt;mem[i], &amp;trans_data-&gt;info[i],</span></span>
<span id="L729"><span class="lineNum">     729</span>              :             GST_MAP_READ)) {</span>
<span id="L730"><span class="lineNum">     730</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_logf_stacktrace</span></span>
<span id="L731"><span class="lineNum">     731</span>              :           (&quot;gst_tensor_filter_transform: For the given input buffer, tensor-filter (%s : %s) cannot map input memory from the buffer for reading. The %u-th memory chunk (%u-th tensor) has failed for memory map.\n&quot;,</span>
<span id="L732"><span class="lineNum">     732</span>              :           prop-&gt;fwname, TF_MODELNAME (prop), i, i);</span>
<span id="L733"><span class="lineNum">     733</span> <span class="tlaUNC">           0 :       _gst_tensor_filter_release_mem_until_idx (trans_data, i);</span></span>
<span id="L734"><span class="lineNum">     734</span> <span class="tlaUNC">           0 :       g_free (trans_data);</span></span>
<span id="L735"><span class="lineNum">     735</span> <span class="tlaUNC">           0 :       return NULL;</span></span>
<span id="L736"><span class="lineNum">     736</span>              :     }</span>
<span id="L737"><span class="lineNum">     737</span>              : </span>
<span id="L738"><span class="lineNum">     738</span> <span class="tlaGNC tlaBgGNC">       22531 :     hsize = _gst_tensor_filter_convert_meta (trans_data, &amp;prop-&gt;input_meta, i);</span></span>
<span id="L739"><span class="lineNum">     739</span>              : </span>
<span id="L740"><span class="lineNum">     740</span> <span class="tlaGNC">       22531 :     trans_data-&gt;tensors[i].data = trans_data-&gt;info[i].data + hsize;</span></span>
<span id="L741"><span class="lineNum">     741</span> <span class="tlaGNC">       22531 :     trans_data-&gt;tensors[i].size = trans_data-&gt;info[i].size - hsize;</span></span>
<span id="L742"><span class="lineNum">     742</span>              :   }</span>
<span id="L743"><span class="lineNum">     743</span>              : </span>
<span id="L744"><span class="lineNum">     744</span> <span class="tlaGNC">       22063 :   return trans_data;</span></span>
<span id="L745"><span class="lineNum">     745</span>              : }</span>
<span id="L746"><span class="lineNum">     746</span>              : </span>
<span id="L747"><span class="lineNum">     747</span>              : /**</span>
<span id="L748"><span class="lineNum">     748</span>              :  * @brief Internal function to get invoke tensors.</span>
<span id="L749"><span class="lineNum">     749</span>              :  */</span>
<span id="L750"><span class="lineNum">     750</span>              : static GstTensorMemory *</span>
<span id="L751"><span class="lineNum">     751</span> <span class="tlaGNC">       22063 : _gst_tensor_filter_transform_get_invoke_tensors (GstBaseTransform * trans,</span></span>
<span id="L752"><span class="lineNum">     752</span>              :     FilterTransformData * trans_data)</span>
<span id="L753"><span class="lineNum">     753</span>              : {</span>
<span id="L754"><span class="lineNum">     754</span> <span class="tlaGNC">       22063 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L755"><span class="lineNum">     755</span> <span class="tlaGNC">       22063 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L756"><span class="lineNum">     756</span> <span class="tlaGNC">       22063 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L757"><span class="lineNum">     757</span>              :   guint i;</span>
<span id="L758"><span class="lineNum">     758</span>              :   gsize expected;</span>
<span id="L759"><span class="lineNum">     759</span> <span class="tlaGNC">       22063 :   GstTensorMemory *invoke_tensors = NULL;</span></span>
<span id="L760"><span class="lineNum">     760</span> <span class="tlaGNC">       22063 :   guint invoke_num_tensors = 0;</span></span>
<span id="L761"><span class="lineNum">     761</span>              : </span>
<span id="L762"><span class="lineNum">     762</span> <span class="tlaGNC">       22063 :   if (priv-&gt;combi.in_combi_defined) {</span></span>
<span id="L763"><span class="lineNum">     763</span> <span class="tlaGNC">           1 :     invoke_num_tensors = g_list_length (priv-&gt;combi.in_combi);</span></span>
<span id="L764"><span class="lineNum">     764</span>              :   } else {</span>
<span id="L765"><span class="lineNum">     765</span> <span class="tlaGNC">       22062 :     if (trans_data-&gt;num_tensors != prop-&gt;input_meta.num_tensors) {</span></span>
<span id="L766"><span class="lineNum">     766</span> <span class="tlaGNC">           1 :       ml_loge_stacktrace</span></span>
<span id="L767"><span class="lineNum">     767</span>              :           (&quot;gst_tensor_filter_transform: Input buffer has invalid number of memory blocks (%u), which is expected to be %u (the number of tensors). Maybe, the pad capability is not consistent with the actual input stream.\n&quot;,</span>
<span id="L768"><span class="lineNum">     768</span>              :           prop-&gt;input_meta.num_tensors, prop-&gt;input_meta.num_tensors);</span>
<span id="L769"><span class="lineNum">     769</span> <span class="tlaGNC">           1 :       return NULL;</span></span>
<span id="L770"><span class="lineNum">     770</span>              :     }</span>
<span id="L771"><span class="lineNum">     771</span> <span class="tlaGNC">       22061 :     invoke_num_tensors = trans_data-&gt;num_tensors;</span></span>
<span id="L772"><span class="lineNum">     772</span>              :   }</span>
<span id="L773"><span class="lineNum">     773</span>              : </span>
<span id="L774"><span class="lineNum">     774</span> <span class="tlaGNC">       22062 :   invoke_tensors = g_new0 (GstTensorMemory, invoke_num_tensors);</span></span>
<span id="L775"><span class="lineNum">     775</span>              : </span>
<span id="L776"><span class="lineNum">     776</span> <span class="tlaGNC">       22062 :   if (!invoke_tensors) {</span></span>
<span id="L777"><span class="lineNum">     777</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge</span></span>
<span id="L778"><span class="lineNum">     778</span>              :         (&quot;Failed to allocate memory for internal data of tensor filter transform invoke tensors. The number of invoke tensors: %u&quot;,</span>
<span id="L779"><span class="lineNum">     779</span>              :         invoke_num_tensors);</span>
<span id="L780"><span class="lineNum">     780</span> <span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L781"><span class="lineNum">     781</span>              :   }</span>
<span id="L782"><span class="lineNum">     782</span>              : </span>
<span id="L783"><span class="lineNum">     783</span>              :   /* Prepare tensors to invoke. */</span>
<span id="L784"><span class="lineNum">     784</span> <span class="tlaGNC tlaBgGNC">       22062 :   if (priv-&gt;combi.in_combi_defined) {</span></span>
<span id="L785"><span class="lineNum">     785</span>              :     GList *list;</span>
<span id="L786"><span class="lineNum">     786</span> <span class="tlaGNC">           1 :     guint info_idx = 0;</span></span>
<span id="L787"><span class="lineNum">     787</span>              : </span>
<span id="L788"><span class="lineNum">     788</span> <span class="tlaGNC">           2 :     for (list = priv-&gt;combi.in_combi; list != NULL; list = list-&gt;next) {</span></span>
<span id="L789"><span class="lineNum">     789</span> <span class="tlaGNC">           1 :       i = GPOINTER_TO_UINT (list-&gt;data);</span></span>
<span id="L790"><span class="lineNum">     790</span>              : </span>
<span id="L791"><span class="lineNum">     791</span> <span class="tlaGNC">           1 :       if (i &gt;= trans_data-&gt;num_tensors) {</span></span>
<span id="L792"><span class="lineNum">     792</span> <span class="tlaUNC tlaBgUNC">           0 :         ml_loge_stacktrace</span></span>
<span id="L793"><span class="lineNum">     793</span>              :             (&quot;gst_tensor_filter_transform: Invalid input combination ('input-combination' property) for the tensor-filter (%s:%s). The %u'th combination's index is %u, which is out of bound (&gt;= %u = the number of memory chunks (tensors) of incoming buffer). Because of buffer index inconsistency, it cannot continue (cannot map the memory for the input buffer).\n&quot;,</span>
<span id="L794"><span class="lineNum">     794</span>              :             prop-&gt;fwname, TF_MODELNAME (prop), info_idx, i,</span>
<span id="L795"><span class="lineNum">     795</span>              :             trans_data-&gt;num_tensors);</span>
<span id="L796"><span class="lineNum">     796</span> <span class="tlaUNC">           0 :         g_free (invoke_tensors);</span></span>
<span id="L797"><span class="lineNum">     797</span> <span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L798"><span class="lineNum">     798</span>              :       }</span>
<span id="L799"><span class="lineNum">     799</span>              : </span>
<span id="L800"><span class="lineNum">     800</span> <span class="tlaGNC tlaBgGNC">           1 :       expected = gst_tensor_filter_get_tensor_size (self, info_idx, TRUE);</span></span>
<span id="L801"><span class="lineNum">     801</span> <span class="tlaGNC">           1 :       if (expected != trans_data-&gt;tensors[i].size) {</span></span>
<span id="L802"><span class="lineNum">     802</span> <span class="tlaUNC tlaBgUNC">           0 :         ml_loge_stacktrace</span></span>
<span id="L803"><span class="lineNum">     803</span>              :             (&quot;gst_tensor_filter_transform: With the given input combination ('input-combination' property) of the tensor-filter, the incoming buffer size of combination index %u (%u'th combination) is %zd, which is invalid and is expected to be %zd. Because of buffer size inconsistency, it cannot continue (cannot map the memory for the input buffer).\n&quot;,</span>
<span id="L804"><span class="lineNum">     804</span>              :             i, info_idx, trans_data-&gt;tensors[i].size, expected);</span>
<span id="L805"><span class="lineNum">     805</span> <span class="tlaUNC">           0 :         g_free (invoke_tensors);</span></span>
<span id="L806"><span class="lineNum">     806</span> <span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L807"><span class="lineNum">     807</span>              :       }</span>
<span id="L808"><span class="lineNum">     808</span>              : </span>
<span id="L809"><span class="lineNum">     809</span> <span class="tlaGNC tlaBgGNC">           1 :       invoke_tensors[info_idx++] = trans_data-&gt;tensors[i];</span></span>
<span id="L810"><span class="lineNum">     810</span>              :     }</span>
<span id="L811"><span class="lineNum">     811</span>              :   } else {</span>
<span id="L812"><span class="lineNum">     812</span> <span class="tlaGNC">       44587 :     for (i = 0; i &lt; prop-&gt;input_meta.num_tensors; i++) {</span></span>
<span id="L813"><span class="lineNum">     813</span> <span class="tlaGNC">       22527 :       expected = gst_tensor_filter_get_tensor_size (self, i, TRUE);</span></span>
<span id="L814"><span class="lineNum">     814</span> <span class="tlaGNC">       22527 :       if (expected != trans_data-&gt;tensors[i].size) {</span></span>
<span id="L815"><span class="lineNum">     815</span> <span class="tlaGNC">           1 :         ml_loge_stacktrace</span></span>
<span id="L816"><span class="lineNum">     816</span>              :             (&quot;gst_tensor_filter_transform: Input buffer size (%u'th memory chunk: %zd) is invalid, which is expected to be %zd, which is the frame size of the corresponding tensor. Maybe, the pad capability is not consistent with the actual input stream; if the size is supposed to change dynamically and the given neural network, framework, and the subpluigins can handle it, please consider using format=flexible.\n&quot;,</span>
<span id="L817"><span class="lineNum">     817</span>              :             i, trans_data-&gt;tensors[i].size, expected);</span>
<span id="L818"><span class="lineNum">     818</span> <span class="tlaGNC">           1 :         g_free (invoke_tensors);</span></span>
<span id="L819"><span class="lineNum">     819</span> <span class="tlaGNC">           1 :         return NULL;</span></span>
<span id="L820"><span class="lineNum">     820</span>              :       }</span>
<span id="L821"><span class="lineNum">     821</span>              : </span>
<span id="L822"><span class="lineNum">     822</span> <span class="tlaGNC">       22526 :       invoke_tensors[i] = trans_data-&gt;tensors[i];</span></span>
<span id="L823"><span class="lineNum">     823</span>              :     }</span>
<span id="L824"><span class="lineNum">     824</span>              :   }</span>
<span id="L825"><span class="lineNum">     825</span>              : </span>
<span id="L826"><span class="lineNum">     826</span> <span class="tlaGNC">       22061 :   return invoke_tensors;</span></span>
<span id="L827"><span class="lineNum">     827</span>              : }</span>
<span id="L828"><span class="lineNum">     828</span>              : </span>
<span id="L829"><span class="lineNum">     829</span>              : /**</span>
<span id="L830"><span class="lineNum">     830</span>              :  * @brief Internal function to get output tensors.</span>
<span id="L831"><span class="lineNum">     831</span>              :  */</span>
<span id="L832"><span class="lineNum">     832</span>              : static FilterTransformData *</span>
<span id="L833"><span class="lineNum">     833</span> <span class="tlaGNC">       22061 : _gst_tensor_filter_transform_get_output_data (GstBaseTransform * trans)</span></span>
<span id="L834"><span class="lineNum">     834</span>              : {</span>
<span id="L835"><span class="lineNum">     835</span> <span class="tlaGNC">       22061 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L836"><span class="lineNum">     836</span> <span class="tlaGNC">       22061 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L837"><span class="lineNum">     837</span> <span class="tlaGNC">       22061 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L838"><span class="lineNum">     838</span> <span class="tlaGNC">       22061 :   FilterTransformData *trans_data = NULL;</span></span>
<span id="L839"><span class="lineNum">     839</span>              : </span>
<span id="L840"><span class="lineNum">     840</span> <span class="tlaGNC">       22061 :   trans_data = g_new0 (FilterTransformData, 1);</span></span>
<span id="L841"><span class="lineNum">     841</span>              : </span>
<span id="L842"><span class="lineNum">     842</span> <span class="tlaGNC">       22061 :   if (!trans_data) {</span></span>
<span id="L843"><span class="lineNum">     843</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge</span></span>
<span id="L844"><span class="lineNum">     844</span>              :         (&quot;Failed to allocate memory for internal data of tensor filter transform output data.&quot;);</span>
<span id="L845"><span class="lineNum">     845</span> <span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L846"><span class="lineNum">     846</span>              :   }</span>
<span id="L847"><span class="lineNum">     847</span>              : </span>
<span id="L848"><span class="lineNum">     848</span> <span class="tlaGNC tlaBgGNC">       22061 :   trans_data-&gt;num_tensors = prop-&gt;output_meta.num_tensors;</span></span>
<span id="L849"><span class="lineNum">     849</span> <span class="tlaGNC">       22061 :   trans_data-&gt;allocate_in_invoke = gst_tensor_filter_allocate_in_invoke (priv);</span></span>
<span id="L850"><span class="lineNum">     850</span> <span class="tlaGNC">       22061 :   trans_data-&gt;is_flexible =</span></span>
<span id="L851"><span class="lineNum">     851</span> <span class="tlaGNC">       22061 :       gst_tensor_pad_caps_is_flexible (GST_BASE_TRANSFORM_SRC_PAD (trans));</span></span>
<span id="L852"><span class="lineNum">     852</span>              : </span>
<span id="L853"><span class="lineNum">     853</span> <span class="tlaGNC">       22061 :   if (prop-&gt;invoke_dynamic &amp;&amp; !trans_data-&gt;is_flexible) {</span></span>
<span id="L854"><span class="lineNum">     854</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge</span></span>
<span id="L855"><span class="lineNum">     855</span>              :         (&quot;Dynamic Invoke of tensor filter is activated but the output of tensor filter is static tensors. Currently, only flexible tensors is supported as output of dynamic invoke. If you don't want to dynamic invoke, remove the invoke-dynamic option of tensor filter.&quot;);</span>
<span id="L856"><span class="lineNum">     856</span> <span class="tlaUNC">           0 :     g_free (trans_data);</span></span>
<span id="L857"><span class="lineNum">     857</span> <span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L858"><span class="lineNum">     858</span>              :   }</span>
<span id="L859"><span class="lineNum">     859</span>              : </span>
<span id="L860"><span class="lineNum">     860</span> <span class="tlaGNC tlaBgGNC">       22061 :   return trans_data;</span></span>
<span id="L861"><span class="lineNum">     861</span>              : }</span>
<span id="L862"><span class="lineNum">     862</span>              : </span>
<span id="L863"><span class="lineNum">     863</span>              : /**</span>
<span id="L864"><span class="lineNum">     864</span>              :  * @brief Internal function to get output tensors.</span>
<span id="L865"><span class="lineNum">     865</span>              :  */</span>
<span id="L866"><span class="lineNum">     866</span>              : static GstFlowReturn</span>
<span id="L867"><span class="lineNum">     867</span> <span class="tlaGNC">       22061 : _gst_tensor_filter_transform_prepare_output_tensors (GstBaseTransform * trans,</span></span>
<span id="L868"><span class="lineNum">     868</span>              :     FilterTransformData * trans_data)</span>
<span id="L869"><span class="lineNum">     869</span>              : {</span>
<span id="L870"><span class="lineNum">     870</span> <span class="tlaGNC">       22061 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L871"><span class="lineNum">     871</span> <span class="tlaGNC">       22061 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L872"><span class="lineNum">     872</span> <span class="tlaGNC">       22061 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L873"><span class="lineNum">     873</span>              :   GstTensorInfo *_info;</span>
<span id="L874"><span class="lineNum">     874</span>              :   guint i;</span>
<span id="L875"><span class="lineNum">     875</span>              :   gsize hsize;</span>
<span id="L876"><span class="lineNum">     876</span>              : </span>
<span id="L877"><span class="lineNum">     877</span> <span class="tlaGNC">       44497 :   for (i = 0; i &lt; prop-&gt;output_meta.num_tensors; i++) {</span></span>
<span id="L878"><span class="lineNum">     878</span> <span class="tlaGNC">       22437 :     trans_data-&gt;tensors[i].data = NULL;</span></span>
<span id="L879"><span class="lineNum">     879</span> <span class="tlaGNC">       22437 :     trans_data-&gt;tensors[i].size =</span></span>
<span id="L880"><span class="lineNum">     880</span> <span class="tlaGNC">       22437 :         gst_tensor_filter_get_tensor_size (self, i, FALSE);</span></span>
<span id="L881"><span class="lineNum">     881</span>              : </span>
<span id="L882"><span class="lineNum">     882</span> <span class="tlaGNC">       22437 :     hsize = 0;</span></span>
<span id="L883"><span class="lineNum">     883</span> <span class="tlaGNC">       22437 :     if (trans_data-&gt;is_flexible &amp;&amp; !prop-&gt;invoke_dynamic) {</span></span>
<span id="L884"><span class="lineNum">     884</span> <span class="tlaGNC">           2 :       _info = gst_tensors_info_get_nth_info (&amp;prop-&gt;output_meta, i);</span></span>
<span id="L885"><span class="lineNum">     885</span> <span class="tlaGNC">           2 :       if (!gst_tensor_info_convert_to_meta (_info, &amp;trans_data-&gt;meta[i])) {</span></span>
<span id="L886"><span class="lineNum">     886</span> <span class="tlaGNC">           1 :         ml_loge_stacktrace</span></span>
<span id="L887"><span class="lineNum">     887</span>              :             (&quot;gst_tensor_filter_transform: The configured output tensor information is invalid, at %u'th output tensor\n&quot;,</span>
<span id="L888"><span class="lineNum">     888</span>              :             i);</span>
<span id="L889"><span class="lineNum">     889</span> <span class="tlaGNC">           1 :         return GST_FLOW_ERROR;</span></span>
<span id="L890"><span class="lineNum">     890</span>              :       }</span>
<span id="L891"><span class="lineNum">     891</span> <span class="tlaGNC">           1 :       hsize = gst_tensor_meta_info_get_header_size (&amp;trans_data-&gt;meta[i]);</span></span>
<span id="L892"><span class="lineNum">     892</span>              :     }</span>
<span id="L893"><span class="lineNum">     893</span>              : </span>
<span id="L894"><span class="lineNum">     894</span>              :     /* allocate memory if allocate_in_invoke is FALSE */</span>
<span id="L895"><span class="lineNum">     895</span> <span class="tlaGNC">       22436 :     if (!trans_data-&gt;allocate_in_invoke) {</span></span>
<span id="L896"><span class="lineNum">     896</span> <span class="tlaGNC">       22393 :       trans_data-&gt;mem[i] =</span></span>
<span id="L897"><span class="lineNum">     897</span> <span class="tlaGNC">       22393 :           gst_allocator_alloc (NULL, trans_data-&gt;tensors[i].size + hsize, NULL);</span></span>
<span id="L898"><span class="lineNum">     898</span> <span class="tlaGNC">       22393 :       if (!trans_data-&gt;mem[i]) {</span></span>
<span id="L899"><span class="lineNum">     899</span> <span class="tlaUNC tlaBgUNC">           0 :         ml_loge_stacktrace</span></span>
<span id="L900"><span class="lineNum">     900</span>              :             (&quot;gst_tensor_filter_transform: cannot allocate memory for the output buffer (%u'th memory chunk for %u'th tensor), which requires %zd bytes. gst_allocate_alloc has returned Null. Out of memory?&quot;,</span>
<span id="L901"><span class="lineNum">     901</span>              :             i, i, trans_data-&gt;tensors[i].size + hsize);</span>
<span id="L902"><span class="lineNum">     902</span> <span class="tlaUNC">           0 :         return GST_FLOW_ERROR;</span></span>
<span id="L903"><span class="lineNum">     903</span>              :       }</span>
<span id="L904"><span class="lineNum">     904</span> <span class="tlaGNC tlaBgGNC">       22393 :       if (!gst_memory_map (trans_data-&gt;mem[i], &amp;trans_data-&gt;info[i],</span></span>
<span id="L905"><span class="lineNum">     905</span>              :               GST_MAP_WRITE)) {</span>
<span id="L906"><span class="lineNum">     906</span> <span class="tlaUNC tlaBgUNC">           0 :         ml_loge_stacktrace</span></span>
<span id="L907"><span class="lineNum">     907</span>              :             (&quot;gst_tensor_filter_transform: For the given output buffer, allocated by gst_tensor_filter_transform, it cannot map output memory buffer for the %u'th memory chunk (%u'th output tensor) for write.\n&quot;,</span>
<span id="L908"><span class="lineNum">     908</span>              :             i, i);</span>
<span id="L909"><span class="lineNum">     909</span> <span class="tlaUNC">           0 :         return GST_FLOW_ERROR;</span></span>
<span id="L910"><span class="lineNum">     910</span>              :       }</span>
<span id="L911"><span class="lineNum">     911</span>              : </span>
<span id="L912"><span class="lineNum">     912</span> <span class="tlaGNC tlaBgGNC">       22393 :       trans_data-&gt;tensors[i].data = trans_data-&gt;info[i].data + hsize;</span></span>
<span id="L913"><span class="lineNum">     913</span>              : </span>
<span id="L914"><span class="lineNum">     914</span>              :       /* append header */</span>
<span id="L915"><span class="lineNum">     915</span> <span class="tlaGNC">       22393 :       if (trans_data-&gt;is_flexible) {</span></span>
<span id="L916"><span class="lineNum">     916</span> <span class="tlaGNC">           1 :         if (FALSE == gst_tensor_meta_info_update_header</span></span>
<span id="L917"><span class="lineNum">     917</span> <span class="tlaGNC">           1 :             (&amp;trans_data-&gt;meta[i], trans_data-&gt;info[i].data)) {</span></span>
<span id="L918"><span class="lineNum">     918</span> <span class="tlaUNC tlaBgUNC">           0 :           ml_loge_stacktrace</span></span>
<span id="L919"><span class="lineNum">     919</span>              :               (&quot;gst_tensor_meta_info_update_header() has failed to update header for flexible format: invalid metadata or buffer for header is not available. This looks like an internal error of nnstreamer/tensor_filter. Please report to github.com/nnstreamer/nnstreamer/issues. %u'th output buffer has failed to update its header.\n&quot;,</span>
<span id="L920"><span class="lineNum">     920</span>              :               i);</span>
<span id="L921"><span class="lineNum">     921</span> <span class="tlaUNC">           0 :           return GST_FLOW_ERROR;</span></span>
<span id="L922"><span class="lineNum">     922</span>              :         }</span>
<span id="L923"><span class="lineNum">     923</span>              :       }</span>
<span id="L924"><span class="lineNum">     924</span>              :     }</span>
<span id="L925"><span class="lineNum">     925</span>              :   }</span>
<span id="L926"><span class="lineNum">     926</span> <span class="tlaGNC tlaBgGNC">       22060 :   return GST_FLOW_OK;</span></span>
<span id="L927"><span class="lineNum">     927</span>              : }</span>
<span id="L928"><span class="lineNum">     928</span>              : </span>
<span id="L929"><span class="lineNum">     929</span>              : /**</span>
<span id="L930"><span class="lineNum">     930</span>              :  * @brief Internal function to check the invoke result.</span>
<span id="L931"><span class="lineNum">     931</span>              :  */</span>
<span id="L932"><span class="lineNum">     932</span>              : static GstFlowReturn</span>
<span id="L933"><span class="lineNum">     933</span> <span class="tlaGNC">       22060 : _gst_tensor_filter_transform_check_invoke_result (GstBaseTransform * trans,</span></span>
<span id="L934"><span class="lineNum">     934</span>              :     FilterTransformData * in_trans_data, FilterTransformData * out_trans_data,</span>
<span id="L935"><span class="lineNum">     935</span>              :     gint invoke_res)</span>
<span id="L936"><span class="lineNum">     936</span>              : {</span>
<span id="L937"><span class="lineNum">     937</span> <span class="tlaGNC">       22060 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L938"><span class="lineNum">     938</span> <span class="tlaGNC">       22060 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L939"><span class="lineNum">     939</span> <span class="tlaGNC">       22060 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L940"><span class="lineNum">     940</span>              :   guint i;</span>
<span id="L941"><span class="lineNum">     941</span>              : </span>
<span id="L942"><span class="lineNum">     942</span> <span class="tlaGNC">       44587 :   for (i = 0; i &lt; in_trans_data-&gt;num_tensors; i++) {</span></span>
<span id="L943"><span class="lineNum">     943</span> <span class="tlaGNC">       22527 :     gst_memory_unmap (in_trans_data-&gt;mem[i], &amp;in_trans_data-&gt;info[i]);</span></span>
<span id="L944"><span class="lineNum">     944</span> <span class="tlaGNC">       22527 :     if (invoke_res != 0)</span></span>
<span id="L945"><span class="lineNum">     945</span> <span class="tlaGNC">          20 :       gst_memory_unref (in_trans_data-&gt;mem[i]);</span></span>
<span id="L946"><span class="lineNum">     946</span>              :   }</span>
<span id="L947"><span class="lineNum">     947</span>              : </span>
<span id="L948"><span class="lineNum">     948</span> <span class="tlaGNC">       22060 :   if (!out_trans_data-&gt;allocate_in_invoke) {</span></span>
<span id="L949"><span class="lineNum">     949</span> <span class="tlaGNC">       44408 :     for (i = 0; i &lt; prop-&gt;output_meta.num_tensors; i++) {</span></span>
<span id="L950"><span class="lineNum">     950</span> <span class="tlaGNC">       22393 :       gst_memory_unmap (out_trans_data-&gt;mem[i], &amp;out_trans_data-&gt;info[i]);</span></span>
<span id="L951"><span class="lineNum">     951</span> <span class="tlaGNC">       22393 :       if (invoke_res != 0)</span></span>
<span id="L952"><span class="lineNum">     952</span> <span class="tlaGNC">          20 :         gst_memory_unref (out_trans_data-&gt;mem[i]);</span></span>
<span id="L953"><span class="lineNum">     953</span>              :     }</span>
<span id="L954"><span class="lineNum">     954</span>              :   }</span>
<span id="L955"><span class="lineNum">     955</span>              : </span>
<span id="L956"><span class="lineNum">     956</span> <span class="tlaGNC">       22060 :   if (invoke_res &lt; 0) {</span></span>
<span id="L957"><span class="lineNum">     957</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge_stacktrace</span></span>
<span id="L958"><span class="lineNum">     958</span>              :         (&quot;Calling invoke function (inference instance) of the tensor-filter subplugin (%s for %s) has failed with error code (%d).\n&quot;,</span>
<span id="L959"><span class="lineNum">     959</span>              :         prop-&gt;fwname, TF_MODELNAME (prop), invoke_res);</span>
<span id="L960"><span class="lineNum">     960</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L961"><span class="lineNum">     961</span> <span class="tlaGNC tlaBgGNC">       22060 :   } else if (invoke_res &gt; 0) {</span></span>
<span id="L962"><span class="lineNum">     962</span>              :     /* drop this buffer */</span>
<span id="L963"><span class="lineNum">     963</span> <span class="tlaGNC">          20 :     return GST_BASE_TRANSFORM_FLOW_DROPPED;</span></span>
<span id="L964"><span class="lineNum">     964</span>              :   }</span>
<span id="L965"><span class="lineNum">     965</span>              : </span>
<span id="L966"><span class="lineNum">     966</span> <span class="tlaGNC">       22040 :   return GST_FLOW_OK;</span></span>
<span id="L967"><span class="lineNum">     967</span>              : }</span>
<span id="L968"><span class="lineNum">     968</span>              : </span>
<span id="L969"><span class="lineNum">     969</span>              : /**</span>
<span id="L970"><span class="lineNum">     970</span>              :  * @brief Internal function to make output buffer.</span>
<span id="L971"><span class="lineNum">     971</span>              :  */</span>
<span id="L972"><span class="lineNum">     972</span>              : static void</span>
<span id="L973"><span class="lineNum">     973</span> <span class="tlaGNC">       22040 : _gst_tensor_filter_transform_update_outbuf (GstBaseTransform * trans,</span></span>
<span id="L974"><span class="lineNum">     974</span>              :     FilterTransformData * in_trans_data, FilterTransformData * out_trans_data,</span>
<span id="L975"><span class="lineNum">     975</span>              :     GstBuffer * outbuf)</span>
<span id="L976"><span class="lineNum">     976</span>              : {</span>
<span id="L977"><span class="lineNum">     977</span> <span class="tlaGNC">       22040 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L978"><span class="lineNum">     978</span> <span class="tlaGNC">       22040 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L979"><span class="lineNum">     979</span> <span class="tlaGNC">       22040 :   GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L980"><span class="lineNum">     980</span>              :   GstMemory *mem;</span>
<span id="L981"><span class="lineNum">     981</span>              :   guint i;</span>
<span id="L982"><span class="lineNum">     982</span>              :   GList *list;</span>
<span id="L983"><span class="lineNum">     983</span>              :   GstTensorInfo *_info;</span>
<span id="L984"><span class="lineNum">     984</span>              :   gsize hsize;</span>
<span id="L985"><span class="lineNum">     985</span>              : </span>
<span id="L986"><span class="lineNum">     986</span> <span class="tlaGNC">       22040 :   if (in_trans_data) {</span></span>
<span id="L987"><span class="lineNum">     987</span>              :     /* If output combination is defined, append input tensors first */</span>
<span id="L988"><span class="lineNum">     988</span> <span class="tlaGNC">       22040 :     if (priv-&gt;combi.out_combi_i_defined) {</span></span>
<span id="L989"><span class="lineNum">     989</span> <span class="tlaGNC">           2 :       for (list = priv-&gt;combi.out_combi_i; list != NULL; list = list-&gt;next) {</span></span>
<span id="L990"><span class="lineNum">     990</span>              :         GstTensorInfo combi_info;</span>
<span id="L991"><span class="lineNum">     991</span> <span class="tlaGNC">           1 :         i = GPOINTER_TO_UINT (list-&gt;data);</span></span>
<span id="L992"><span class="lineNum">     992</span>              : </span>
<span id="L993"><span class="lineNum">     993</span> <span class="tlaGNC">           1 :         gst_tensor_info_init (&amp;combi_info);</span></span>
<span id="L994"><span class="lineNum">     994</span> <span class="tlaGNC">           1 :         _info = gst_tensors_info_get_nth_info (&amp;priv-&gt;in_config.info, i);</span></span>
<span id="L995"><span class="lineNum">     995</span>              : </span>
<span id="L996"><span class="lineNum">     996</span> <span class="tlaGNC">           1 :         if (!in_trans_data-&gt;is_flexible &amp;&amp; out_trans_data-&gt;is_flexible) {</span></span>
<span id="L997"><span class="lineNum">     997</span>              :           /* append header */</span>
<span id="L998"><span class="lineNum">     998</span> <span class="tlaUNC tlaBgUNC">           0 :           gst_tensor_info_convert_to_meta (_info, &amp;in_trans_data-&gt;meta[i]);</span></span>
<span id="L999"><span class="lineNum">     999</span> <span class="tlaUNC">           0 :           mem =</span></span>
<span id="L1000"><span class="lineNum">    1000</span> <span class="tlaUNC">           0 :               gst_tensor_meta_info_append_header (&amp;in_trans_data-&gt;meta[i],</span></span>
<span id="L1001"><span class="lineNum">    1001</span>              :               in_trans_data-&gt;mem[i]);</span>
<span id="L1002"><span class="lineNum">    1002</span> <span class="tlaGNC tlaBgGNC">           1 :         } else if (in_trans_data-&gt;is_flexible &amp;&amp; !out_trans_data-&gt;is_flexible) {</span></span>
<span id="L1003"><span class="lineNum">    1003</span>              :           /* remove header */</span>
<span id="L1004"><span class="lineNum">    1004</span> <span class="tlaUNC tlaBgUNC">           0 :           hsize = gst_tensor_meta_info_get_header_size (&amp;in_trans_data-&gt;meta[i]);</span></span>
<span id="L1005"><span class="lineNum">    1005</span> <span class="tlaUNC">           0 :           mem = gst_memory_share (in_trans_data-&gt;mem[i], hsize, -1);</span></span>
<span id="L1006"><span class="lineNum">    1006</span> <span class="tlaUNC">           0 :           gst_tensor_meta_info_convert (&amp;in_trans_data-&gt;meta[i], &amp;combi_info);</span></span>
<span id="L1007"><span class="lineNum">    1007</span> <span class="tlaUNC">           0 :           _info = &amp;combi_info;</span></span>
<span id="L1008"><span class="lineNum">    1008</span>              :         } else {</span>
<span id="L1009"><span class="lineNum">    1009</span> <span class="tlaGNC tlaBgGNC">           1 :           mem = gst_memory_ref (in_trans_data-&gt;mem[i]);</span></span>
<span id="L1010"><span class="lineNum">    1010</span>              :         }</span>
<span id="L1011"><span class="lineNum">    1011</span> <span class="tlaGNC">           1 :         gst_tensor_buffer_append_memory (outbuf, mem, _info);</span></span>
<span id="L1012"><span class="lineNum">    1012</span> <span class="tlaGNC">           1 :         gst_tensor_info_free (&amp;combi_info);</span></span>
<span id="L1013"><span class="lineNum">    1013</span>              :       }</span>
<span id="L1014"><span class="lineNum">    1014</span>              :     }</span>
<span id="L1015"><span class="lineNum">    1015</span> <span class="tlaGNC">       44547 :     for (i = 0; i &lt; in_trans_data-&gt;num_tensors; i++) {</span></span>
<span id="L1016"><span class="lineNum">    1016</span> <span class="tlaGNC">       22507 :       if (in_trans_data-&gt;mem[i]) {</span></span>
<span id="L1017"><span class="lineNum">    1017</span> <span class="tlaGNC">       22507 :         gst_memory_unref (in_trans_data-&gt;mem[i]);</span></span>
<span id="L1018"><span class="lineNum">    1018</span>              :       }</span>
<span id="L1019"><span class="lineNum">    1019</span>              :     }</span>
<span id="L1020"><span class="lineNum">    1020</span>              :   }</span>
<span id="L1021"><span class="lineNum">    1021</span>              : </span>
<span id="L1022"><span class="lineNum">    1022</span> <span class="tlaGNC">       44458 :   for (i = 0; i &lt; prop-&gt;output_meta.num_tensors; i++) {</span></span>
<span id="L1023"><span class="lineNum">    1023</span> <span class="tlaGNC">       22418 :     if (priv-&gt;combi.out_combi_o_defined) {</span></span>
<span id="L1024"><span class="lineNum">    1024</span> <span class="tlaGNC">           1 :       gboolean out_combi = FALSE;</span></span>
<span id="L1025"><span class="lineNum">    1025</span>              : </span>
<span id="L1026"><span class="lineNum">    1026</span> <span class="tlaGNC">           1 :       for (list = priv-&gt;combi.out_combi_o; list != NULL; list = list-&gt;next) {</span></span>
<span id="L1027"><span class="lineNum">    1027</span> <span class="tlaGNC">           1 :         if (i == GPOINTER_TO_UINT (list-&gt;data)) {</span></span>
<span id="L1028"><span class="lineNum">    1028</span> <span class="tlaGNC">           1 :           out_combi = TRUE;</span></span>
<span id="L1029"><span class="lineNum">    1029</span> <span class="tlaGNC">           1 :           break;</span></span>
<span id="L1030"><span class="lineNum">    1030</span>              :         }</span>
<span id="L1031"><span class="lineNum">    1031</span>              :       }</span>
<span id="L1032"><span class="lineNum">    1032</span> <span class="tlaGNC">           1 :       if (!out_combi) {</span></span>
<span id="L1033"><span class="lineNum">    1033</span>              :         /* release memory block if output tensor is not in the combi list */</span>
<span id="L1034"><span class="lineNum">    1034</span> <span class="tlaUNC tlaBgUNC">           0 :         if (out_trans_data-&gt;allocate_in_invoke) {</span></span>
<span id="L1035"><span class="lineNum">    1035</span> <span class="tlaUNC">           0 :           gst_tensor_filter_destroy_notify_util (priv,</span></span>
<span id="L1036"><span class="lineNum">    1036</span>              :               out_trans_data-&gt;tensors[i].data);</span>
<span id="L1037"><span class="lineNum">    1037</span>              :         } else {</span>
<span id="L1038"><span class="lineNum">    1038</span> <span class="tlaUNC">           0 :           gst_memory_unref (out_trans_data-&gt;mem[i]);</span></span>
<span id="L1039"><span class="lineNum">    1039</span>              :         }</span>
<span id="L1040"><span class="lineNum">    1040</span>              : </span>
<span id="L1041"><span class="lineNum">    1041</span> <span class="tlaUNC">           0 :         continue;</span></span>
<span id="L1042"><span class="lineNum">    1042</span>              :       }</span>
<span id="L1043"><span class="lineNum">    1043</span>              :     }</span>
<span id="L1044"><span class="lineNum">    1044</span>              : </span>
<span id="L1045"><span class="lineNum">    1045</span> <span class="tlaGNC tlaBgGNC">       22418 :     _info = gst_tensors_info_get_nth_info (&amp;prop-&gt;output_meta, i);</span></span>
<span id="L1046"><span class="lineNum">    1046</span>              : </span>
<span id="L1047"><span class="lineNum">    1047</span> <span class="tlaGNC">       22418 :     if (prop-&gt;invoke_dynamic) {</span></span>
<span id="L1048"><span class="lineNum">    1048</span>              :       GstTensorMetaInfo meta;</span>
<span id="L1049"><span class="lineNum">    1049</span>              :       GstMemory *flex_mem;</span>
<span id="L1050"><span class="lineNum">    1050</span>              : </span>
<span id="L1051"><span class="lineNum">    1051</span>              :       /* Convert to flexible tensors */</span>
<span id="L1052"><span class="lineNum">    1052</span> <span class="tlaGNC">          18 :       gst_tensor_info_convert_to_meta (_info, &amp;meta);</span></span>
<span id="L1053"><span class="lineNum">    1053</span> <span class="tlaGNC">          18 :       meta.media_type = _NNS_TENSOR;</span></span>
<span id="L1054"><span class="lineNum">    1054</span> <span class="tlaGNC">          18 :       meta.format = _NNS_TENSOR_FORMAT_FLEXIBLE;</span></span>
<span id="L1055"><span class="lineNum">    1055</span>              : </span>
<span id="L1056"><span class="lineNum">    1056</span> <span class="tlaGNC">          18 :       flex_mem = gst_memory_new_wrapped (0,</span></span>
<span id="L1057"><span class="lineNum">    1057</span>              :           out_trans_data-&gt;tensors[i].data, out_trans_data-&gt;tensors[i].size, 0,</span>
<span id="L1058"><span class="lineNum">    1058</span>              :           out_trans_data-&gt;tensors[i].size, out_trans_data-&gt;tensors[i].data,</span>
<span id="L1059"><span class="lineNum">    1059</span>              :           g_free);</span>
<span id="L1060"><span class="lineNum">    1060</span>              : </span>
<span id="L1061"><span class="lineNum">    1061</span> <span class="tlaGNC">          18 :       out_trans_data-&gt;mem[i] =</span></span>
<span id="L1062"><span class="lineNum">    1062</span> <span class="tlaGNC">          18 :           gst_tensor_meta_info_append_header (&amp;meta, flex_mem);</span></span>
<span id="L1063"><span class="lineNum">    1063</span> <span class="tlaGNC">          18 :       gst_memory_unref (flex_mem);</span></span>
<span id="L1064"><span class="lineNum">    1064</span> <span class="tlaGNC">       22400 :     } else if (out_trans_data-&gt;allocate_in_invoke) {</span></span>
<span id="L1065"><span class="lineNum">    1065</span>              :       /* prepare memory block if successfully done */</span>
<span id="L1066"><span class="lineNum">    1066</span> <span class="tlaGNC">          27 :       out_trans_data-&gt;mem[i] = mem = gst_tensor_filter_get_wrapped_mem (self,</span></span>
<span id="L1067"><span class="lineNum">    1067</span>              :           out_trans_data-&gt;tensors[i].data, out_trans_data-&gt;tensors[i].size);</span>
<span id="L1068"><span class="lineNum">    1068</span>              : </span>
<span id="L1069"><span class="lineNum">    1069</span> <span class="tlaGNC">          27 :       if (out_trans_data-&gt;is_flexible) {</span></span>
<span id="L1070"><span class="lineNum">    1070</span>              :         /* prepare new memory block with meta */</span>
<span id="L1071"><span class="lineNum">    1071</span> <span class="tlaUNC tlaBgUNC">           0 :         out_trans_data-&gt;mem[i] =</span></span>
<span id="L1072"><span class="lineNum">    1072</span> <span class="tlaUNC">           0 :             gst_tensor_meta_info_append_header (&amp;out_trans_data-&gt;meta[i], mem);</span></span>
<span id="L1073"><span class="lineNum">    1073</span> <span class="tlaUNC">           0 :         gst_memory_unref (mem);</span></span>
<span id="L1074"><span class="lineNum">    1074</span>              :       }</span>
<span id="L1075"><span class="lineNum">    1075</span>              :     }</span>
<span id="L1076"><span class="lineNum">    1076</span>              : </span>
<span id="L1077"><span class="lineNum">    1077</span>              :     /* append the memory block to outbuf */</span>
<span id="L1078"><span class="lineNum">    1078</span> <span class="tlaGNC tlaBgGNC">       22418 :     gst_tensor_buffer_append_memory (outbuf, out_trans_data-&gt;mem[i], _info);</span></span>
<span id="L1079"><span class="lineNum">    1079</span>              :   }</span>
<span id="L1080"><span class="lineNum">    1080</span> <span class="tlaGNC">       22040 : }</span></span>
<span id="L1081"><span class="lineNum">    1081</span>              : </span>
<span id="L1082"><span class="lineNum">    1082</span>              : /**</span>
<span id="L1083"><span class="lineNum">    1083</span>              :  * @brief Called when there is no input within suspend time specified by the user.</span>
<span id="L1084"><span class="lineNum">    1084</span>              :  */</span>
<span id="L1085"><span class="lineNum">    1085</span>              : static gboolean</span>
<span id="L1086"><span class="lineNum">    1086</span> <span class="tlaGNC">           1 : gst_tensor_filter_watchdog_trigger (gpointer ptr)</span></span>
<span id="L1087"><span class="lineNum">    1087</span>              : {</span>
<span id="L1088"><span class="lineNum">    1088</span> <span class="tlaGNC">           1 :   GstTensorFilterPrivate *priv = (GstTensorFilterPrivate *) ptr;</span></span>
<span id="L1089"><span class="lineNum">    1089</span>              : </span>
<span id="L1090"><span class="lineNum">    1090</span> <span class="tlaGNC">           1 :   ml_logd (&quot;Suspend watchdog triggered. Unload the NN framework.&quot;);</span></span>
<span id="L1091"><span class="lineNum">    1091</span> <span class="tlaGNC">           1 :   gst_tensor_filter_common_unload_fw (priv);</span></span>
<span id="L1092"><span class="lineNum">    1092</span>              : </span>
<span id="L1093"><span class="lineNum">    1093</span> <span class="tlaGNC">           1 :   return FALSE;</span></span>
<span id="L1094"><span class="lineNum">    1094</span>              : }</span>
<span id="L1095"><span class="lineNum">    1095</span>              : </span>
<span id="L1096"><span class="lineNum">    1096</span>              : /**</span>
<span id="L1097"><span class="lineNum">    1097</span>              :  * @brief Callback function invoked for asynchronous output of sub-plugins.</span>
<span id="L1098"><span class="lineNum">    1098</span>              :  *</span>
<span id="L1099"><span class="lineNum">    1099</span>              :  * This callback function is registered with the gst_tensor_filter_enable_invoke_async()</span>
<span id="L1100"><span class="lineNum">    1100</span>              :  * and is called when nnstreamer_filter_dispatch_invoke_async() is called</span>
<span id="L1101"><span class="lineNum">    1101</span>              :  * when output is produced from the sub-plugin.</span>
<span id="L1102"><span class="lineNum">    1102</span>              :  */</span>
<span id="L1103"><span class="lineNum">    1103</span>              : static void</span>
<span id="L1104"><span class="lineNum">    1104</span> <span class="tlaUNC tlaBgUNC">           0 : nnstreamer_filter_async_output_callback (void *async_handle,</span></span>
<span id="L1105"><span class="lineNum">    1105</span>              :     GstTensorMemory * output)</span>
<span id="L1106"><span class="lineNum">    1106</span>              : {</span>
<span id="L1107"><span class="lineNum">    1107</span>              :   guint i;</span>
<span id="L1108"><span class="lineNum">    1108</span>              :   GstTensorFilter *self;</span>
<span id="L1109"><span class="lineNum">    1109</span>              :   GstBaseTransform *trans;</span>
<span id="L1110"><span class="lineNum">    1110</span> <span class="tlaUNC">           0 :   GstTensorFilterPrivate *priv = NULL;</span></span>
<span id="L1111"><span class="lineNum">    1111</span> <span class="tlaUNC">           0 :   FilterTransformData *out_trans_data = NULL;</span></span>
<span id="L1112"><span class="lineNum">    1112</span> <span class="tlaUNC">           0 :   GstTensorFilterProperties *prop = NULL;</span></span>
<span id="L1113"><span class="lineNum">    1113</span> <span class="tlaUNC">           0 :   GstBuffer *outbuf = NULL;</span></span>
<span id="L1114"><span class="lineNum">    1114</span>              : </span>
<span id="L1115"><span class="lineNum">    1115</span> <span class="tlaUNC">           0 :   g_return_if_fail (output != NULL);</span></span>
<span id="L1116"><span class="lineNum">    1116</span> <span class="tlaUNC">           0 :   g_return_if_fail (async_handle != NULL);</span></span>
<span id="L1117"><span class="lineNum">    1117</span>              : </span>
<span id="L1118"><span class="lineNum">    1118</span> <span class="tlaUNC">           0 :   self = GST_TENSOR_FILTER_CAST (async_handle);</span></span>
<span id="L1119"><span class="lineNum">    1119</span> <span class="tlaUNC">           0 :   trans = GST_BASE_TRANSFORM_CAST (self);</span></span>
<span id="L1120"><span class="lineNum">    1120</span> <span class="tlaUNC">           0 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1121"><span class="lineNum">    1121</span> <span class="tlaUNC">           0 :   prop = &amp;priv-&gt;prop;</span></span>
<span id="L1122"><span class="lineNum">    1122</span>              : </span>
<span id="L1123"><span class="lineNum">    1123</span> <span class="tlaUNC">           0 :   outbuf = gst_buffer_new ();</span></span>
<span id="L1124"><span class="lineNum">    1124</span> <span class="tlaUNC">           0 :   if (!outbuf) {</span></span>
<span id="L1125"><span class="lineNum">    1125</span> <span class="tlaUNC">           0 :     ml_loge (&quot;Failed to allocate GstBuffer.&quot;);</span></span>
<span id="L1126"><span class="lineNum">    1126</span> <span class="tlaUNC">           0 :     goto error;</span></span>
<span id="L1127"><span class="lineNum">    1127</span>              :   }</span>
<span id="L1128"><span class="lineNum">    1128</span>              : </span>
<span id="L1129"><span class="lineNum">    1129</span> <span class="tlaUNC">           0 :   out_trans_data = _gst_tensor_filter_transform_get_output_data (trans);</span></span>
<span id="L1130"><span class="lineNum">    1130</span> <span class="tlaUNC">           0 :   if (!out_trans_data) {</span></span>
<span id="L1131"><span class="lineNum">    1131</span> <span class="tlaUNC">           0 :     ml_loge (&quot;Failed to get output transform data.&quot;);</span></span>
<span id="L1132"><span class="lineNum">    1132</span> <span class="tlaUNC">           0 :     goto error;</span></span>
<span id="L1133"><span class="lineNum">    1133</span>              :   }</span>
<span id="L1134"><span class="lineNum">    1134</span>              : </span>
<span id="L1135"><span class="lineNum">    1135</span> <span class="tlaUNC">           0 :   for (i = 0; i &lt; prop-&gt;output_meta.num_tensors; i++) {</span></span>
<span id="L1136"><span class="lineNum">    1136</span> <span class="tlaUNC">           0 :     if (!output[i].data) {</span></span>
<span id="L1137"><span class="lineNum">    1137</span> <span class="tlaUNC">           0 :       ml_loge (&quot;Invalid tensor memory at index %d&quot;, i);</span></span>
<span id="L1138"><span class="lineNum">    1138</span> <span class="tlaUNC">           0 :       goto error;</span></span>
<span id="L1139"><span class="lineNum">    1139</span>              :     }</span>
<span id="L1140"><span class="lineNum">    1140</span> <span class="tlaUNC">           0 :     out_trans_data-&gt;tensors[i].data = output[i].data;</span></span>
<span id="L1141"><span class="lineNum">    1141</span> <span class="tlaUNC">           0 :     out_trans_data-&gt;tensors[i].size = output[i].size;</span></span>
<span id="L1142"><span class="lineNum">    1142</span>              :   }</span>
<span id="L1143"><span class="lineNum">    1143</span>              : </span>
<span id="L1144"><span class="lineNum">    1144</span> <span class="tlaUNC">           0 :   _gst_tensor_filter_transform_update_outbuf (trans, NULL, out_trans_data,</span></span>
<span id="L1145"><span class="lineNum">    1145</span>              :       outbuf);</span>
<span id="L1146"><span class="lineNum">    1146</span> <span class="tlaUNC">           0 :   g_clear_pointer (&amp;out_trans_data, g_free);</span></span>
<span id="L1147"><span class="lineNum">    1147</span>              : </span>
<span id="L1148"><span class="lineNum">    1148</span> <span class="tlaUNC">           0 :   if (gst_pad_push (trans-&gt;srcpad, outbuf) != GST_FLOW_OK) {</span></span>
<span id="L1149"><span class="lineNum">    1149</span> <span class="tlaUNC">           0 :     ml_loge (&quot;Failed to push output buffer at tensor-filter async callback.&quot;);</span></span>
<span id="L1150"><span class="lineNum">    1150</span>              :   }</span>
<span id="L1151"><span class="lineNum">    1151</span>              : </span>
<span id="L1152"><span class="lineNum">    1152</span> <span class="tlaUNC">           0 :   return;</span></span>
<span id="L1153"><span class="lineNum">    1153</span>              : </span>
<span id="L1154"><span class="lineNum">    1154</span> <span class="tlaUNC">           0 : error:</span></span>
<span id="L1155"><span class="lineNum">    1155</span> <span class="tlaUNC">           0 :   for (i = 0; i &lt; prop-&gt;output_meta.num_tensors; i++)</span></span>
<span id="L1156"><span class="lineNum">    1156</span> <span class="tlaUNC">           0 :     g_clear_pointer (&amp;output[i].data, g_free);</span></span>
<span id="L1157"><span class="lineNum">    1157</span>              : </span>
<span id="L1158"><span class="lineNum">    1158</span> <span class="tlaUNC">           0 :   if (outbuf)</span></span>
<span id="L1159"><span class="lineNum">    1159</span> <span class="tlaUNC">           0 :     gst_buffer_unref (outbuf);</span></span>
<span id="L1160"><span class="lineNum">    1160</span>              : </span>
<span id="L1161"><span class="lineNum">    1161</span> <span class="tlaUNC">           0 :   g_clear_pointer (&amp;out_trans_data, g_free);</span></span>
<span id="L1162"><span class="lineNum">    1162</span>              : }</span>
<span id="L1163"><span class="lineNum">    1163</span>              : </span>
<span id="L1164"><span class="lineNum">    1164</span>              : /**</span>
<span id="L1165"><span class="lineNum">    1165</span>              :  * @brief non-ip transform. required vmethod of GstBaseTransform.</span>
<span id="L1166"><span class="lineNum">    1166</span>              :  */</span>
<span id="L1167"><span class="lineNum">    1167</span>              : static GstFlowReturn</span>
<span id="L1168"><span class="lineNum">    1168</span> <span class="tlaGNC tlaBgGNC">       22211 : gst_tensor_filter_transform (GstBaseTransform * trans,</span></span>
<span id="L1169"><span class="lineNum">    1169</span>              :     GstBuffer * inbuf, GstBuffer * outbuf)</span>
<span id="L1170"><span class="lineNum">    1170</span>              : {</span>
<span id="L1171"><span class="lineNum">    1171</span> <span class="tlaGNC">       22211 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1172"><span class="lineNum">    1172</span> <span class="tlaGNC">       22211 :   GstTensorFilterPrivate *priv = &amp;self-&gt;priv;</span></span>
<span id="L1173"><span class="lineNum">    1173</span> <span class="tlaGNC">       22211 :   gint invoke_res = -1;</span></span>
<span id="L1174"><span class="lineNum">    1174</span>              :   gboolean need_profiling;</span>
<span id="L1175"><span class="lineNum">    1175</span> <span class="tlaGNC">       22211 :   GstFlowReturn retval = GST_FLOW_OK;</span></span>
<span id="L1176"><span class="lineNum">    1176</span> <span class="tlaGNC">       22211 :   FilterTransformData *in_trans_data = NULL;</span></span>
<span id="L1177"><span class="lineNum">    1177</span> <span class="tlaGNC">       22211 :   FilterTransformData *out_trans_data = NULL;</span></span>
<span id="L1178"><span class="lineNum">    1178</span> <span class="tlaGNC">       22211 :   GstTensorMemory *invoke_tensors = NULL;</span></span>
<span id="L1179"><span class="lineNum">    1179</span>              : </span>
<span id="L1180"><span class="lineNum">    1180</span>              :   /** Reset suspend timeout */</span>
<span id="L1181"><span class="lineNum">    1181</span> <span class="tlaGNC">       22211 :   if (priv-&gt;prop.suspend != 0) {</span></span>
<span id="L1182"><span class="lineNum">    1182</span> <span class="tlaGNC">           2 :     GST_OBJECT_LOCK (self);</span></span>
<span id="L1183"><span class="lineNum">    1183</span> <span class="tlaGNC">           2 :     nnstreamer_watchdog_release (priv-&gt;watchdog_h);</span></span>
<span id="L1184"><span class="lineNum">    1184</span> <span class="tlaGNC">           2 :     GST_OBJECT_UNLOCK (self);</span></span>
<span id="L1185"><span class="lineNum">    1185</span>              : </span>
<span id="L1186"><span class="lineNum">    1186</span> <span class="tlaGNC">           2 :     if (!gst_tensor_filter_common_open_fw (priv))</span></span>
<span id="L1187"><span class="lineNum">    1187</span> <span class="tlaUNC tlaBgUNC">           0 :       return GST_FLOW_ERROR;</span></span>
<span id="L1188"><span class="lineNum">    1188</span>              :   }</span>
<span id="L1189"><span class="lineNum">    1189</span>              : </span>
<span id="L1190"><span class="lineNum">    1190</span>              :   /* 0. Check all properties. */</span>
<span id="L1191"><span class="lineNum">    1191</span> <span class="tlaGNC tlaBgGNC">       22211 :   retval = _gst_tensor_filter_transform_validate (trans, inbuf, outbuf);</span></span>
<span id="L1192"><span class="lineNum">    1192</span> <span class="tlaGNC">       22211 :   if (retval != GST_FLOW_OK)</span></span>
<span id="L1193"><span class="lineNum">    1193</span> <span class="tlaGNC">         148 :     return retval;</span></span>
<span id="L1194"><span class="lineNum">    1194</span>              : </span>
<span id="L1195"><span class="lineNum">    1195</span>              :   in_trans_data =</span>
<span id="L1196"><span class="lineNum">    1196</span> <span class="tlaGNC">       22063 :       _gst_tensor_filter_transform_get_all_input_data (trans, inbuf);</span></span>
<span id="L1197"><span class="lineNum">    1197</span> <span class="tlaGNC">       22063 :   if (!in_trans_data) {</span></span>
<span id="L1198"><span class="lineNum">    1198</span> <span class="tlaUNC tlaBgUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L1199"><span class="lineNum">    1199</span>              :   }</span>
<span id="L1200"><span class="lineNum">    1200</span>              : </span>
<span id="L1201"><span class="lineNum">    1201</span>              :   invoke_tensors =</span>
<span id="L1202"><span class="lineNum">    1202</span> <span class="tlaGNC tlaBgGNC">       22063 :       _gst_tensor_filter_transform_get_invoke_tensors (trans, in_trans_data);</span></span>
<span id="L1203"><span class="lineNum">    1203</span> <span class="tlaGNC">       22063 :   if (!invoke_tensors) {</span></span>
<span id="L1204"><span class="lineNum">    1204</span> <span class="tlaGNC">           2 :     goto mem_map_error;</span></span>
<span id="L1205"><span class="lineNum">    1205</span>              :   }</span>
<span id="L1206"><span class="lineNum">    1206</span>              : </span>
<span id="L1207"><span class="lineNum">    1207</span> <span class="tlaGNC">       22061 :   out_trans_data = _gst_tensor_filter_transform_get_output_data (trans);</span></span>
<span id="L1208"><span class="lineNum">    1208</span> <span class="tlaGNC">       22061 :   if (!out_trans_data) {</span></span>
<span id="L1209"><span class="lineNum">    1209</span> <span class="tlaUNC tlaBgUNC">           0 :     goto mem_map_error;</span></span>
<span id="L1210"><span class="lineNum">    1210</span>              :   }</span>
<span id="L1211"><span class="lineNum">    1211</span>              : </span>
<span id="L1212"><span class="lineNum">    1212</span>              :   retval =</span>
<span id="L1213"><span class="lineNum">    1213</span> <span class="tlaGNC tlaBgGNC">       22061 :       _gst_tensor_filter_transform_prepare_output_tensors (trans,</span></span>
<span id="L1214"><span class="lineNum">    1214</span>              :       out_trans_data);</span>
<span id="L1215"><span class="lineNum">    1215</span> <span class="tlaGNC">       22061 :   if (retval != GST_FLOW_OK) {</span></span>
<span id="L1216"><span class="lineNum">    1216</span> <span class="tlaGNC">           1 :     goto mem_map_error;</span></span>
<span id="L1217"><span class="lineNum">    1217</span>              :   }</span>
<span id="L1218"><span class="lineNum">    1218</span>              : </span>
<span id="L1219"><span class="lineNum">    1219</span> <span class="tlaGNC">       43967 :   need_profiling = (priv-&gt;latency_mode &gt; 0 || priv-&gt;throughput_mode &gt; 0 ||</span></span>
<span id="L1220"><span class="lineNum">    1220</span> <span class="tlaGNC">       21907 :       priv-&gt;latency_reporting);</span></span>
<span id="L1221"><span class="lineNum">    1221</span> <span class="tlaGNC">       22060 :   if (need_profiling)</span></span>
<span id="L1222"><span class="lineNum">    1222</span> <span class="tlaGNC">         160 :     prepare_statistics (priv);</span></span>
<span id="L1223"><span class="lineNum">    1223</span>              : </span>
<span id="L1224"><span class="lineNum">    1224</span> <span class="tlaGNC">       22060 :   GST_TF_FW_INVOKE_COMPAT (priv, invoke_res, invoke_tensors,</span></span>
<span id="L1225"><span class="lineNum">    1225</span>              :       out_trans_data-&gt;tensors);</span>
<span id="L1226"><span class="lineNum">    1226</span> <span class="tlaGNC">       22060 :   if (need_profiling) {</span></span>
<span id="L1227"><span class="lineNum">    1227</span> <span class="tlaGNC">         160 :     record_statistics (priv);</span></span>
<span id="L1228"><span class="lineNum">    1228</span> <span class="tlaGNC">         160 :     track_latency (self);</span></span>
<span id="L1229"><span class="lineNum">    1229</span>              :   }</span>
<span id="L1230"><span class="lineNum">    1230</span>              : </span>
<span id="L1231"><span class="lineNum">    1231</span>              :   retval =</span>
<span id="L1232"><span class="lineNum">    1232</span> <span class="tlaGNC">       22060 :       _gst_tensor_filter_transform_check_invoke_result (trans, in_trans_data,</span></span>
<span id="L1233"><span class="lineNum">    1233</span>              :       out_trans_data, invoke_res);</span>
<span id="L1234"><span class="lineNum">    1234</span> <span class="tlaGNC">       22060 :   if (retval != GST_FLOW_OK) {</span></span>
<span id="L1235"><span class="lineNum">    1235</span> <span class="tlaGNC">          20 :     goto done;</span></span>
<span id="L1236"><span class="lineNum">    1236</span>              :   }</span>
<span id="L1237"><span class="lineNum">    1237</span>              : </span>
<span id="L1238"><span class="lineNum">    1238</span> <span class="tlaGNC">       22040 :   _gst_tensor_filter_transform_update_outbuf (trans, in_trans_data,</span></span>
<span id="L1239"><span class="lineNum">    1239</span>              :       out_trans_data, outbuf);</span>
<span id="L1240"><span class="lineNum">    1240</span>              : </span>
<span id="L1241"><span class="lineNum">    1241</span> <span class="tlaGNC">       22040 :   goto done;</span></span>
<span id="L1242"><span class="lineNum">    1242</span>              : </span>
<span id="L1243"><span class="lineNum">    1243</span> <span class="tlaGNC">           3 : mem_map_error:</span></span>
<span id="L1244"><span class="lineNum">    1244</span> <span class="tlaGNC">           3 :   retval = GST_FLOW_ERROR;</span></span>
<span id="L1245"><span class="lineNum">    1245</span> <span class="tlaGNC">           3 :   if (in_trans_data) {</span></span>
<span id="L1246"><span class="lineNum">    1246</span> <span class="tlaGNC">           3 :     _gst_tensor_filter_release_mem_until_idx (in_trans_data,</span></span>
<span id="L1247"><span class="lineNum">    1247</span>              :         in_trans_data-&gt;num_tensors);</span>
<span id="L1248"><span class="lineNum">    1248</span>              :   }</span>
<span id="L1249"><span class="lineNum">    1249</span>              : </span>
<span id="L1250"><span class="lineNum">    1250</span> <span class="tlaGNC">           3 :   if (out_trans_data &amp;&amp; !out_trans_data-&gt;allocate_in_invoke) {</span></span>
<span id="L1251"><span class="lineNum">    1251</span> <span class="tlaGNC">           1 :     _gst_tensor_filter_release_mem_until_idx (out_trans_data,</span></span>
<span id="L1252"><span class="lineNum">    1252</span>              :         out_trans_data-&gt;num_tensors);</span>
<span id="L1253"><span class="lineNum">    1253</span>              :   }</span>
<span id="L1254"><span class="lineNum">    1254</span>              : </span>
<span id="L1255"><span class="lineNum">    1255</span> <span class="tlaGNC">           2 : done:</span></span>
<span id="L1256"><span class="lineNum">    1256</span>              :   /** Set suspend timeout */</span>
<span id="L1257"><span class="lineNum">    1257</span> <span class="tlaGNC">       22063 :   if (retval == GST_FLOW_OK &amp;&amp; priv-&gt;prop.suspend != 0) {</span></span>
<span id="L1258"><span class="lineNum">    1258</span> <span class="tlaGNC">           2 :     GST_OBJECT_LOCK (self);</span></span>
<span id="L1259"><span class="lineNum">    1259</span> <span class="tlaGNC">           2 :     if (!nnstreamer_watchdog_feed (priv-&gt;watchdog_h,</span></span>
<span id="L1260"><span class="lineNum">    1260</span>              :         gst_tensor_filter_watchdog_trigger, priv-&gt;prop.suspend, priv)) {</span>
<span id="L1261"><span class="lineNum">    1261</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_logw (&quot;Failed to feed watchdog. Suspend mode is not working.&quot;);</span></span>
<span id="L1262"><span class="lineNum">    1262</span>              :     }</span>
<span id="L1263"><span class="lineNum">    1263</span> <span class="tlaGNC tlaBgGNC">           2 :     GST_OBJECT_UNLOCK (self);</span></span>
<span id="L1264"><span class="lineNum">    1264</span>              :   }</span>
<span id="L1265"><span class="lineNum">    1265</span>              : </span>
<span id="L1266"><span class="lineNum">    1266</span> <span class="tlaGNC">       22063 :   g_free (in_trans_data);</span></span>
<span id="L1267"><span class="lineNum">    1267</span> <span class="tlaGNC">       22063 :   g_free (out_trans_data);</span></span>
<span id="L1268"><span class="lineNum">    1268</span> <span class="tlaGNC">       22063 :   g_free (invoke_tensors);</span></span>
<span id="L1269"><span class="lineNum">    1269</span>              : </span>
<span id="L1270"><span class="lineNum">    1270</span> <span class="tlaGNC">       22063 :   return retval;</span></span>
<span id="L1271"><span class="lineNum">    1271</span>              : }</span>
<span id="L1272"><span class="lineNum">    1272</span>              : </span>
<span id="L1273"><span class="lineNum">    1273</span>              : /**</span>
<span id="L1274"><span class="lineNum">    1274</span>              :  * @brief Configure input and output tensor info from incaps.</span>
<span id="L1275"><span class="lineNum">    1275</span>              :  * @param self &quot;this&quot; pointer</span>
<span id="L1276"><span class="lineNum">    1276</span>              :  * @param incaps received caps for sink pad</span>
<span id="L1277"><span class="lineNum">    1277</span>              :  * @return TRUE if fully configured</span>
<span id="L1278"><span class="lineNum">    1278</span>              :  */</span>
<span id="L1279"><span class="lineNum">    1279</span>              : static gboolean</span>
<span id="L1280"><span class="lineNum">    1280</span> <span class="tlaGNC">         195 : gst_tensor_filter_configure_tensor (GstTensorFilter * self,</span></span>
<span id="L1281"><span class="lineNum">    1281</span>              :     const GstCaps * incaps)</span>
<span id="L1282"><span class="lineNum">    1282</span>              : {</span>
<span id="L1283"><span class="lineNum">    1283</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1284"><span class="lineNum">    1284</span>              :   GstTensorFilterProperties *prop;</span>
<span id="L1285"><span class="lineNum">    1285</span>              :   GstTensorsConfig in_config, out_config;</span>
<span id="L1286"><span class="lineNum">    1286</span>              :   GstTensorsInfo in_info, out_info;</span>
<span id="L1287"><span class="lineNum">    1287</span>              :   gboolean flexible;</span>
<span id="L1288"><span class="lineNum">    1288</span>              : </span>
<span id="L1289"><span class="lineNum">    1289</span> <span class="tlaGNC">         390 :   g_return_val_if_fail (incaps != NULL, FALSE);</span></span>
<span id="L1290"><span class="lineNum">    1290</span> <span class="tlaGNC">         195 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1291"><span class="lineNum">    1291</span> <span class="tlaGNC">         195 :   prop = &amp;priv-&gt;prop;</span></span>
<span id="L1292"><span class="lineNum">    1292</span> <span class="tlaGNC">         195 :   gst_tensors_config_init (&amp;in_config);</span></span>
<span id="L1293"><span class="lineNum">    1293</span> <span class="tlaGNC">         195 :   gst_tensors_config_init (&amp;out_config);</span></span>
<span id="L1294"><span class="lineNum">    1294</span> <span class="tlaGNC">         195 :   gst_tensors_info_init (&amp;in_info);</span></span>
<span id="L1295"><span class="lineNum">    1295</span> <span class="tlaGNC">         195 :   gst_tensors_info_init (&amp;out_info);</span></span>
<span id="L1296"><span class="lineNum">    1296</span>              : </span>
<span id="L1297"><span class="lineNum">    1297</span>              :   /**</span>
<span id="L1298"><span class="lineNum">    1298</span>              :    * GstTensorFilter has to parse the tensor dimension and type from NN model.</span>
<span id="L1299"><span class="lineNum">    1299</span>              :    * 1. Call functions getInputDimension and getOutputDimension to get the dimension and type.</span>
<span id="L1300"><span class="lineNum">    1300</span>              :    * 2. If these functions are not defined, call setInputDimension with parsed info from caps.</span>
<span id="L1301"><span class="lineNum">    1301</span>              :    * 3. If set-prop configured dimension, verify the dimension with fw callbacks.</span>
<span id="L1302"><span class="lineNum">    1302</span>              :    */</span>
<span id="L1303"><span class="lineNum">    1303</span> <span class="tlaGNC">         195 :   gst_tensor_filter_load_tensor_info (&amp;self-&gt;priv);</span></span>
<span id="L1304"><span class="lineNum">    1304</span>              : </span>
<span id="L1305"><span class="lineNum">    1305</span>              :   /**</span>
<span id="L1306"><span class="lineNum">    1306</span>              :    * Check configuration from caps.</span>
<span id="L1307"><span class="lineNum">    1307</span>              :    * If true, fully configured tensor info from caps.</span>
<span id="L1308"><span class="lineNum">    1308</span>              :    */</span>
<span id="L1309"><span class="lineNum">    1309</span> <span class="tlaGNC">         195 :   if (!gst_tensors_config_from_caps (&amp;in_config, incaps, TRUE)) {</span></span>
<span id="L1310"><span class="lineNum">    1310</span> <span class="tlaUNC tlaBgUNC">           0 :     gchar *capstr = gst_caps_to_string (incaps);</span></span>
<span id="L1311"><span class="lineNum">    1311</span> <span class="tlaUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1312"><span class="lineNum">    1312</span>              :         (&quot;%s:%u The input stream padcaps cannot be validated. It is not a valid tensor stream for tensor_filter element. Input stream type for tensor_filter (%s:%s) is %s. tensor-filter could get config from the input padcap; however, it cannot be validated: framerate or format is not valid. Try a static tensor stream with a valid (0/1 is also valid!) framerate.&quot;,</span>
<span id="L1313"><span class="lineNum">    1313</span>              :             __func__, __LINE__, GST_STR_NULL (prop-&gt;fwname),</span>
<span id="L1314"><span class="lineNum">    1314</span>              :             TF_MODELNAME (prop), capstr));</span>
<span id="L1315"><span class="lineNum">    1315</span> <span class="tlaUNC">           0 :     g_free (capstr);</span></span>
<span id="L1316"><span class="lineNum">    1316</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L1317"><span class="lineNum">    1317</span>              :   }</span>
<span id="L1318"><span class="lineNum">    1318</span>              : </span>
<span id="L1319"><span class="lineNum">    1319</span> <span class="tlaGNC tlaBgGNC">         195 :   if (!gst_tensor_filter_common_get_combined_in_info (priv, &amp;in_config.info,</span></span>
<span id="L1320"><span class="lineNum">    1320</span>              :           &amp;in_info)) {</span>
<span id="L1321"><span class="lineNum">    1321</span> <span class="tlaUNC tlaBgUNC">           0 :     gchar *capstr = gst_caps_to_string (incaps);</span></span>
<span id="L1322"><span class="lineNum">    1322</span> <span class="tlaUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1323"><span class="lineNum">    1323</span>              :         (&quot;%s:%u Failed to configure combined input info for tensor-filter (%s:%s). The given padcap is '%s'. User has specified input combination (refer to the previous error log), which shuffles the order of tensors, which is not compatible with the given model. Please check the padcap, input combination, and tensor/dimension requirement of your neural network model.&quot;,</span>
<span id="L1324"><span class="lineNum">    1324</span>              :             __func__, __LINE__, GST_STR_NULL (prop-&gt;fwname),</span>
<span id="L1325"><span class="lineNum">    1325</span>              :             TF_MODELNAME (prop), capstr));</span>
<span id="L1326"><span class="lineNum">    1326</span> <span class="tlaUNC">           0 :     g_free (capstr);</span></span>
<span id="L1327"><span class="lineNum">    1327</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L1328"><span class="lineNum">    1328</span>              :   }</span>
<span id="L1329"><span class="lineNum">    1329</span>              : </span>
<span id="L1330"><span class="lineNum">    1330</span>              :   /* flexible tensor case, we cannot get the exact info from caps. */</span>
<span id="L1331"><span class="lineNum">    1331</span> <span class="tlaGNC tlaBgGNC">         195 :   flexible = gst_tensors_config_is_flexible (&amp;in_config);</span></span>
<span id="L1332"><span class="lineNum">    1332</span>              : </span>
<span id="L1333"><span class="lineNum">    1333</span>              :   /** if set-property called and already has info, verify it! */</span>
<span id="L1334"><span class="lineNum">    1334</span> <span class="tlaGNC">         195 :   if (prop-&gt;input_meta.num_tensors &gt; 0) {</span></span>
<span id="L1335"><span class="lineNum">    1335</span> <span class="tlaGNC">         148 :     if (flexible) {</span></span>
<span id="L1336"><span class="lineNum">    1336</span>              :       /**</span>
<span id="L1337"><span class="lineNum">    1337</span>              :        * If incoming tensor is flexible, we cannot validate tensor info here.</span>
<span id="L1338"><span class="lineNum">    1338</span>              :        * Need to compare buffer size in transform().</span>
<span id="L1339"><span class="lineNum">    1339</span>              :        */</span>
<span id="L1340"><span class="lineNum">    1340</span> <span class="tlaGNC">          17 :       GST_INFO_OBJECT (self, &quot;The input tensor is flexible.&quot;);</span></span>
<span id="L1341"><span class="lineNum">    1341</span> <span class="tlaGNC">         131 :     } else if (!gst_tensors_info_is_equal (&amp;in_info, &amp;prop-&gt;input_meta)) {</span></span>
<span id="L1342"><span class="lineNum">    1342</span> <span class="tlaGNC">          35 :       gchar *capstr = gst_caps_to_string (incaps);</span></span>
<span id="L1343"><span class="lineNum">    1343</span>              :       gchar *compare =</span>
<span id="L1344"><span class="lineNum">    1344</span> <span class="tlaGNC">          35 :           gst_tensors_info_compare_to_string (&amp;in_info, &amp;prop-&gt;input_meta);</span></span>
<span id="L1345"><span class="lineNum">    1345</span> <span class="tlaGNC">          35 :       GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1346"><span class="lineNum">    1346</span>              :           (&quot;%s:%u The input tensor of tensor_filter (%s:%s) is not compatible with the configured input information. Please check tensor-filter properties if you have given input dimensions explicitly; or the model properties if you have not given them. Check the input stream caps and related caps-filters, too. The given gstcap is %s, which is not compatible: %s&quot;,</span>
<span id="L1347"><span class="lineNum">    1347</span>              :               __func__, __LINE__, GST_STR_NULL (prop-&gt;fwname),</span>
<span id="L1348"><span class="lineNum">    1348</span>              :               TF_MODELNAME (prop), capstr, compare));</span>
<span id="L1349"><span class="lineNum">    1349</span> <span class="tlaGNC">          35 :       g_free (compare);</span></span>
<span id="L1350"><span class="lineNum">    1350</span> <span class="tlaGNC">          35 :       g_free (capstr);</span></span>
<span id="L1351"><span class="lineNum">    1351</span> <span class="tlaGNC">          35 :       goto done;</span></span>
<span id="L1352"><span class="lineNum">    1352</span>              :     }</span>
<span id="L1353"><span class="lineNum">    1353</span>              :   } else {</span>
<span id="L1354"><span class="lineNum">    1354</span> <span class="tlaGNC">          47 :     if (flexible) {</span></span>
<span id="L1355"><span class="lineNum">    1355</span> <span class="tlaUNC tlaBgUNC">           0 :       gchar *capstr = gst_caps_to_string (incaps);</span></span>
<span id="L1356"><span class="lineNum">    1356</span>              :       /** @todo</span>
<span id="L1357"><span class="lineNum">    1357</span>              :        * We do not support this (flexible tensor for flexible input model).</span>
<span id="L1358"><span class="lineNum">    1358</span>              :        * Cap-negotiation of the current tensor-filter requires either side of</span>
<span id="L1359"><span class="lineNum">    1359</span>              :        * &quot;model / set-property&quot; or &quot;incoming gstcaps&quot; to be static/explicit.</span>
<span id="L1360"><span class="lineNum">    1360</span>              :        * Ideally, this should support flexible tensor for flexible input model,</span>
<span id="L1361"><span class="lineNum">    1361</span>              :        * leaving the negotiation to other elements, but we didn't implement it yet.</span>
<span id="L1362"><span class="lineNum">    1362</span>              :        */</span>
<span id="L1363"><span class="lineNum">    1363</span> <span class="tlaUNC">           0 :       GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1364"><span class="lineNum">    1364</span>              :           (&quot;%s:%u The input tensor of tensor_filter (%s:%s) is flexible (gstcap: '%s'), which requires either explicit type/dimension tensor-filter property values or static input dimension models. The current version of tensor-filter does not support flexible tensors for dynamic-input models without explicit input dimension declaration. Declare type/dimension/tensors with tensor-filter properties, or apply caps-filter in front of tensor-filter, or use static tensor streams.&quot;,</span>
<span id="L1365"><span class="lineNum">    1365</span>              :               __func__, __LINE__, GST_STR_NULL (prop-&gt;fwname),</span>
<span id="L1366"><span class="lineNum">    1366</span>              :               TF_MODELNAME (prop), capstr));</span>
<span id="L1367"><span class="lineNum">    1367</span> <span class="tlaUNC">           0 :       g_free (capstr);</span></span>
<span id="L1368"><span class="lineNum">    1368</span> <span class="tlaUNC">           0 :       goto done;</span></span>
<span id="L1369"><span class="lineNum">    1369</span>              :     } else {</span>
<span id="L1370"><span class="lineNum">    1370</span> <span class="tlaGNC tlaBgGNC">          47 :       gst_tensors_info_copy (&amp;prop-&gt;input_meta, &amp;in_info);</span></span>
<span id="L1371"><span class="lineNum">    1371</span>              :     }</span>
<span id="L1372"><span class="lineNum">    1372</span>              :   }</span>
<span id="L1373"><span class="lineNum">    1373</span>              : </span>
<span id="L1374"><span class="lineNum">    1374</span> <span class="tlaGNC">         160 :   prop-&gt;input_configured = TRUE;</span></span>
<span id="L1375"><span class="lineNum">    1375</span>              : </span>
<span id="L1376"><span class="lineNum">    1376</span>              :   /** call setInputDimension if output tensor is not configured */</span>
<span id="L1377"><span class="lineNum">    1377</span> <span class="tlaGNC">         160 :   if (!prop-&gt;output_configured) {</span></span>
<span id="L1378"><span class="lineNum">    1378</span> <span class="tlaGNC">          53 :     if (gst_tensor_filter_common_get_out_info (priv, &amp;prop-&gt;input_meta,</span></span>
<span id="L1379"><span class="lineNum">    1379</span>              :             &amp;out_info)) {</span>
<span id="L1380"><span class="lineNum">    1380</span>              :       /** if set-property called and already has info, verify it! */</span>
<span id="L1381"><span class="lineNum">    1381</span> <span class="tlaGNC">          52 :       if (prop-&gt;output_meta.num_tensors &gt; 0) {</span></span>
<span id="L1382"><span class="lineNum">    1382</span> <span class="tlaGNC">           5 :         if (!gst_tensors_info_is_equal (&amp;out_info, &amp;prop-&gt;output_meta)) {</span></span>
<span id="L1383"><span class="lineNum">    1383</span> <span class="tlaGNC">           6 :           gchar *cmpstr = gst_tensors_info_compare_to_string (&amp;out_info,</span></span>
<span id="L1384"><span class="lineNum">    1384</span> <span class="tlaGNC">           3 :               &amp;prop-&gt;output_meta);</span></span>
<span id="L1385"><span class="lineNum">    1385</span> <span class="tlaGNC">           3 :           GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1386"><span class="lineNum">    1386</span>              :               (&quot;%s:%u The output tensor is not compatible with the configured tensor information. The configuration is usually set by tensor-filter properties declared by users or the given neural network itself. The following two tensor metadata are not compatible: %s.\n&quot;,</span>
<span id="L1387"><span class="lineNum">    1387</span>              :                   __func__, __LINE__, cmpstr));</span>
<span id="L1388"><span class="lineNum">    1388</span> <span class="tlaGNC">           3 :           g_free (cmpstr);</span></span>
<span id="L1389"><span class="lineNum">    1389</span> <span class="tlaGNC">           3 :           gst_tensors_info_free (&amp;out_info);</span></span>
<span id="L1390"><span class="lineNum">    1390</span> <span class="tlaGNC">           3 :           goto done;</span></span>
<span id="L1391"><span class="lineNum">    1391</span>              :         }</span>
<span id="L1392"><span class="lineNum">    1392</span>              :       } else {</span>
<span id="L1393"><span class="lineNum">    1393</span> <span class="tlaGNC">          47 :         gst_tensors_info_copy (&amp;prop-&gt;output_meta, &amp;out_info);</span></span>
<span id="L1394"><span class="lineNum">    1394</span>              :       }</span>
<span id="L1395"><span class="lineNum">    1395</span>              : </span>
<span id="L1396"><span class="lineNum">    1396</span> <span class="tlaGNC">          49 :       prop-&gt;output_configured = TRUE;</span></span>
<span id="L1397"><span class="lineNum">    1397</span>              :     }</span>
<span id="L1398"><span class="lineNum">    1398</span>              : </span>
<span id="L1399"><span class="lineNum">    1399</span> <span class="tlaGNC">          50 :     if (!prop-&gt;output_configured) {</span></span>
<span id="L1400"><span class="lineNum">    1400</span> <span class="tlaGNC">           1 :       GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1401"><span class="lineNum">    1401</span>              :           (&quot;%s:%u Failed to get output tensor info: not enough related information to configure output.\n&quot;,</span>
<span id="L1402"><span class="lineNum">    1402</span>              :               __func__, __LINE__));</span>
<span id="L1403"><span class="lineNum">    1403</span> <span class="tlaGNC">           1 :       goto done;</span></span>
<span id="L1404"><span class="lineNum">    1404</span>              :     }</span>
<span id="L1405"><span class="lineNum">    1405</span>              :   }</span>
<span id="L1406"><span class="lineNum">    1406</span>              : </span>
<span id="L1407"><span class="lineNum">    1407</span>              :   /**</span>
<span id="L1408"><span class="lineNum">    1408</span>              :    * @todo framerate of output tensors</span>
<span id="L1409"><span class="lineNum">    1409</span>              :    * How can we update the framerate?</span>
<span id="L1410"><span class="lineNum">    1410</span>              :    * GstTensorFilter cannot assure the framerate.</span>
<span id="L1411"><span class="lineNum">    1411</span>              :    * Simply set the framerate of out-tensor from incaps.</span>
<span id="L1412"><span class="lineNum">    1412</span>              :    */</span>
<span id="L1413"><span class="lineNum">    1413</span> <span class="tlaGNC">         156 :   out_config.rate_n = in_config.rate_n;</span></span>
<span id="L1414"><span class="lineNum">    1414</span> <span class="tlaGNC">         156 :   out_config.rate_d = in_config.rate_d;</span></span>
<span id="L1415"><span class="lineNum">    1415</span>              : </span>
<span id="L1416"><span class="lineNum">    1416</span> <span class="tlaGNC">         156 :   if (!gst_tensor_filter_common_get_combined_out_info (priv, &amp;in_config.info,</span></span>
<span id="L1417"><span class="lineNum">    1417</span> <span class="tlaGNC">         156 :           &amp;prop-&gt;output_meta, &amp;out_config.info)) {</span></span>
<span id="L1418"><span class="lineNum">    1418</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1419"><span class="lineNum">    1419</span>              :         (&quot;%s:%u Failed to configure combined output info: please refer to the error message of gst_tensor_filter_common_get_combined_out_info(). &quot;,</span>
<span id="L1420"><span class="lineNum">    1420</span>              :             __func__, __LINE__));</span>
<span id="L1421"><span class="lineNum">    1421</span> <span class="tlaUNC">           0 :     goto done;</span></span>
<span id="L1422"><span class="lineNum">    1422</span>              :   }</span>
<span id="L1423"><span class="lineNum">    1423</span>              : </span>
<span id="L1424"><span class="lineNum">    1424</span> <span class="tlaGNC tlaBgGNC">         156 :   if (priv-&gt;configured) {</span></span>
<span id="L1425"><span class="lineNum">    1425</span>              :     /** already configured, compare to old. */</span>
<span id="L1426"><span class="lineNum">    1426</span> <span class="tlaGNC">           1 :     if (!priv-&gt;prop.invoke_dynamic) {</span></span>
<span id="L1427"><span class="lineNum">    1427</span> <span class="tlaGNC">           1 :       g_assert (gst_tensors_config_is_equal (&amp;priv-&gt;in_config, &amp;in_config));</span></span>
<span id="L1428"><span class="lineNum">    1428</span> <span class="tlaGNC">           1 :       g_assert (gst_tensors_config_is_equal (&amp;priv-&gt;out_config, &amp;out_config));</span></span>
<span id="L1429"><span class="lineNum">    1429</span>              :     }</span>
<span id="L1430"><span class="lineNum">    1430</span>              :   } else {</span>
<span id="L1431"><span class="lineNum">    1431</span> <span class="tlaGNC">         155 :     gst_tensors_config_copy (&amp;priv-&gt;in_config, &amp;in_config);</span></span>
<span id="L1432"><span class="lineNum">    1432</span> <span class="tlaGNC">         155 :     gst_tensors_config_copy (&amp;priv-&gt;out_config, &amp;out_config);</span></span>
<span id="L1433"><span class="lineNum">    1433</span>              : </span>
<span id="L1434"><span class="lineNum">    1434</span> <span class="tlaGNC">         155 :     priv-&gt;configured = TRUE;</span></span>
<span id="L1435"><span class="lineNum">    1435</span>              :   }</span>
<span id="L1436"><span class="lineNum">    1436</span>              : </span>
<span id="L1437"><span class="lineNum">    1437</span> <span class="tlaGNC">         195 : done:</span></span>
<span id="L1438"><span class="lineNum">    1438</span> <span class="tlaGNC">         195 :   gst_tensors_config_free (&amp;in_config);</span></span>
<span id="L1439"><span class="lineNum">    1439</span> <span class="tlaGNC">         195 :   gst_tensors_config_free (&amp;out_config);</span></span>
<span id="L1440"><span class="lineNum">    1440</span> <span class="tlaGNC">         195 :   gst_tensors_info_free (&amp;in_info);</span></span>
<span id="L1441"><span class="lineNum">    1441</span> <span class="tlaGNC">         195 :   gst_tensors_info_free (&amp;out_info);</span></span>
<span id="L1442"><span class="lineNum">    1442</span>              : </span>
<span id="L1443"><span class="lineNum">    1443</span> <span class="tlaGNC">         195 :   return priv-&gt;configured;</span></span>
<span id="L1444"><span class="lineNum">    1444</span>              : }</span>
<span id="L1445"><span class="lineNum">    1445</span>              : </span>
<span id="L1446"><span class="lineNum">    1446</span>              : /**</span>
<span id="L1447"><span class="lineNum">    1447</span>              :  * @brief configure tensor-srcpad cap from &quot;proposed&quot; cap.</span>
<span id="L1448"><span class="lineNum">    1448</span>              :  *</span>
<span id="L1449"><span class="lineNum">    1449</span>              :  * @trans (&quot;this&quot; pointer)</span>
<span id="L1450"><span class="lineNum">    1450</span>              :  * @direction (why do we need this?)</span>
<span id="L1451"><span class="lineNum">    1451</span>              :  * @caps sinkpad cap (if direction GST_PAD_SINK)</span>
<span id="L1452"><span class="lineNum">    1452</span>              :  * @filter this element's cap (don't know specifically.)</span>
<span id="L1453"><span class="lineNum">    1453</span>              :  *</span>
<span id="L1454"><span class="lineNum">    1454</span>              :  * Be careful not to fix/set caps at this stage. Negotiation not completed yet.</span>
<span id="L1455"><span class="lineNum">    1455</span>              :  */</span>
<span id="L1456"><span class="lineNum">    1456</span>              : static GstCaps *</span>
<span id="L1457"><span class="lineNum">    1457</span> <span class="tlaGNC">        2787 : gst_tensor_filter_transform_caps (GstBaseTransform * trans,</span></span>
<span id="L1458"><span class="lineNum">    1458</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * filter)</span>
<span id="L1459"><span class="lineNum">    1459</span>              : {</span>
<span id="L1460"><span class="lineNum">    1460</span>              :   GstTensorFilter *self;</span>
<span id="L1461"><span class="lineNum">    1461</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1462"><span class="lineNum">    1462</span>              :   GstTensorFilterProperties *prop;</span>
<span id="L1463"><span class="lineNum">    1463</span>              :   GstTensorsConfig in_config, out_config;</span>
<span id="L1464"><span class="lineNum">    1464</span>              :   GstPad *pad;</span>
<span id="L1465"><span class="lineNum">    1465</span>              :   GstCaps *result;</span>
<span id="L1466"><span class="lineNum">    1466</span> <span class="tlaGNC">        2787 :   gboolean configured = FALSE;</span></span>
<span id="L1467"><span class="lineNum">    1467</span>              : </span>
<span id="L1468"><span class="lineNum">    1468</span> <span class="tlaGNC">        2787 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1469"><span class="lineNum">    1469</span> <span class="tlaGNC">        2787 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1470"><span class="lineNum">    1470</span> <span class="tlaGNC">        2787 :   prop = &amp;priv-&gt;prop;</span></span>
<span id="L1471"><span class="lineNum">    1471</span>              : </span>
<span id="L1472"><span class="lineNum">    1472</span>              :   /* Not ready */</span>
<span id="L1473"><span class="lineNum">    1473</span> <span class="tlaGNC">        2787 :   if (priv-&gt;fw == NULL)</span></span>
<span id="L1474"><span class="lineNum">    1474</span> <span class="tlaGNC">        2787 :     return NULL;</span></span>
<span id="L1475"><span class="lineNum">    1475</span>              : </span>
<span id="L1476"><span class="lineNum">    1476</span> <span class="tlaGNC">        2723 :   gst_tensors_config_init (&amp;in_config);</span></span>
<span id="L1477"><span class="lineNum">    1477</span> <span class="tlaGNC">        2723 :   gst_tensors_config_init (&amp;out_config);</span></span>
<span id="L1478"><span class="lineNum">    1478</span>              : </span>
<span id="L1479"><span class="lineNum">    1479</span> <span class="tlaGNC">        2723 :   silent_debug_caps (self, caps, &quot;from&quot;);</span></span>
<span id="L1480"><span class="lineNum">    1480</span> <span class="tlaGNC">        2723 :   silent_debug_caps (self, filter, &quot;filter&quot;);</span></span>
<span id="L1481"><span class="lineNum">    1481</span>              : </span>
<span id="L1482"><span class="lineNum">    1482</span> <span class="tlaGNC">        2723 :   if (direction == GST_PAD_SINK)</span></span>
<span id="L1483"><span class="lineNum">    1483</span> <span class="tlaGNC">        1383 :     pad = GST_BASE_TRANSFORM_SRC_PAD (trans);</span></span>
<span id="L1484"><span class="lineNum">    1484</span>              :   else</span>
<span id="L1485"><span class="lineNum">    1485</span> <span class="tlaGNC">        1340 :     pad = GST_BASE_TRANSFORM_SINK_PAD (trans);</span></span>
<span id="L1486"><span class="lineNum">    1486</span>              : </span>
<span id="L1487"><span class="lineNum">    1487</span>              :   /**</span>
<span id="L1488"><span class="lineNum">    1488</span>              :    * GstTensorFilter has to parse the tensor dimension and type from NN model.</span>
<span id="L1489"><span class="lineNum">    1489</span>              :    * In this stage, in-caps may not be fixed yet.</span>
<span id="L1490"><span class="lineNum">    1490</span>              :    * To get the tensor info and generate pad-caps, call getInputDimension and getOutputDimension.</span>
<span id="L1491"><span class="lineNum">    1491</span>              :    * If these functions are not defined, we have to call setInputDimension, and then it will fully configure the tensor info.</span>
<span id="L1492"><span class="lineNum">    1492</span>              :    *</span>
<span id="L1493"><span class="lineNum">    1493</span>              :    * @todo how to set the framerate of output tensors</span>
<span id="L1494"><span class="lineNum">    1494</span>              :    */</span>
<span id="L1495"><span class="lineNum">    1495</span> <span class="tlaGNC">        2723 :   gst_tensor_filter_load_tensor_info (&amp;self-&gt;priv);</span></span>
<span id="L1496"><span class="lineNum">    1496</span>              : </span>
<span id="L1497"><span class="lineNum">    1497</span> <span class="tlaGNC">        2723 :   gst_tensors_config_from_caps (&amp;in_config, caps, FALSE);</span></span>
<span id="L1498"><span class="lineNum">    1498</span>              : </span>
<span id="L1499"><span class="lineNum">    1499</span>              :   /* set framerate from input config */</span>
<span id="L1500"><span class="lineNum">    1500</span> <span class="tlaGNC">        2723 :   out_config.rate_n = in_config.rate_n;</span></span>
<span id="L1501"><span class="lineNum">    1501</span> <span class="tlaGNC">        2723 :   out_config.rate_d = in_config.rate_d;</span></span>
<span id="L1502"><span class="lineNum">    1502</span>              : </span>
<span id="L1503"><span class="lineNum">    1503</span> <span class="tlaGNC">        2723 :   if (direction == GST_PAD_SINK) {</span></span>
<span id="L1504"><span class="lineNum">    1504</span>              :     GstTensorsInfo out_info;</span>
<span id="L1505"><span class="lineNum">    1505</span>              : </span>
<span id="L1506"><span class="lineNum">    1506</span> <span class="tlaGNC">        1383 :     gst_tensors_info_init (&amp;out_info);</span></span>
<span id="L1507"><span class="lineNum">    1507</span>              : </span>
<span id="L1508"><span class="lineNum">    1508</span>              :     /* caps: sink pad. get src pad info */</span>
<span id="L1509"><span class="lineNum">    1509</span> <span class="tlaGNC">        1383 :     if (prop-&gt;output_configured) {</span></span>
<span id="L1510"><span class="lineNum">    1510</span>              :       /* caps with sub-plugin's tensor info */</span>
<span id="L1511"><span class="lineNum">    1511</span> <span class="tlaGNC">         850 :       gst_tensors_info_copy (&amp;out_info, &amp;prop-&gt;output_meta);</span></span>
<span id="L1512"><span class="lineNum">    1512</span> <span class="tlaGNC">         850 :       configured = TRUE;</span></span>
<span id="L1513"><span class="lineNum">    1513</span>              :     } else {</span>
<span id="L1514"><span class="lineNum">    1514</span>              :       /* check in-tensor info to call setInputDimension */</span>
<span id="L1515"><span class="lineNum">    1515</span> <span class="tlaGNC">         533 :       configured = gst_tensor_filter_common_get_out_info (priv,</span></span>
<span id="L1516"><span class="lineNum">    1516</span>              :           &amp;in_config.info, &amp;out_info);</span>
<span id="L1517"><span class="lineNum">    1517</span>              :     }</span>
<span id="L1518"><span class="lineNum">    1518</span>              : </span>
<span id="L1519"><span class="lineNum">    1519</span>              :     /* If output combination option is given, reconfigure tensor info */</span>
<span id="L1520"><span class="lineNum">    1520</span> <span class="tlaGNC">        1383 :     if (configured)</span></span>
<span id="L1521"><span class="lineNum">    1521</span> <span class="tlaGNC">        1087 :       configured = gst_tensor_filter_common_get_combined_out_info (priv,</span></span>
<span id="L1522"><span class="lineNum">    1522</span>              :           &amp;in_config.info, &amp;out_info, &amp;out_config.info);</span>
<span id="L1523"><span class="lineNum">    1523</span>              : </span>
<span id="L1524"><span class="lineNum">    1524</span> <span class="tlaGNC">        1383 :     gst_tensors_info_free (&amp;out_info);</span></span>
<span id="L1525"><span class="lineNum">    1525</span>              :   } else {</span>
<span id="L1526"><span class="lineNum">    1526</span>              :     /* caps: src pad. get sink pad info */</span>
<span id="L1527"><span class="lineNum">    1527</span> <span class="tlaGNC">        1340 :     if (prop-&gt;input_configured &amp;&amp; !priv-&gt;combi.in_combi_defined) {</span></span>
<span id="L1528"><span class="lineNum">    1528</span>              :       /* caps with sub-plugin's tensor info */</span>
<span id="L1529"><span class="lineNum">    1529</span> <span class="tlaGNC">         859 :       gst_tensors_info_copy (&amp;out_config.info, &amp;prop-&gt;input_meta);</span></span>
<span id="L1530"><span class="lineNum">    1530</span> <span class="tlaGNC">         859 :       configured = TRUE;</span></span>
<span id="L1531"><span class="lineNum">    1531</span>              :     }</span>
<span id="L1532"><span class="lineNum">    1532</span>              :   }</span>
<span id="L1533"><span class="lineNum">    1533</span>              : </span>
<span id="L1534"><span class="lineNum">    1534</span> <span class="tlaGNC">        2723 :   if (configured) {</span></span>
<span id="L1535"><span class="lineNum">    1535</span>              :     /* output info may be configured */</span>
<span id="L1536"><span class="lineNum">    1536</span> <span class="tlaGNC">        1944 :     result = gst_tensor_pad_possible_caps_from_config (pad, &amp;out_config);</span></span>
<span id="L1537"><span class="lineNum">    1537</span>              : </span>
<span id="L1538"><span class="lineNum">    1538</span>              :     /* Update dimension for src pad caps. */</span>
<span id="L1539"><span class="lineNum">    1539</span> <span class="tlaGNC">        1944 :     if (direction == GST_PAD_SINK) {</span></span>
<span id="L1540"><span class="lineNum">    1540</span> <span class="tlaGNC">        1085 :       GstCaps *peer = gst_pad_peer_query_caps (pad, NULL);</span></span>
<span id="L1541"><span class="lineNum">    1541</span>              : </span>
<span id="L1542"><span class="lineNum">    1542</span> <span class="tlaGNC">        1085 :       if (peer) {</span></span>
<span id="L1543"><span class="lineNum">    1543</span> <span class="tlaGNC">        1085 :         if (!gst_caps_is_any (peer))</span></span>
<span id="L1544"><span class="lineNum">    1544</span> <span class="tlaGNC">         487 :           gst_tensor_caps_update_dimension (result, peer);</span></span>
<span id="L1545"><span class="lineNum">    1545</span> <span class="tlaGNC">        1085 :         gst_caps_unref (peer);</span></span>
<span id="L1546"><span class="lineNum">    1546</span>              :       }</span>
<span id="L1547"><span class="lineNum">    1547</span>              :     }</span>
<span id="L1548"><span class="lineNum">    1548</span>              :   } else {</span>
<span id="L1549"><span class="lineNum">    1549</span>              :     /* we don't know the exact tensor info yet */</span>
<span id="L1550"><span class="lineNum">    1550</span> <span class="tlaGNC">         779 :     result = gst_caps_from_string (CAPS_STRING);</span></span>
<span id="L1551"><span class="lineNum">    1551</span>              :   }</span>
<span id="L1552"><span class="lineNum">    1552</span>              : </span>
<span id="L1553"><span class="lineNum">    1553</span> <span class="tlaGNC">        2723 :   if (filter &amp;&amp; gst_caps_get_size (filter) &gt; 0) {</span></span>
<span id="L1554"><span class="lineNum">    1554</span>              :     GstCaps *intersection;</span>
<span id="L1555"><span class="lineNum">    1555</span>              : </span>
<span id="L1556"><span class="lineNum">    1556</span>              :     /**</span>
<span id="L1557"><span class="lineNum">    1557</span>              :      * @todo We do not have a testcase hitting here. Thus, we do not ensure the validity here.</span>
<span id="L1558"><span class="lineNum">    1558</span>              :      * However, according to gstreamer doxygen entry, if filter is given, that's not to be ignored.</span>
<span id="L1559"><span class="lineNum">    1559</span>              :      * For now, we assume that if caps-size is 0, filter is &quot;ANY&quot;.</span>
<span id="L1560"><span class="lineNum">    1560</span>              :      */</span>
<span id="L1561"><span class="lineNum">    1561</span>              :     intersection =</span>
<span id="L1562"><span class="lineNum">    1562</span> <span class="tlaGNC">         527 :         gst_caps_intersect_full (result, filter, GST_CAPS_INTERSECT_FIRST);</span></span>
<span id="L1563"><span class="lineNum">    1563</span>              : </span>
<span id="L1564"><span class="lineNum">    1564</span> <span class="tlaGNC">         527 :     gst_caps_unref (result);</span></span>
<span id="L1565"><span class="lineNum">    1565</span> <span class="tlaGNC">         527 :     result = intersection;</span></span>
<span id="L1566"><span class="lineNum">    1566</span>              :   }</span>
<span id="L1567"><span class="lineNum">    1567</span>              : </span>
<span id="L1568"><span class="lineNum">    1568</span> <span class="tlaGNC">        2723 :   silent_debug_caps (self, result, &quot;to&quot;);</span></span>
<span id="L1569"><span class="lineNum">    1569</span> <span class="tlaGNC">        2723 :   gst_tensors_config_free (&amp;in_config);</span></span>
<span id="L1570"><span class="lineNum">    1570</span> <span class="tlaGNC">        2723 :   gst_tensors_config_free (&amp;out_config);</span></span>
<span id="L1571"><span class="lineNum">    1571</span> <span class="tlaGNC">        2723 :   return result;</span></span>
<span id="L1572"><span class="lineNum">    1572</span>              : }</span>
<span id="L1573"><span class="lineNum">    1573</span>              : </span>
<span id="L1574"><span class="lineNum">    1574</span>              : /**</span>
<span id="L1575"><span class="lineNum">    1575</span>              :  * @brief fixate caps. required vmethod of GstBaseTransform.</span>
<span id="L1576"><span class="lineNum">    1576</span>              :  */</span>
<span id="L1577"><span class="lineNum">    1577</span>              : static GstCaps *</span>
<span id="L1578"><span class="lineNum">    1578</span> <span class="tlaGNC">         196 : gst_tensor_filter_fixate_caps (GstBaseTransform * trans,</span></span>
<span id="L1579"><span class="lineNum">    1579</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)</span>
<span id="L1580"><span class="lineNum">    1580</span>              : {</span>
<span id="L1581"><span class="lineNum">    1581</span>              :   GstTensorFilter *self;</span>
<span id="L1582"><span class="lineNum">    1582</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1583"><span class="lineNum">    1583</span>              :   GstCaps *result;</span>
<span id="L1584"><span class="lineNum">    1584</span> <span class="tlaGNC">         196 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1585"><span class="lineNum">    1585</span> <span class="tlaGNC">         196 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1586"><span class="lineNum">    1586</span>              : </span>
<span id="L1587"><span class="lineNum">    1587</span> <span class="tlaGNC">         196 :   silent_debug (self, &quot;fixate_caps, direction = %d\n&quot;, direction);</span></span>
<span id="L1588"><span class="lineNum">    1588</span> <span class="tlaGNC">         196 :   silent_debug_caps (self, caps, &quot;caps&quot;);</span></span>
<span id="L1589"><span class="lineNum">    1589</span> <span class="tlaGNC">         196 :   silent_debug_caps (self, othercaps, &quot;othercaps&quot;);</span></span>
<span id="L1590"><span class="lineNum">    1590</span>              : </span>
<span id="L1591"><span class="lineNum">    1591</span>              :   /** Removes no-used-variable warning for priv in when DBG is set */</span>
<span id="L1592"><span class="lineNum">    1592</span> <span class="tlaGNC">         196 :   if (priv-&gt;fw == NULL) {</span></span>
<span id="L1593"><span class="lineNum">    1593</span> <span class="tlaUNC tlaBgUNC">           0 :     gst_caps_unref (othercaps);</span></span>
<span id="L1594"><span class="lineNum">    1594</span> <span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L1595"><span class="lineNum">    1595</span>              :   }</span>
<span id="L1596"><span class="lineNum">    1596</span>              : </span>
<span id="L1597"><span class="lineNum">    1597</span>              :   /**</span>
<span id="L1598"><span class="lineNum">    1598</span>              :    * To get the out-caps, GstTensorFilter has to parse tensor info from NN model.</span>
<span id="L1599"><span class="lineNum">    1599</span>              :    */</span>
<span id="L1600"><span class="lineNum">    1600</span> <span class="tlaGNC tlaBgGNC">         196 :   result = gst_tensor_filter_transform_caps (trans, direction, caps, othercaps);</span></span>
<span id="L1601"><span class="lineNum">    1601</span> <span class="tlaGNC">         196 :   gst_caps_unref (othercaps);</span></span>
<span id="L1602"><span class="lineNum">    1602</span> <span class="tlaGNC">         196 :   result = gst_caps_make_writable (result);</span></span>
<span id="L1603"><span class="lineNum">    1603</span> <span class="tlaGNC">         196 :   result = gst_caps_fixate (result);</span></span>
<span id="L1604"><span class="lineNum">    1604</span>              : </span>
<span id="L1605"><span class="lineNum">    1605</span> <span class="tlaGNC">         196 :   silent_debug_caps (self, result, &quot;result&quot;);</span></span>
<span id="L1606"><span class="lineNum">    1606</span> <span class="tlaGNC">         196 :   return result;</span></span>
<span id="L1607"><span class="lineNum">    1607</span>              : }</span>
<span id="L1608"><span class="lineNum">    1608</span>              : </span>
<span id="L1609"><span class="lineNum">    1609</span>              : /**</span>
<span id="L1610"><span class="lineNum">    1610</span>              :  * @brief set caps. required vmethod of GstBaseTransform.</span>
<span id="L1611"><span class="lineNum">    1611</span>              :  */</span>
<span id="L1612"><span class="lineNum">    1612</span>              : static gboolean</span>
<span id="L1613"><span class="lineNum">    1613</span> <span class="tlaGNC">         195 : gst_tensor_filter_set_caps (GstBaseTransform * trans,</span></span>
<span id="L1614"><span class="lineNum">    1614</span>              :     GstCaps * incaps, GstCaps * outcaps)</span>
<span id="L1615"><span class="lineNum">    1615</span>              : {</span>
<span id="L1616"><span class="lineNum">    1616</span>              :   GstTensorFilter *self;</span>
<span id="L1617"><span class="lineNum">    1617</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1618"><span class="lineNum">    1618</span>              :   GstTensorsConfig config;</span>
<span id="L1619"><span class="lineNum">    1619</span>              : </span>
<span id="L1620"><span class="lineNum">    1620</span> <span class="tlaGNC">         195 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1621"><span class="lineNum">    1621</span> <span class="tlaGNC">         195 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1622"><span class="lineNum">    1622</span>              : </span>
<span id="L1623"><span class="lineNum">    1623</span> <span class="tlaGNC">         195 :   silent_debug_caps (self, incaps, &quot;incaps&quot;);</span></span>
<span id="L1624"><span class="lineNum">    1624</span> <span class="tlaGNC">         195 :   silent_debug_caps (self, outcaps, &quot;outcaps&quot;);</span></span>
<span id="L1625"><span class="lineNum">    1625</span>              : </span>
<span id="L1626"><span class="lineNum">    1626</span> <span class="tlaGNC">         195 :   if (!gst_tensor_filter_configure_tensor (self, incaps)) {</span></span>
<span id="L1627"><span class="lineNum">    1627</span> <span class="tlaGNC">          39 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1628"><span class="lineNum">    1628</span>              :         (&quot;Failed to configure tensor. Please refer to the error log of gst_tensor_filter_configure_tensor ().&quot;));</span>
<span id="L1629"><span class="lineNum">    1629</span> <span class="tlaGNC">         195 :     return FALSE;</span></span>
<span id="L1630"><span class="lineNum">    1630</span>              :   }</span>
<span id="L1631"><span class="lineNum">    1631</span>              : </span>
<span id="L1632"><span class="lineNum">    1632</span> <span class="tlaGNC">         156 :   if (!gst_tensors_config_validate (&amp;priv-&gt;in_config)) {</span></span>
<span id="L1633"><span class="lineNum">    1633</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1634"><span class="lineNum">    1634</span>              :         (&quot;Failed to validate input tensor configuration. Please refer to the error log of gst_tensors_config_validate(): %s&quot;,</span>
<span id="L1635"><span class="lineNum">    1635</span>              :             GST_STR_NULL (_nnstreamer_error ())));</span>
<span id="L1636"><span class="lineNum">    1636</span> <span class="tlaUNC">           0 :     return FALSE;</span></span>
<span id="L1637"><span class="lineNum">    1637</span>              :   }</span>
<span id="L1638"><span class="lineNum">    1638</span>              : </span>
<span id="L1639"><span class="lineNum">    1639</span> <span class="tlaGNC tlaBgGNC">         156 :   if (!priv-&gt;prop.invoke_dynamic &amp;&amp;</span></span>
<span id="L1640"><span class="lineNum">    1640</span> <span class="tlaGNC">         154 :       !gst_tensors_config_validate (&amp;priv-&gt;out_config)) {</span></span>
<span id="L1641"><span class="lineNum">    1641</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1642"><span class="lineNum">    1642</span>              :         (&quot;Failed to validate output tensor configuration. Please refer to the error log of gst_tensors_config_validate(): %s&quot;,</span>
<span id="L1643"><span class="lineNum">    1643</span>              :             GST_STR_NULL (_nnstreamer_error ())));</span>
<span id="L1644"><span class="lineNum">    1644</span> <span class="tlaUNC">           0 :     return FALSE;</span></span>
<span id="L1645"><span class="lineNum">    1645</span>              :   }</span>
<span id="L1646"><span class="lineNum">    1646</span>              : </span>
<span id="L1647"><span class="lineNum">    1647</span>              :   /* compare output tensor */</span>
<span id="L1648"><span class="lineNum">    1648</span> <span class="tlaGNC tlaBgGNC">         156 :   if (!gst_tensors_config_from_caps (&amp;config, outcaps, TRUE)) {</span></span>
<span id="L1649"><span class="lineNum">    1649</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1650"><span class="lineNum">    1650</span>              :         (&quot;Failed to parse output tensor from caps. Please refer to the error log of gst_tensors_config_validate(): %s&quot;,</span>
<span id="L1651"><span class="lineNum">    1651</span>              :             GST_STR_NULL (_nnstreamer_error ())));</span>
<span id="L1652"><span class="lineNum">    1652</span> <span class="tlaUNC">           0 :     return FALSE;</span></span>
<span id="L1653"><span class="lineNum">    1653</span>              :   }</span>
<span id="L1654"><span class="lineNum">    1654</span>              : </span>
<span id="L1655"><span class="lineNum">    1655</span> <span class="tlaGNC tlaBgGNC">         156 :   if (gst_tensors_config_is_flexible (&amp;config)) {</span></span>
<span id="L1656"><span class="lineNum">    1656</span> <span class="tlaGNC">           4 :     GST_INFO_OBJECT (self, &quot;Output tensor is flexible.&quot;);</span></span>
<span id="L1657"><span class="lineNum">    1657</span> <span class="tlaGNC">         152 :   } else if (!gst_tensors_config_is_equal (&amp;priv-&gt;out_config, &amp;config)) {</span></span>
<span id="L1658"><span class="lineNum">    1658</span> <span class="tlaUNC tlaBgUNC">           0 :     GstTensorFilterProperties *prop = &amp;priv-&gt;prop;</span></span>
<span id="L1659"><span class="lineNum">    1659</span> <span class="tlaUNC">           0 :     gchar *compare = gst_tensors_info_compare_to_string (&amp;priv-&gt;out_config.info,</span></span>
<span id="L1660"><span class="lineNum">    1660</span>              :         &amp;config.info);</span>
<span id="L1661"><span class="lineNum">    1661</span> <span class="tlaUNC">           0 :     GST_ELEMENT_ERROR_BTRACE (self, STREAM, WRONG_TYPE,</span></span>
<span id="L1662"><span class="lineNum">    1662</span>              :         (&quot;Set-caps failed. Invalid output config (padcaps) for tensor-filter (%s:%s): its format is static, but not equal to the internal configuration: %s\nThis might be an internal error. Please report to https://github.com/nnstreamer/nnstreamer/issues .&quot;,</span>
<span id="L1663"><span class="lineNum">    1663</span>              :             GST_STR_NULL (prop-&gt;fwname), TF_MODELNAME (prop), compare));</span>
<span id="L1664"><span class="lineNum">    1664</span> <span class="tlaUNC">           0 :     g_free (compare);</span></span>
<span id="L1665"><span class="lineNum">    1665</span> <span class="tlaUNC">           0 :     return FALSE;</span></span>
<span id="L1666"><span class="lineNum">    1666</span>              :   }</span>
<span id="L1667"><span class="lineNum">    1667</span>              : </span>
<span id="L1668"><span class="lineNum">    1668</span> <span class="tlaGNC tlaBgGNC">         156 :   gst_tensors_config_free (&amp;config);</span></span>
<span id="L1669"><span class="lineNum">    1669</span>              : </span>
<span id="L1670"><span class="lineNum">    1670</span> <span class="tlaGNC">         156 :   return TRUE;</span></span>
<span id="L1671"><span class="lineNum">    1671</span>              : }</span>
<span id="L1672"><span class="lineNum">    1672</span>              : </span>
<span id="L1673"><span class="lineNum">    1673</span>              : /**</span>
<span id="L1674"><span class="lineNum">    1674</span>              :  * @brief query handling, optional vmethod of GstBaseTransform.</span>
<span id="L1675"><span class="lineNum">    1675</span>              :  */</span>
<span id="L1676"><span class="lineNum">    1676</span>              : static gboolean</span>
<span id="L1677"><span class="lineNum">    1677</span> <span class="tlaGNC">        2757 : gst_tensor_filter_query (GstBaseTransform * trans,</span></span>
<span id="L1678"><span class="lineNum">    1678</span>              :     GstPadDirection direction, GstQuery * query)</span>
<span id="L1679"><span class="lineNum">    1679</span>              : {</span>
<span id="L1680"><span class="lineNum">    1680</span>              :   GstTensorFilter *self;</span>
<span id="L1681"><span class="lineNum">    1681</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1682"><span class="lineNum">    1682</span> <span class="tlaGNC">        2757 :   gboolean res = FALSE;</span></span>
<span id="L1683"><span class="lineNum">    1683</span>              : </span>
<span id="L1684"><span class="lineNum">    1684</span>              :   UNUSED (direction);</span>
<span id="L1685"><span class="lineNum">    1685</span> <span class="tlaGNC">        2757 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1686"><span class="lineNum">    1686</span> <span class="tlaGNC">        2757 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1687"><span class="lineNum">    1687</span>              : </span>
<span id="L1688"><span class="lineNum">    1688</span> <span class="tlaGNC">        2757 :   switch (GST_QUERY_TYPE (query)) {</span></span>
<span id="L1689"><span class="lineNum">    1689</span> <span class="tlaGNC">         345 :     case GST_QUERY_LATENCY:</span></span>
<span id="L1690"><span class="lineNum">    1690</span>              :     {</span>
<span id="L1691"><span class="lineNum">    1691</span>              :       GstClockTime min, max;</span>
<span id="L1692"><span class="lineNum">    1692</span>              :       gboolean live;</span>
<span id="L1693"><span class="lineNum">    1693</span>              :       gint estimated;</span>
<span id="L1694"><span class="lineNum">    1694</span>              :       gdouble latency;</span>
<span id="L1695"><span class="lineNum">    1695</span>              : </span>
<span id="L1696"><span class="lineNum">    1696</span> <span class="tlaGNC">         345 :       GST_OBJECT_LOCK (self);</span></span>
<span id="L1697"><span class="lineNum">    1697</span> <span class="tlaGNC">         345 :       estimated = (gint) priv-&gt;prop.latency;</span></span>
<span id="L1698"><span class="lineNum">    1698</span> <span class="tlaGNC">         345 :       GST_OBJECT_UNLOCK (self);</span></span>
<span id="L1699"><span class="lineNum">    1699</span>              : </span>
<span id="L1700"><span class="lineNum">    1700</span> <span class="tlaGNC">         345 :       if ((priv-&gt;latency_reporting) &amp;&amp; (estimated &gt; 0)) {</span></span>
<span id="L1701"><span class="lineNum">    1701</span> <span class="tlaGNC">           1 :         if ((res = gst_pad_peer_query (GST_BASE_TRANSFORM (self)-&gt;sinkpad,</span></span>
<span id="L1702"><span class="lineNum">    1702</span>              :                     query))) {</span>
<span id="L1703"><span class="lineNum">    1703</span> <span class="tlaGNC">           1 :           gst_query_parse_latency (query, &amp;live, &amp;min, &amp;max);</span></span>
<span id="L1704"><span class="lineNum">    1704</span>              : </span>
<span id="L1705"><span class="lineNum">    1705</span> <span class="tlaGNC">           1 :           GST_DEBUG_OBJECT (self, &quot;Peer latency: min %&quot;</span></span>
<span id="L1706"><span class="lineNum">    1706</span>              :               GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT,</span>
<span id="L1707"><span class="lineNum">    1707</span>              :               GST_TIME_ARGS (min), GST_TIME_ARGS (max));</span>
<span id="L1708"><span class="lineNum">    1708</span>              : </span>
<span id="L1709"><span class="lineNum">    1709</span> <span class="tlaGNC">           1 :           latency = (gdouble) estimated *GST_USECOND *</span></span>
<span id="L1710"><span class="lineNum">    1710</span>              :               (1 + LATENCY_REPORT_HEADROOM);</span>
<span id="L1711"><span class="lineNum">    1711</span> <span class="tlaGNC">           1 :           priv-&gt;latency_reported = (gint64) latency;</span></span>
<span id="L1712"><span class="lineNum">    1712</span>              : </span>
<span id="L1713"><span class="lineNum">    1713</span> <span class="tlaGNC">           1 :           min += (gint64) latency;</span></span>
<span id="L1714"><span class="lineNum">    1714</span> <span class="tlaGNC">           1 :           if (max != GST_CLOCK_TIME_NONE)</span></span>
<span id="L1715"><span class="lineNum">    1715</span> <span class="tlaUNC tlaBgUNC">           0 :             max += (gint64) latency;</span></span>
<span id="L1716"><span class="lineNum">    1716</span>              : </span>
<span id="L1717"><span class="lineNum">    1717</span> <span class="tlaGNC tlaBgGNC">           1 :           GST_DEBUG_OBJECT (self, &quot;Calculated total latency : min %&quot;</span></span>
<span id="L1718"><span class="lineNum">    1718</span>              :               GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT,</span>
<span id="L1719"><span class="lineNum">    1719</span>              :               GST_TIME_ARGS (min), GST_TIME_ARGS (max));</span>
<span id="L1720"><span class="lineNum">    1720</span>              : </span>
<span id="L1721"><span class="lineNum">    1721</span> <span class="tlaGNC">           1 :           gst_query_set_latency (query, live, min, max);</span></span>
<span id="L1722"><span class="lineNum">    1722</span>              :         }</span>
<span id="L1723"><span class="lineNum">    1723</span>              :       }</span>
<span id="L1724"><span class="lineNum">    1724</span> <span class="tlaGNC">         345 :       if (!res) {</span></span>
<span id="L1725"><span class="lineNum">    1725</span>              :         res =</span>
<span id="L1726"><span class="lineNum">    1726</span> <span class="tlaGNC">         344 :             GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;query (trans, direction,</span></span>
<span id="L1727"><span class="lineNum">    1727</span>              :             query);</span>
<span id="L1728"><span class="lineNum">    1728</span>              :       }</span>
<span id="L1729"><span class="lineNum">    1729</span> <span class="tlaGNC">         345 :       break;</span></span>
<span id="L1730"><span class="lineNum">    1730</span>              :     }</span>
<span id="L1731"><span class="lineNum">    1731</span> <span class="tlaGNC">        2412 :     default:</span></span>
<span id="L1732"><span class="lineNum">    1732</span>              :       res =</span>
<span id="L1733"><span class="lineNum">    1733</span> <span class="tlaGNC">        2412 :           GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;query (trans, direction,</span></span>
<span id="L1734"><span class="lineNum">    1734</span>              :           query);</span>
<span id="L1735"><span class="lineNum">    1735</span> <span class="tlaGNC">        2412 :       break;</span></span>
<span id="L1736"><span class="lineNum">    1736</span>              :   }</span>
<span id="L1737"><span class="lineNum">    1737</span>              : </span>
<span id="L1738"><span class="lineNum">    1738</span> <span class="tlaGNC">        2757 :   return res;</span></span>
<span id="L1739"><span class="lineNum">    1739</span>              : }</span>
<span id="L1740"><span class="lineNum">    1740</span>              : </span>
<span id="L1741"><span class="lineNum">    1741</span>              : /**</span>
<span id="L1742"><span class="lineNum">    1742</span>              :  * @brief Tell the framework the required size of buffer based on the info of the other side pad. optional vmethod of BaseTransform</span>
<span id="L1743"><span class="lineNum">    1743</span>              :  *</span>
<span id="L1744"><span class="lineNum">    1744</span>              :  * We cannot directly get the value from size value, we need to review the pad-caps.</span>
<span id="L1745"><span class="lineNum">    1745</span>              :  * This is called when non-ip mode is used.</span>
<span id="L1746"><span class="lineNum">    1746</span>              :  */</span>
<span id="L1747"><span class="lineNum">    1747</span>              : static gboolean</span>
<span id="L1748"><span class="lineNum">    1748</span> <span class="tlaGNC">       22211 : gst_tensor_filter_transform_size (GstBaseTransform * trans,</span></span>
<span id="L1749"><span class="lineNum">    1749</span>              :     GstPadDirection direction, GstCaps * caps, gsize size,</span>
<span id="L1750"><span class="lineNum">    1750</span>              :     GstCaps * othercaps, gsize * othersize)</span>
<span id="L1751"><span class="lineNum">    1751</span>              : {</span>
<span id="L1752"><span class="lineNum">    1752</span>              :   GstTensorFilter *self;</span>
<span id="L1753"><span class="lineNum">    1753</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1754"><span class="lineNum">    1754</span>              :   UNUSED (direction);</span>
<span id="L1755"><span class="lineNum">    1755</span>              :   UNUSED (caps);</span>
<span id="L1756"><span class="lineNum">    1756</span>              :   UNUSED (size);</span>
<span id="L1757"><span class="lineNum">    1757</span>              :   UNUSED (othercaps);</span>
<span id="L1758"><span class="lineNum">    1758</span> <span class="tlaGNC">       22211 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1759"><span class="lineNum">    1759</span> <span class="tlaGNC">       22211 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1760"><span class="lineNum">    1760</span>              :   /** Internal Logic Error. Cannot proceed without configured pipeline */</span>
<span id="L1761"><span class="lineNum">    1761</span> <span class="tlaGNC">       22211 :   g_assert (priv-&gt;configured);</span></span>
<span id="L1762"><span class="lineNum">    1762</span>              :   /**</span>
<span id="L1763"><span class="lineNum">    1763</span>              :    * Consider multi-tensors.</span>
<span id="L1764"><span class="lineNum">    1764</span>              :    * Set each memory block in transform()</span>
<span id="L1765"><span class="lineNum">    1765</span>              :    */</span>
<span id="L1766"><span class="lineNum">    1766</span> <span class="tlaGNC">       22211 :   *othersize = 0;</span></span>
<span id="L1767"><span class="lineNum">    1767</span> <span class="tlaGNC">       22211 :   return TRUE;</span></span>
<span id="L1768"><span class="lineNum">    1768</span>              : }</span>
<span id="L1769"><span class="lineNum">    1769</span>              : </span>
<span id="L1770"><span class="lineNum">    1770</span>              : /**</span>
<span id="L1771"><span class="lineNum">    1771</span>              :  * @brief Event handler for sink pad of tensor filter.</span>
<span id="L1772"><span class="lineNum">    1772</span>              :  * @param trans &quot;this&quot; pointer</span>
<span id="L1773"><span class="lineNum">    1773</span>              :  * @param event a passed event object</span>
<span id="L1774"><span class="lineNum">    1774</span>              :  * @return TRUE if there is no error.</span>
<span id="L1775"><span class="lineNum">    1775</span>              :  */</span>
<span id="L1776"><span class="lineNum">    1776</span>              : static gboolean</span>
<span id="L1777"><span class="lineNum">    1777</span> <span class="tlaGNC">         707 : gst_tensor_filter_sink_event (GstBaseTransform * trans, GstEvent * event)</span></span>
<span id="L1778"><span class="lineNum">    1778</span>              : {</span>
<span id="L1779"><span class="lineNum">    1779</span>              :   GstTensorFilter *self;</span>
<span id="L1780"><span class="lineNum">    1780</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1781"><span class="lineNum">    1781</span> <span class="tlaGNC">         707 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1782"><span class="lineNum">    1782</span> <span class="tlaGNC">         707 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1783"><span class="lineNum">    1783</span> <span class="tlaGNC">         707 :   switch (GST_EVENT_TYPE (event)) {</span></span>
<span id="L1784"><span class="lineNum">    1784</span> <span class="tlaUNC tlaBgUNC">           0 :     case GST_EVENT_CUSTOM_DOWNSTREAM:</span></span>
<span id="L1785"><span class="lineNum">    1785</span>              :     {</span>
<span id="L1786"><span class="lineNum">    1786</span> <span class="tlaUNC">           0 :       const GstStructure *structure = gst_event_get_structure (event);</span></span>
<span id="L1787"><span class="lineNum">    1787</span> <span class="tlaUNC">           0 :       int ret = -1;</span></span>
<span id="L1788"><span class="lineNum">    1788</span> <span class="tlaUNC">           0 :       if (structure == NULL ||</span></span>
<span id="L1789"><span class="lineNum">    1789</span> <span class="tlaUNC">           0 :           !gst_structure_has_name (structure, EVENT_NAME_UPDATE_MODEL))</span></span>
<span id="L1790"><span class="lineNum">    1790</span>              :         break;</span>
<span id="L1791"><span class="lineNum">    1791</span> <span class="tlaUNC">           0 :       if (priv-&gt;is_updatable) {</span></span>
<span id="L1792"><span class="lineNum">    1792</span>              :         const GValue *value =</span>
<span id="L1793"><span class="lineNum">    1793</span> <span class="tlaUNC">           0 :             gst_structure_get_value (structure, &quot;model_files&quot;);</span></span>
<span id="L1794"><span class="lineNum">    1794</span> <span class="tlaUNC">           0 :         if (value != NULL) {</span></span>
<span id="L1795"><span class="lineNum">    1795</span> <span class="tlaUNC">           0 :           g_object_set (self, &quot;model&quot;, value, NULL);</span></span>
<span id="L1796"><span class="lineNum">    1796</span> <span class="tlaUNC">           0 :           ret = 0;</span></span>
<span id="L1797"><span class="lineNum">    1797</span>              :         }</span>
<span id="L1798"><span class="lineNum">    1798</span>              :       }</span>
<span id="L1799"><span class="lineNum">    1799</span>              : </span>
<span id="L1800"><span class="lineNum">    1800</span> <span class="tlaUNC">           0 :       gst_event_unref (event);</span></span>
<span id="L1801"><span class="lineNum">    1801</span> <span class="tlaUNC">           0 :       return (ret == 0);</span></span>
<span id="L1802"><span class="lineNum">    1802</span>              :     }</span>
<span id="L1803"><span class="lineNum">    1803</span> <span class="tlaGNC tlaBgGNC">         707 :     default:</span></span>
<span id="L1804"><span class="lineNum">    1804</span> <span class="tlaGNC">         707 :       break;</span></span>
<span id="L1805"><span class="lineNum">    1805</span>              :   }</span>
<span id="L1806"><span class="lineNum">    1806</span>              : </span>
<span id="L1807"><span class="lineNum">    1807</span>              :   /** other events are handled in the default event handler */</span>
<span id="L1808"><span class="lineNum">    1808</span> <span class="tlaGNC">         707 :   return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;sink_event (trans, event);</span></span>
<span id="L1809"><span class="lineNum">    1809</span>              : }</span>
<span id="L1810"><span class="lineNum">    1810</span>              : </span>
<span id="L1811"><span class="lineNum">    1811</span>              : /**</span>
<span id="L1812"><span class="lineNum">    1812</span>              :  * @brief Event handler for src pad of tensor filter.</span>
<span id="L1813"><span class="lineNum">    1813</span>              :  * @param trans &quot;this&quot; pointer</span>
<span id="L1814"><span class="lineNum">    1814</span>              :  * @param event a passed event object</span>
<span id="L1815"><span class="lineNum">    1815</span>              :  * @return TRUE if there is no error.</span>
<span id="L1816"><span class="lineNum">    1816</span>              :  */</span>
<span id="L1817"><span class="lineNum">    1817</span>              : static gboolean</span>
<span id="L1818"><span class="lineNum">    1818</span> <span class="tlaGNC">        2220 : gst_tensor_filter_src_event (GstBaseTransform * trans, GstEvent * event)</span></span>
<span id="L1819"><span class="lineNum">    1819</span>              : {</span>
<span id="L1820"><span class="lineNum">    1820</span> <span class="tlaGNC">        2220 :   GstTensorFilter *self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1821"><span class="lineNum">    1821</span> <span class="tlaGNC">        2220 :   switch (GST_EVENT_TYPE (event)) {</span></span>
<span id="L1822"><span class="lineNum">    1822</span> <span class="tlaGNC">        1850 :     case GST_EVENT_QOS:</span></span>
<span id="L1823"><span class="lineNum">    1823</span>              :     {</span>
<span id="L1824"><span class="lineNum">    1824</span>              :       GstQOSType type;</span>
<span id="L1825"><span class="lineNum">    1825</span>              :       GstClockTimeDiff diff;</span>
<span id="L1826"><span class="lineNum">    1826</span> <span class="tlaGNC">        1850 :       gst_event_parse_qos (event, &amp;type, NULL, &amp;diff, NULL);</span></span>
<span id="L1827"><span class="lineNum">    1827</span> <span class="tlaGNC">        1850 :       if (type == GST_QOS_TYPE_THROTTLE &amp;&amp; diff &gt; 0) {</span></span>
<span id="L1828"><span class="lineNum">    1828</span> <span class="tlaGNC">          50 :         GST_OBJECT_LOCK (trans);</span></span>
<span id="L1829"><span class="lineNum">    1829</span> <span class="tlaGNC">          50 :         if (self-&gt;throttling_delay != 0)</span></span>
<span id="L1830"><span class="lineNum">    1830</span>              :           /* set to more tight framerate */</span>
<span id="L1831"><span class="lineNum">    1831</span> <span class="tlaGNC">          49 :           self-&gt;throttling_delay = MIN (self-&gt;throttling_delay, diff);</span></span>
<span id="L1832"><span class="lineNum">    1832</span>              :         else</span>
<span id="L1833"><span class="lineNum">    1833</span> <span class="tlaGNC">           1 :           self-&gt;throttling_delay = diff;</span></span>
<span id="L1834"><span class="lineNum">    1834</span> <span class="tlaGNC">          50 :         GST_OBJECT_UNLOCK (trans);</span></span>
<span id="L1835"><span class="lineNum">    1835</span> <span class="tlaGNC">          50 :         gst_event_unref (event);</span></span>
<span id="L1836"><span class="lineNum">    1836</span>              :         /* enable the average latency profiling */</span>
<span id="L1837"><span class="lineNum">    1837</span> <span class="tlaGNC">          50 :         g_object_set (self, &quot;latency&quot;, 1, NULL);</span></span>
<span id="L1838"><span class="lineNum">    1838</span> <span class="tlaGNC">          50 :         return TRUE;</span></span>
<span id="L1839"><span class="lineNum">    1839</span>              :       }</span>
<span id="L1840"><span class="lineNum">    1840</span>              :     }</span>
<span id="L1841"><span class="lineNum">    1841</span>              :       /* fall-through */</span>
<span id="L1842"><span class="lineNum">    1842</span>              :     default:</span>
<span id="L1843"><span class="lineNum">    1843</span> <span class="tlaGNC">        2170 :       break;</span></span>
<span id="L1844"><span class="lineNum">    1844</span>              :   }</span>
<span id="L1845"><span class="lineNum">    1845</span>              : </span>
<span id="L1846"><span class="lineNum">    1846</span>              :   /** other events are handled in the default event handler */</span>
<span id="L1847"><span class="lineNum">    1847</span> <span class="tlaGNC">        2170 :   return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;src_event (trans, event);</span></span>
<span id="L1848"><span class="lineNum">    1848</span>              : }</span>
<span id="L1849"><span class="lineNum">    1849</span>              : </span>
<span id="L1850"><span class="lineNum">    1850</span>              : /**</span>
<span id="L1851"><span class="lineNum">    1851</span>              :  * @brief Called when the element starts processing. optional vmethod of BaseTransform</span>
<span id="L1852"><span class="lineNum">    1852</span>              :  * @param trans &quot;this&quot; pointer</span>
<span id="L1853"><span class="lineNum">    1853</span>              :  * @return TRUE if there is no error.</span>
<span id="L1854"><span class="lineNum">    1854</span>              :  */</span>
<span id="L1855"><span class="lineNum">    1855</span>              : static gboolean</span>
<span id="L1856"><span class="lineNum">    1856</span> <span class="tlaGNC">         296 : gst_tensor_filter_start (GstBaseTransform * trans)</span></span>
<span id="L1857"><span class="lineNum">    1857</span>              : {</span>
<span id="L1858"><span class="lineNum">    1858</span>              :   GstTensorFilter *self;</span>
<span id="L1859"><span class="lineNum">    1859</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1860"><span class="lineNum">    1860</span> <span class="tlaGNC">         296 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1861"><span class="lineNum">    1861</span> <span class="tlaGNC">         296 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1862"><span class="lineNum">    1862</span>              : </span>
<span id="L1863"><span class="lineNum">    1863</span>              :   /* If it is not configured properly, don't allow to start! */</span>
<span id="L1864"><span class="lineNum">    1864</span> <span class="tlaGNC">         296 :   if (!gst_tensor_filter_common_open_fw (priv))</span></span>
<span id="L1865"><span class="lineNum">    1865</span> <span class="tlaGNC">         108 :     return FALSE;</span></span>
<span id="L1866"><span class="lineNum">    1866</span>              : </span>
<span id="L1867"><span class="lineNum">    1867</span> <span class="tlaGNC">         188 :   if (priv-&gt;prop.suspend != 0) {</span></span>
<span id="L1868"><span class="lineNum">    1868</span> <span class="tlaGNC">           1 :     GST_OBJECT_LOCK (self);</span></span>
<span id="L1869"><span class="lineNum">    1869</span> <span class="tlaGNC">           1 :     if (!nnstreamer_watchdog_create (&amp;priv-&gt;watchdog_h)) {</span></span>
<span id="L1870"><span class="lineNum">    1870</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_logw (&quot;Failed to create watchdog. Suspend mode is not working.&quot;);</span></span>
<span id="L1871"><span class="lineNum">    1871</span> <span class="tlaGNC tlaBgGNC">           1 :     } else if (!nnstreamer_watchdog_feed (priv-&gt;watchdog_h,</span></span>
<span id="L1872"><span class="lineNum">    1872</span>              :         gst_tensor_filter_watchdog_trigger, priv-&gt;prop.suspend, priv)) {</span>
<span id="L1873"><span class="lineNum">    1873</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_logw (&quot;Failed to feed watchdog. Suspend mode is not working.&quot;);</span></span>
<span id="L1874"><span class="lineNum">    1874</span>              :     }</span>
<span id="L1875"><span class="lineNum">    1875</span> <span class="tlaGNC tlaBgGNC">           1 :     GST_OBJECT_UNLOCK (self);</span></span>
<span id="L1876"><span class="lineNum">    1876</span>              :   }</span>
<span id="L1877"><span class="lineNum">    1877</span>              : </span>
<span id="L1878"><span class="lineNum">    1878</span> <span class="tlaGNC">         188 :   gst_tensor_filter_enable_invoke_async</span></span>
<span id="L1879"><span class="lineNum">    1879</span>              :       (nnstreamer_filter_async_output_callback, &amp;priv-&gt;prop, self);</span>
<span id="L1880"><span class="lineNum">    1880</span>              : </span>
<span id="L1881"><span class="lineNum">    1881</span> <span class="tlaGNC">         188 :   return priv-&gt;prop.fw_opened;</span></span>
<span id="L1882"><span class="lineNum">    1882</span>              : }</span>
<span id="L1883"><span class="lineNum">    1883</span>              : </span>
<span id="L1884"><span class="lineNum">    1884</span>              : /**</span>
<span id="L1885"><span class="lineNum">    1885</span>              :  * @brief Called when the element stops processing. optional vmethod of BaseTransform</span>
<span id="L1886"><span class="lineNum">    1886</span>              :  * @param trans &quot;this&quot; pointer</span>
<span id="L1887"><span class="lineNum">    1887</span>              :  * @return TRUE if there is no error.</span>
<span id="L1888"><span class="lineNum">    1888</span>              :  */</span>
<span id="L1889"><span class="lineNum">    1889</span>              : static gboolean</span>
<span id="L1890"><span class="lineNum">    1890</span> <span class="tlaGNC">         177 : gst_tensor_filter_stop (GstBaseTransform * trans)</span></span>
<span id="L1891"><span class="lineNum">    1891</span>              : {</span>
<span id="L1892"><span class="lineNum">    1892</span>              :   GstTensorFilter *self;</span>
<span id="L1893"><span class="lineNum">    1893</span>              :   GstTensorFilterPrivate *priv;</span>
<span id="L1894"><span class="lineNum">    1894</span> <span class="tlaGNC">         177 :   self = GST_TENSOR_FILTER_CAST (trans);</span></span>
<span id="L1895"><span class="lineNum">    1895</span> <span class="tlaGNC">         177 :   priv = &amp;self-&gt;priv;</span></span>
<span id="L1896"><span class="lineNum">    1896</span>              : </span>
<span id="L1897"><span class="lineNum">    1897</span> <span class="tlaGNC">         177 :   if (priv-&gt;prop.suspend != 0) {</span></span>
<span id="L1898"><span class="lineNum">    1898</span> <span class="tlaGNC">           1 :     GST_OBJECT_LOCK (self);</span></span>
<span id="L1899"><span class="lineNum">    1899</span> <span class="tlaGNC">           1 :     nnstreamer_watchdog_destroy (priv-&gt;watchdog_h);</span></span>
<span id="L1900"><span class="lineNum">    1900</span> <span class="tlaGNC">           1 :     priv-&gt;watchdog_h = NULL;</span></span>
<span id="L1901"><span class="lineNum">    1901</span> <span class="tlaGNC">           1 :     GST_OBJECT_UNLOCK (self);</span></span>
<span id="L1902"><span class="lineNum">    1902</span>              :   }</span>
<span id="L1903"><span class="lineNum">    1903</span>              : </span>
<span id="L1904"><span class="lineNum">    1904</span> <span class="tlaGNC">         177 :   gst_tensor_filter_disable_invoke_async (&amp;priv-&gt;prop);</span></span>
<span id="L1905"><span class="lineNum">    1905</span> <span class="tlaGNC">         177 :   gst_tensor_filter_common_close_fw (priv);</span></span>
<span id="L1906"><span class="lineNum">    1906</span>              : </span>
<span id="L1907"><span class="lineNum">    1907</span> <span class="tlaGNC">         177 :   return TRUE;</span></span>
<span id="L1908"><span class="lineNum">    1908</span>              : }</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>

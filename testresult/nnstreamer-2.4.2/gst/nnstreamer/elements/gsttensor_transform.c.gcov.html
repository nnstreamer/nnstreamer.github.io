<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - nnstreamer 2.4.2-0 nnstreamer/nnstreamer#089da04449a4934859581d1323e7626ecd600185 - nnstreamer-2.4.2/gst/nnstreamer/elements/gsttensor_transform.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">nnstreamer-2.4.2/gst/nnstreamer/elements</a> - gsttensor_transform.c<span style="font-size: 80%;"> (source / <a href="gsttensor_transform.c.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">nnstreamer 2.4.2-0 nnstreamer/nnstreamer#089da04449a4934859581d1323e7626ecd600185</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryMed">87.8&nbsp;%</td>
            <td class="headerCovTableEntry">935</td>
            <td class="headerCovTableEntry">821</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-03-31 05:37:27</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">96.3&nbsp;%</td>
            <td class="headerCovTableEntry">27</td>
            <td class="headerCovTableEntry">26</td>
          </tr>
                  <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /**</span>
<span id="L2"><span class="lineNum">       2</span>              :  * GStreamer</span>
<span id="L3"><span class="lineNum">       3</span>              :  * Copyright (C) 2005 Thomas Vander Stichele &lt;thomas@apestaart.org&gt;</span>
<span id="L4"><span class="lineNum">       4</span>              :  * Copyright (C) 2005 Ronald S. Bultje &lt;rbultje@ronald.bitfreak.net&gt;</span>
<span id="L5"><span class="lineNum">       5</span>              :  * Copyright (C) 2018 MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;</span>
<span id="L6"><span class="lineNum">       6</span>              :  *</span>
<span id="L7"><span class="lineNum">       7</span>              :  * This library is free software; you can redistribute it and/or</span>
<span id="L8"><span class="lineNum">       8</span>              :  * modify it under the terms of the GNU Library General Public</span>
<span id="L9"><span class="lineNum">       9</span>              :  * License as published by the Free Software Foundation;</span>
<span id="L10"><span class="lineNum">      10</span>              :  * version 2.1 of the License.</span>
<span id="L11"><span class="lineNum">      11</span>              :  *</span>
<span id="L12"><span class="lineNum">      12</span>              :  * This library is distributed in the hope that it will be useful,</span>
<span id="L13"><span class="lineNum">      13</span>              :  * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span id="L14"><span class="lineNum">      14</span>              :  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span id="L15"><span class="lineNum">      15</span>              :  * Library General Public License for more details.</span>
<span id="L16"><span class="lineNum">      16</span>              :  *</span>
<span id="L17"><span class="lineNum">      17</span>              :  */</span>
<span id="L18"><span class="lineNum">      18</span>              : /**</span>
<span id="L19"><span class="lineNum">      19</span>              :  * @file        gsttensor_transform.c</span>
<span id="L20"><span class="lineNum">      20</span>              :  * @date        10 Jul 2018</span>
<span id="L21"><span class="lineNum">      21</span>              :  * @brief       GStreamer plugin to transform tensor dimension or type</span>
<span id="L22"><span class="lineNum">      22</span>              :  * @see         https://github.com/nnstreamer/nnstreamer</span>
<span id="L23"><span class="lineNum">      23</span>              :  * @author      MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;</span>
<span id="L24"><span class="lineNum">      24</span>              :  * @bug         This is NYI.</span>
<span id="L25"><span class="lineNum">      25</span>              :  *</span>
<span id="L26"><span class="lineNum">      26</span>              :  */</span>
<span id="L27"><span class="lineNum">      27</span>              : </span>
<span id="L28"><span class="lineNum">      28</span>              : /**</span>
<span id="L29"><span class="lineNum">      29</span>              :  * SECTION:element-tensor_transform</span>
<span id="L30"><span class="lineNum">      30</span>              :  *</span>
<span id="L31"><span class="lineNum">      31</span>              :  * A filter that transforms tensors dimension or type.</span>
<span id="L32"><span class="lineNum">      32</span>              :  * The input and output is always in the format of other/tensor or other/tensors.</span>
<span id="L33"><span class="lineNum">      33</span>              :  *</span>
<span id="L34"><span class="lineNum">      34</span>              :  * &lt;refsect2&gt;</span>
<span id="L35"><span class="lineNum">      35</span>              :  * &lt;title&gt;Example launch line&lt;/title&gt;</span>
<span id="L36"><span class="lineNum">      36</span>              :  * |[</span>
<span id="L37"><span class="lineNum">      37</span>              :  * gst-launch -v -m fakesrc ! tensor_converter ! tensor_transform mode=dimchg option=0:2 ! fakesink silent=TRUE</span>
<span id="L38"><span class="lineNum">      38</span>              :  * ]|</span>
<span id="L39"><span class="lineNum">      39</span>              :  * &lt;title&gt;How to use dimchg&lt;/title&gt;</span>
<span id="L40"><span class="lineNum">      40</span>              :  * |[</span>
<span id="L41"><span class="lineNum">      41</span>              :  * option=0:2 # Move 0th dim to 2nd dim. I.e., [a][H][W][C] ==&gt; [a][C][H][W]</span>
<span id="L42"><span class="lineNum">      42</span>              :  * ]|</span>
<span id="L43"><span class="lineNum">      43</span>              :  * &lt;/refsect2&gt;</span>
<span id="L44"><span class="lineNum">      44</span>              :  */</span>
<span id="L45"><span class="lineNum">      45</span>              : </span>
<span id="L46"><span class="lineNum">      46</span>              : #ifdef HAVE_CONFIG_H</span>
<span id="L47"><span class="lineNum">      47</span>              : #include &lt;config.h&gt;</span>
<span id="L48"><span class="lineNum">      48</span>              : #endif</span>
<span id="L49"><span class="lineNum">      49</span>              : </span>
<span id="L50"><span class="lineNum">      50</span>              : #include &lt;string.h&gt;</span>
<span id="L51"><span class="lineNum">      51</span>              : #include &lt;math.h&gt;</span>
<span id="L52"><span class="lineNum">      52</span>              : #include &lt;nnstreamer_log.h&gt;</span>
<span id="L53"><span class="lineNum">      53</span>              : #include &lt;nnstreamer_util.h&gt;</span>
<span id="L54"><span class="lineNum">      54</span>              : #include &quot;gsttensor_transform.h&quot;</span>
<span id="L55"><span class="lineNum">      55</span>              : </span>
<span id="L56"><span class="lineNum">      56</span>              : #ifdef HAVE_ORC</span>
<span id="L57"><span class="lineNum">      57</span>              : #include &quot;nnstreamer-orc.h&quot;</span>
<span id="L58"><span class="lineNum">      58</span>              : #endif</span>
<span id="L59"><span class="lineNum">      59</span>              : </span>
<span id="L60"><span class="lineNum">      60</span>              : /**</span>
<span id="L61"><span class="lineNum">      61</span>              :  * @brief Macro for debug mode.</span>
<span id="L62"><span class="lineNum">      62</span>              :  */</span>
<span id="L63"><span class="lineNum">      63</span>              : #ifndef DBG</span>
<span id="L64"><span class="lineNum">      64</span>              : #define DBG (!filter-&gt;silent)</span>
<span id="L65"><span class="lineNum">      65</span>              : #endif</span>
<span id="L66"><span class="lineNum">      66</span>              : </span>
<span id="L67"><span class="lineNum">      67</span>              : GST_DEBUG_CATEGORY_STATIC (gst_tensor_transform_debug);</span>
<span id="L68"><span class="lineNum">      68</span>              : #define GST_CAT_DEFAULT gst_tensor_transform_debug</span>
<span id="L69"><span class="lineNum">      69</span>              : #define CAPS_STRING GST_TENSOR_CAP_DEFAULT &quot;;&quot; GST_TENSORS_CAP_MAKE (&quot;{ static, flexible }&quot;)</span>
<span id="L70"><span class="lineNum">      70</span>              : #define REGEX_DIMCHG_OPTION &quot;^([0-9]|1[0-5]):([0-9]|1[0-5])$&quot;</span>
<span id="L71"><span class="lineNum">      71</span>              : #define REGEX_TYPECAST_OPTION &quot;(^[u]?int(8|16|32|64)$|^float(16|32|64)$)&quot;</span>
<span id="L72"><span class="lineNum">      72</span>              : #define REGEX_TRANSPOSE_OPTION &quot;^(?:([0-2]):(?!.*\\1)){3}3$&quot;</span>
<span id="L73"><span class="lineNum">      73</span>              : #define REGEX_STAND_OPTION &quot;^(default|dc-average)(:([u]?int(8|16|32|64)|float(16|32|64)))?(,per-channel:(true|false))?$&quot;</span>
<span id="L74"><span class="lineNum">      74</span>              : #define REGEX_CLAMP_OPTION &quot;^((([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?))):&quot;\</span>
<span id="L75"><span class="lineNum">      75</span>              :     &quot;((([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)))$&quot;</span>
<span id="L76"><span class="lineNum">      76</span>              : #define REGEX_PADDING_OPTION &quot;^((left|right|top|bottom|front|back):(\\d)(,)?)+(layout:(NCHW|NHWC))?$&quot;</span>
<span id="L77"><span class="lineNum">      77</span>              : #define REGEX_ARITH_OPTION &quot;^(typecast:([u]?int(8|16|32|64)|float(16|32|64)),)?&quot;\</span>
<span id="L78"><span class="lineNum">      78</span>              :     &quot;(per-channel:(false|true@[0-9]+),)?&quot;\</span>
<span id="L79"><span class="lineNum">      79</span>              :     &quot;(((add|mul|div)(:([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?))+(@[0-9]+)?)(,|))+$&quot;</span>
<span id="L80"><span class="lineNum">      80</span>              : </span>
<span id="L81"><span class="lineNum">      81</span>              : #define REGEX_ARITH_OPTION_TYPECAST &quot;(typecast:([u]?int(8|16|32|64)|float(16|32|64)))&quot;</span>
<span id="L82"><span class="lineNum">      82</span>              : </span>
<span id="L83"><span class="lineNum">      83</span>              : /**</span>
<span id="L84"><span class="lineNum">      84</span>              :  * @brief The transpose rank is fixed to 4.</span>
<span id="L85"><span class="lineNum">      85</span>              :  * This RANK does not affect other/tensors(s)'s NNS_TENSOR_RANK_LIMIT.</span>
<span id="L86"><span class="lineNum">      86</span>              :  */</span>
<span id="L87"><span class="lineNum">      87</span>              : #define NNS_TENSOR_TRANSPOSE_RANK_LIMIT (4)</span>
<span id="L88"><span class="lineNum">      88</span>              : </span>
<span id="L89"><span class="lineNum">      89</span>              : /**</span>
<span id="L90"><span class="lineNum">      90</span>              :  * @brief The padding rank is fixed to 3.</span>
<span id="L91"><span class="lineNum">      91</span>              :  * This RANK does not affect other/tensors(s)'s NNS_TENSOR_RANK_LIMIT.</span>
<span id="L92"><span class="lineNum">      92</span>              :  */</span>
<span id="L93"><span class="lineNum">      93</span>              : #define NNS_TENSOR_PADDING_RANK_LIMIT (3)</span>
<span id="L94"><span class="lineNum">      94</span>              : </span>
<span id="L95"><span class="lineNum">      95</span>              : /**</span>
<span id="L96"><span class="lineNum">      96</span>              :  * @brief tensor_transform properties</span>
<span id="L97"><span class="lineNum">      97</span>              :  */</span>
<span id="L98"><span class="lineNum">      98</span>              : enum</span>
<span id="L99"><span class="lineNum">      99</span>              : {</span>
<span id="L100"><span class="lineNum">     100</span>              :   PROP_0,</span>
<span id="L101"><span class="lineNum">     101</span>              :   PROP_SILENT,</span>
<span id="L102"><span class="lineNum">     102</span>              :   PROP_MODE,</span>
<span id="L103"><span class="lineNum">     103</span>              :   PROP_OPTION,</span>
<span id="L104"><span class="lineNum">     104</span>              :   PROP_ACCELERATION,</span>
<span id="L105"><span class="lineNum">     105</span>              :   PROP_APPLY,</span>
<span id="L106"><span class="lineNum">     106</span>              :   PROP_TRANSPOSE_RANK_LIMIT</span>
<span id="L107"><span class="lineNum">     107</span>              : };</span>
<span id="L108"><span class="lineNum">     108</span>              : </span>
<span id="L109"><span class="lineNum">     109</span>              : /**</span>
<span id="L110"><span class="lineNum">     110</span>              :  * @brief Flag to set orc acceleration.</span>
<span id="L111"><span class="lineNum">     111</span>              :  */</span>
<span id="L112"><span class="lineNum">     112</span>              : #ifdef HAVE_ORC</span>
<span id="L113"><span class="lineNum">     113</span>              : #define DEFAULT_ACCELERATION TRUE</span>
<span id="L114"><span class="lineNum">     114</span>              : #else</span>
<span id="L115"><span class="lineNum">     115</span>              : #define DEFAULT_ACCELERATION FALSE</span>
<span id="L116"><span class="lineNum">     116</span>              : #endif</span>
<span id="L117"><span class="lineNum">     117</span>              : </span>
<span id="L118"><span class="lineNum">     118</span>              : static const gchar *gst_tensor_transform_stand_string[] = {</span>
<span id="L119"><span class="lineNum">     119</span>              :   [STAND_DEFAULT] = &quot;default&quot;,</span>
<span id="L120"><span class="lineNum">     120</span>              :   [STAND_DC_AVERAGE] = &quot;dc-average&quot;,</span>
<span id="L121"><span class="lineNum">     121</span>              :   [STAND_END] = NULL</span>
<span id="L122"><span class="lineNum">     122</span>              : };</span>
<span id="L123"><span class="lineNum">     123</span>              : </span>
<span id="L124"><span class="lineNum">     124</span>              : static const gchar *gst_tensor_transform_operator_string[] = {</span>
<span id="L125"><span class="lineNum">     125</span>              :   [GTT_OP_TYPECAST] = &quot;typecast&quot;,</span>
<span id="L126"><span class="lineNum">     126</span>              :   [GTT_OP_ADD] = &quot;add&quot;,</span>
<span id="L127"><span class="lineNum">     127</span>              :   [GTT_OP_MUL] = &quot;mul&quot;,</span>
<span id="L128"><span class="lineNum">     128</span>              :   [GTT_OP_DIV] = &quot;div&quot;,</span>
<span id="L129"><span class="lineNum">     129</span>              :   [GTT_OP_UNKNOWN] = NULL</span>
<span id="L130"><span class="lineNum">     130</span>              : };</span>
<span id="L131"><span class="lineNum">     131</span>              : </span>
<span id="L132"><span class="lineNum">     132</span>              : /**</span>
<span id="L133"><span class="lineNum">     133</span>              :  * @brief The capabilities of the inputs</span>
<span id="L134"><span class="lineNum">     134</span>              :  */</span>
<span id="L135"><span class="lineNum">     135</span>              : static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,</span>
<span id="L136"><span class="lineNum">     136</span>              :     GST_PAD_SINK,</span>
<span id="L137"><span class="lineNum">     137</span>              :     GST_PAD_ALWAYS,</span>
<span id="L138"><span class="lineNum">     138</span>              :     GST_STATIC_CAPS (CAPS_STRING));</span>
<span id="L139"><span class="lineNum">     139</span>              : </span>
<span id="L140"><span class="lineNum">     140</span>              : /**</span>
<span id="L141"><span class="lineNum">     141</span>              :  * @brief The capabilities of the outputs</span>
<span id="L142"><span class="lineNum">     142</span>              :  */</span>
<span id="L143"><span class="lineNum">     143</span>              : static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,</span>
<span id="L144"><span class="lineNum">     144</span>              :     GST_PAD_SRC,</span>
<span id="L145"><span class="lineNum">     145</span>              :     GST_PAD_ALWAYS,</span>
<span id="L146"><span class="lineNum">     146</span>              :     GST_STATIC_CAPS (CAPS_STRING));</span>
<span id="L147"><span class="lineNum">     147</span>              : </span>
<span id="L148"><span class="lineNum">     148</span>              : #define gst_tensor_transform_parent_class parent_class</span>
<span id="L149"><span class="lineNum">     149</span> <span class="tlaGNC tlaBgGNC">        1809 : G_DEFINE_TYPE (GstTensorTransform, gst_tensor_transform,</span></span>
<span id="L150"><span class="lineNum">     150</span>              :     GST_TYPE_BASE_TRANSFORM);</span>
<span id="L151"><span class="lineNum">     151</span>              : </span>
<span id="L152"><span class="lineNum">     152</span>              : /* GObject vmethod implementations */</span>
<span id="L153"><span class="lineNum">     153</span>              : static void gst_tensor_transform_set_property (GObject * object, guint prop_id,</span>
<span id="L154"><span class="lineNum">     154</span>              :     const GValue * value, GParamSpec * pspec);</span>
<span id="L155"><span class="lineNum">     155</span>              : static void gst_tensor_transform_get_property (GObject * object, guint prop_id,</span>
<span id="L156"><span class="lineNum">     156</span>              :     GValue * value, GParamSpec * pspec);</span>
<span id="L157"><span class="lineNum">     157</span>              : static void gst_tensor_transform_finalize (GObject * object);</span>
<span id="L158"><span class="lineNum">     158</span>              : </span>
<span id="L159"><span class="lineNum">     159</span>              : /* GstBaseTransformer vmethod implementations */</span>
<span id="L160"><span class="lineNum">     160</span>              : static GstFlowReturn gst_tensor_transform_transform (GstBaseTransform * trans,</span>
<span id="L161"><span class="lineNum">     161</span>              :     GstBuffer * inbuf, GstBuffer * outbuf);</span>
<span id="L162"><span class="lineNum">     162</span>              : static GstCaps *gst_tensor_transform_transform_caps (GstBaseTransform * trans,</span>
<span id="L163"><span class="lineNum">     163</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * filter);</span>
<span id="L164"><span class="lineNum">     164</span>              : static GstCaps *gst_tensor_transform_fixate_caps (GstBaseTransform * trans,</span>
<span id="L165"><span class="lineNum">     165</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);</span>
<span id="L166"><span class="lineNum">     166</span>              : static gboolean gst_tensor_transform_set_caps (GstBaseTransform * trans,</span>
<span id="L167"><span class="lineNum">     167</span>              :     GstCaps * incaps, GstCaps * outcaps);</span>
<span id="L168"><span class="lineNum">     168</span>              : static gboolean gst_tensor_transform_transform_size (GstBaseTransform * trans,</span>
<span id="L169"><span class="lineNum">     169</span>              :     GstPadDirection direction, GstCaps * caps, gsize size,</span>
<span id="L170"><span class="lineNum">     170</span>              :     GstCaps * othercaps, gsize * othersize);</span>
<span id="L171"><span class="lineNum">     171</span>              : </span>
<span id="L172"><span class="lineNum">     172</span>              : static gboolean gst_tensor_transform_convert_dimension (GstTensorTransform *</span>
<span id="L173"><span class="lineNum">     173</span>              :     filter, GstPadDirection direction, guint idx, const GstTensorInfo * in_info,</span>
<span id="L174"><span class="lineNum">     174</span>              :     GstTensorInfo * out_info);</span>
<span id="L175"><span class="lineNum">     175</span>              : </span>
<span id="L176"><span class="lineNum">     176</span>              : #define GST_TYPE_TENSOR_TRANSFORM_MODE (gst_tensor_transform_mode_get_type ())</span>
<span id="L177"><span class="lineNum">     177</span>              : /**</span>
<span id="L178"><span class="lineNum">     178</span>              :  * @brief A private function to register GEnumValue array for the 'mode' property</span>
<span id="L179"><span class="lineNum">     179</span>              :  *        to a GType and return it</span>
<span id="L180"><span class="lineNum">     180</span>              :  */</span>
<span id="L181"><span class="lineNum">     181</span>              : static GType</span>
<span id="L182"><span class="lineNum">     182</span> <span class="tlaGNC">          95 : gst_tensor_transform_mode_get_type (void)</span></span>
<span id="L183"><span class="lineNum">     183</span>              : {</span>
<span id="L184"><span class="lineNum">     184</span>              :   static GType mode_type = 0;</span>
<span id="L185"><span class="lineNum">     185</span>              : </span>
<span id="L186"><span class="lineNum">     186</span> <span class="tlaGNC">          95 :   if (mode_type == 0) {</span></span>
<span id="L187"><span class="lineNum">     187</span>              :     static GEnumValue mode_types[] = {</span>
<span id="L188"><span class="lineNum">     188</span>              :       {GTT_DIMCHG, &quot;Mode for changing tensor dimensions, &quot;</span>
<span id="L189"><span class="lineNum">     189</span>              :             &quot;option=FROM_DIM:TO_DIM (with a regex, &quot; REGEX_DIMCHG_OPTION</span>
<span id="L190"><span class="lineNum">     190</span>              :             &quot;, where NNS_TENSOR_RANK_LIMIT is 16)&quot;,</span>
<span id="L191"><span class="lineNum">     191</span>              :           &quot;dimchg&quot;},</span>
<span id="L192"><span class="lineNum">     192</span>              :       {GTT_TYPECAST, &quot;Mode for casting type of tensor, &quot;</span>
<span id="L193"><span class="lineNum">     193</span>              :             &quot;option=&quot; REGEX_TYPECAST_OPTION, &quot;typecast&quot;},</span>
<span id="L194"><span class="lineNum">     194</span>              :       {GTT_ARITHMETIC, &quot;Mode for arithmetic operations with tensor, &quot;</span>
<span id="L195"><span class="lineNum">     195</span>              :             &quot;option=[typecast:TYPE,][per-channel:(false|true@DIM),]add|mul|div:NUMBER[@CH_IDX], ...&quot;,</span>
<span id="L196"><span class="lineNum">     196</span>              :           &quot;arithmetic&quot;},</span>
<span id="L197"><span class="lineNum">     197</span>              :       {GTT_TRANSPOSE, &quot;Mode for transposing shape of tensor, &quot;</span>
<span id="L198"><span class="lineNum">     198</span>              :             &quot;option=D1\':D2\':D3\':D4 (fixed to 3)&quot;,</span>
<span id="L199"><span class="lineNum">     199</span>              :           &quot;transpose&quot;},</span>
<span id="L200"><span class="lineNum">     200</span>              :       {GTT_STAND, &quot;Mode for statistical standardization of tensor, &quot;</span>
<span id="L201"><span class="lineNum">     201</span>              :             &quot;option=(default|dc-average)[:TYPE][,per-channel:(false|true)]&quot;,</span>
<span id="L202"><span class="lineNum">     202</span>              :           &quot;stand&quot;},</span>
<span id="L203"><span class="lineNum">     203</span>              :       {GTT_CLAMP, &quot;Mode for clamping all elements of tensor into the range, &quot;</span>
<span id="L204"><span class="lineNum">     204</span>              :             &quot;option=CLAMP_MIN:CLAMP_MAX&quot;,</span>
<span id="L205"><span class="lineNum">     205</span>              :           &quot;clamp&quot;},</span>
<span id="L206"><span class="lineNum">     206</span>              :       {GTT_PADDING, &quot;Mode for padding of tensor, &quot;</span>
<span id="L207"><span class="lineNum">     207</span>              :             &quot;option=left|right|top|bottom|front|back:NUMBER[,layout:(NCHW|NHWC)]&quot;,</span>
<span id="L208"><span class="lineNum">     208</span>              :           &quot;padding&quot;},</span>
<span id="L209"><span class="lineNum">     209</span>              :       {GTT_UNKNOWN, &quot;Unknown or not-implemented-yet mode&quot;,</span>
<span id="L210"><span class="lineNum">     210</span>              :           &quot;unknown&quot;},</span>
<span id="L211"><span class="lineNum">     211</span>              :       {0, NULL, NULL},</span>
<span id="L212"><span class="lineNum">     212</span>              :     };</span>
<span id="L213"><span class="lineNum">     213</span>              : </span>
<span id="L214"><span class="lineNum">     214</span> <span class="tlaGNC">          95 :     mode_type = g_enum_register_static (&quot;gtt_mode_type&quot;, mode_types);</span></span>
<span id="L215"><span class="lineNum">     215</span>              :   }</span>
<span id="L216"><span class="lineNum">     216</span>              : </span>
<span id="L217"><span class="lineNum">     217</span> <span class="tlaGNC">          95 :   return mode_type;</span></span>
<span id="L218"><span class="lineNum">     218</span>              : }</span>
<span id="L219"><span class="lineNum">     219</span>              : </span>
<span id="L220"><span class="lineNum">     220</span>              : /**</span>
<span id="L221"><span class="lineNum">     221</span>              :  * @brief initialize the tensor_transform's class</span>
<span id="L222"><span class="lineNum">     222</span>              :  */</span>
<span id="L223"><span class="lineNum">     223</span>              : static void</span>
<span id="L224"><span class="lineNum">     224</span> <span class="tlaGNC">          95 : gst_tensor_transform_class_init (GstTensorTransformClass * klass)</span></span>
<span id="L225"><span class="lineNum">     225</span>              : {</span>
<span id="L226"><span class="lineNum">     226</span>              :   GObjectClass *gobject_class;</span>
<span id="L227"><span class="lineNum">     227</span>              :   GstElementClass *gstelement_class;</span>
<span id="L228"><span class="lineNum">     228</span>              :   GstBaseTransformClass *trans_class;</span>
<span id="L229"><span class="lineNum">     229</span>              : </span>
<span id="L230"><span class="lineNum">     230</span> <span class="tlaGNC">          95 :   GST_DEBUG_CATEGORY_INIT (gst_tensor_transform_debug, &quot;tensor_transform&quot;, 0,</span></span>
<span id="L231"><span class="lineNum">     231</span>              :       &quot;Element to transforms tensor dimension or type&quot;);</span>
<span id="L232"><span class="lineNum">     232</span>              : </span>
<span id="L233"><span class="lineNum">     233</span> <span class="tlaGNC">          95 :   trans_class = (GstBaseTransformClass *) klass;</span></span>
<span id="L234"><span class="lineNum">     234</span> <span class="tlaGNC">          95 :   gstelement_class = (GstElementClass *) trans_class;</span></span>
<span id="L235"><span class="lineNum">     235</span> <span class="tlaGNC">          95 :   gobject_class = (GObjectClass *) gstelement_class;</span></span>
<span id="L236"><span class="lineNum">     236</span>              : </span>
<span id="L237"><span class="lineNum">     237</span> <span class="tlaGNC">          95 :   gobject_class-&gt;set_property = gst_tensor_transform_set_property;</span></span>
<span id="L238"><span class="lineNum">     238</span> <span class="tlaGNC">          95 :   gobject_class-&gt;get_property = gst_tensor_transform_get_property;</span></span>
<span id="L239"><span class="lineNum">     239</span> <span class="tlaGNC">          95 :   gobject_class-&gt;finalize = gst_tensor_transform_finalize;</span></span>
<span id="L240"><span class="lineNum">     240</span>              : </span>
<span id="L241"><span class="lineNum">     241</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_SILENT,</span></span>
<span id="L242"><span class="lineNum">     242</span>              :       g_param_spec_boolean (&quot;silent&quot;, &quot;Silent&quot;, &quot;Produce verbose output ?&quot;,</span>
<span id="L243"><span class="lineNum">     243</span>              :           FALSE, G_PARAM_READWRITE));</span>
<span id="L244"><span class="lineNum">     244</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_MODE,</span></span>
<span id="L245"><span class="lineNum">     245</span>              :       g_param_spec_enum (&quot;mode&quot;, &quot;Mode&quot;, &quot;Mode used for transforming tensor&quot;,</span>
<span id="L246"><span class="lineNum">     246</span>              :           GST_TYPE_TENSOR_TRANSFORM_MODE, GTT_UNKNOWN,</span>
<span id="L247"><span class="lineNum">     247</span>              :           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span>
<span id="L248"><span class="lineNum">     248</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_OPTION,</span></span>
<span id="L249"><span class="lineNum">     249</span>              :       g_param_spec_string (&quot;option&quot;, &quot;Option&quot;,</span>
<span id="L250"><span class="lineNum">     250</span>              :           &quot;Option for the tensor transform mode ?&quot;, &quot;&quot;, G_PARAM_READWRITE));</span>
<span id="L251"><span class="lineNum">     251</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_ACCELERATION,</span></span>
<span id="L252"><span class="lineNum">     252</span>              :       g_param_spec_boolean (&quot;acceleration&quot;, &quot;Acceleration&quot;, &quot;Orc acceleration&quot;,</span>
<span id="L253"><span class="lineNum">     253</span>              :           DEFAULT_ACCELERATION, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span>
<span id="L254"><span class="lineNum">     254</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_APPLY,</span></span>
<span id="L255"><span class="lineNum">     255</span>              :       g_param_spec_string (&quot;apply&quot;, &quot;Apply&quot;, &quot;Select tensors to apply, &quot;</span>
<span id="L256"><span class="lineNum">     256</span>              :           &quot;separated with ',' in case of multiple tensors. Default to apply all tensors.&quot;,</span>
<span id="L257"><span class="lineNum">     257</span>              :           &quot;&quot;, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));</span>
<span id="L258"><span class="lineNum">     258</span> <span class="tlaGNC">          95 :   g_object_class_install_property (gobject_class, PROP_TRANSPOSE_RANK_LIMIT,</span></span>
<span id="L259"><span class="lineNum">     259</span>              :       g_param_spec_uint (&quot;transpose-rank-limit&quot;, &quot;Transpose rank limit&quot;,</span>
<span id="L260"><span class="lineNum">     260</span>              :           &quot;The rank limit of transpose, which varies per version of nnstreamer and may be lower than the global rank limit if it is over 4.&quot;,</span>
<span id="L261"><span class="lineNum">     261</span>              :           0, NNS_TENSOR_RANK_LIMIT, NNS_TENSOR_TRANSPOSE_RANK_LIMIT,</span>
<span id="L262"><span class="lineNum">     262</span>              :           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));</span>
<span id="L263"><span class="lineNum">     263</span>              : </span>
<span id="L264"><span class="lineNum">     264</span> <span class="tlaGNC">          95 :   gst_element_class_set_details_simple (gstelement_class,</span></span>
<span id="L265"><span class="lineNum">     265</span>              :       &quot;TensorTransform&quot;,</span>
<span id="L266"><span class="lineNum">     266</span>              :       &quot;Filter/Tensor&quot;,</span>
<span id="L267"><span class="lineNum">     267</span>              :       &quot;Transforms other/tensor dimensions for different models or frameworks&quot;,</span>
<span id="L268"><span class="lineNum">     268</span>              :       &quot;MyungJoo Ham &lt;myungjoo.ham@samsung.com&gt;&quot;);</span>
<span id="L269"><span class="lineNum">     269</span>              : </span>
<span id="L270"><span class="lineNum">     270</span> <span class="tlaGNC">          95 :   gst_element_class_add_pad_template (gstelement_class,</span></span>
<span id="L271"><span class="lineNum">     271</span>              :       gst_static_pad_template_get (&amp;src_factory));</span>
<span id="L272"><span class="lineNum">     272</span> <span class="tlaGNC">          95 :   gst_element_class_add_pad_template (gstelement_class,</span></span>
<span id="L273"><span class="lineNum">     273</span>              :       gst_static_pad_template_get (&amp;sink_factory));</span>
<span id="L274"><span class="lineNum">     274</span>              :   /* Refer: https://gstreamer.freedesktop.org/documentation/design/element-transform.html */</span>
<span id="L275"><span class="lineNum">     275</span> <span class="tlaGNC">          95 :   trans_class-&gt;passthrough_on_same_caps = FALSE;</span></span>
<span id="L276"><span class="lineNum">     276</span>              : </span>
<span id="L277"><span class="lineNum">     277</span>              :   /* Processing units */</span>
<span id="L278"><span class="lineNum">     278</span> <span class="tlaGNC">          95 :   trans_class-&gt;transform = GST_DEBUG_FUNCPTR (gst_tensor_transform_transform);</span></span>
<span id="L279"><span class="lineNum">     279</span>              : </span>
<span id="L280"><span class="lineNum">     280</span>              :   /* Negotiation units */</span>
<span id="L281"><span class="lineNum">     281</span> <span class="tlaGNC">          95 :   trans_class-&gt;transform_caps =</span></span>
<span id="L282"><span class="lineNum">     282</span> <span class="tlaGNC">          95 :       GST_DEBUG_FUNCPTR (gst_tensor_transform_transform_caps);</span></span>
<span id="L283"><span class="lineNum">     283</span> <span class="tlaGNC">          95 :   trans_class-&gt;fixate_caps =</span></span>
<span id="L284"><span class="lineNum">     284</span> <span class="tlaGNC">          95 :       GST_DEBUG_FUNCPTR (gst_tensor_transform_fixate_caps);</span></span>
<span id="L285"><span class="lineNum">     285</span> <span class="tlaGNC">          95 :   trans_class-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_tensor_transform_set_caps);</span></span>
<span id="L286"><span class="lineNum">     286</span>              : </span>
<span id="L287"><span class="lineNum">     287</span>              :   /* Allocation units */</span>
<span id="L288"><span class="lineNum">     288</span> <span class="tlaGNC">          95 :   trans_class-&gt;transform_size =</span></span>
<span id="L289"><span class="lineNum">     289</span> <span class="tlaGNC">          95 :       GST_DEBUG_FUNCPTR (gst_tensor_transform_transform_size);</span></span>
<span id="L290"><span class="lineNum">     290</span> <span class="tlaGNC">          95 : }</span></span>
<span id="L291"><span class="lineNum">     291</span>              : </span>
<span id="L292"><span class="lineNum">     292</span>              : /**</span>
<span id="L293"><span class="lineNum">     293</span>              :  * @brief initialize the new element (G_DEFINE_TYPE requires this)</span>
<span id="L294"><span class="lineNum">     294</span>              :  * instantiate pads and add them to element</span>
<span id="L295"><span class="lineNum">     295</span>              :  * set pad callback functions</span>
<span id="L296"><span class="lineNum">     296</span>              :  * initialize instance structure</span>
<span id="L297"><span class="lineNum">     297</span>              :  */</span>
<span id="L298"><span class="lineNum">     298</span>              : static void</span>
<span id="L299"><span class="lineNum">     299</span> <span class="tlaGNC">         254 : gst_tensor_transform_init (GstTensorTransform * filter)</span></span>
<span id="L300"><span class="lineNum">     300</span>              : {</span>
<span id="L301"><span class="lineNum">     301</span> <span class="tlaGNC">         254 :   filter-&gt;silent = TRUE;</span></span>
<span id="L302"><span class="lineNum">     302</span> <span class="tlaGNC">         254 :   filter-&gt;mode = GTT_UNKNOWN;</span></span>
<span id="L303"><span class="lineNum">     303</span> <span class="tlaGNC">         254 :   filter-&gt;option = NULL;</span></span>
<span id="L304"><span class="lineNum">     304</span> <span class="tlaGNC">         254 :   filter-&gt;loaded = FALSE;</span></span>
<span id="L305"><span class="lineNum">     305</span> <span class="tlaGNC">         254 :   filter-&gt;operators = NULL;</span></span>
<span id="L306"><span class="lineNum">     306</span> <span class="tlaGNC">         254 :   filter-&gt;acceleration = DEFAULT_ACCELERATION;</span></span>
<span id="L307"><span class="lineNum">     307</span> <span class="tlaGNC">         254 :   filter-&gt;apply = NULL;</span></span>
<span id="L308"><span class="lineNum">     308</span>              : </span>
<span id="L309"><span class="lineNum">     309</span> <span class="tlaGNC">         254 :   gst_tensors_config_init (&amp;filter-&gt;in_config);</span></span>
<span id="L310"><span class="lineNum">     310</span> <span class="tlaGNC">         254 :   gst_tensors_config_init (&amp;filter-&gt;out_config);</span></span>
<span id="L311"><span class="lineNum">     311</span> <span class="tlaGNC">         254 : }</span></span>
<span id="L312"><span class="lineNum">     312</span>              : </span>
<span id="L313"><span class="lineNum">     313</span>              : /**</span>
<span id="L314"><span class="lineNum">     314</span>              :  * @brief Get the corresponding operator from the string value</span>
<span id="L315"><span class="lineNum">     315</span>              :  * @param[in] str The string value for the operator</span>
<span id="L316"><span class="lineNum">     316</span>              :  * @return corresponding operator for the string (GTT_OP_UNKNOWN for errors)</span>
<span id="L317"><span class="lineNum">     317</span>              :  */</span>
<span id="L318"><span class="lineNum">     318</span>              : static tensor_transform_operator</span>
<span id="L319"><span class="lineNum">     319</span> <span class="tlaGNC">         175 : gst_tensor_transform_get_operator (const gchar * str)</span></span>
<span id="L320"><span class="lineNum">     320</span>              : {</span>
<span id="L321"><span class="lineNum">     321</span>              :   int index;</span>
<span id="L322"><span class="lineNum">     322</span>              : </span>
<span id="L323"><span class="lineNum">     323</span> <span class="tlaGNC">         175 :   index = find_key_strv (gst_tensor_transform_operator_string, str);</span></span>
<span id="L324"><span class="lineNum">     324</span>              : </span>
<span id="L325"><span class="lineNum">     325</span> <span class="tlaGNC">         175 :   return (index &lt; 0) ? GTT_OP_UNKNOWN : index;</span></span>
<span id="L326"><span class="lineNum">     326</span>              : }</span>
<span id="L327"><span class="lineNum">     327</span>              : </span>
<span id="L328"><span class="lineNum">     328</span>              : /**</span>
<span id="L329"><span class="lineNum">     329</span>              :  * @brief Get the corresponding mode from the string value</span>
<span id="L330"><span class="lineNum">     330</span>              :  * @param[in] str The string value for the mode</span>
<span id="L331"><span class="lineNum">     331</span>              :  * @return corresponding mode for the string. STAND_END for errors</span>
<span id="L332"><span class="lineNum">     332</span>              :  */</span>
<span id="L333"><span class="lineNum">     333</span>              : static tensor_transform_stand_mode</span>
<span id="L334"><span class="lineNum">     334</span> <span class="tlaGNC">           4 : gst_tensor_transform_get_stand_mode (const gchar * str)</span></span>
<span id="L335"><span class="lineNum">     335</span>              : {</span>
<span id="L336"><span class="lineNum">     336</span>              :   int index;</span>
<span id="L337"><span class="lineNum">     337</span>              : </span>
<span id="L338"><span class="lineNum">     338</span> <span class="tlaGNC">           4 :   index = find_key_strv (gst_tensor_transform_stand_string, str);</span></span>
<span id="L339"><span class="lineNum">     339</span>              : </span>
<span id="L340"><span class="lineNum">     340</span> <span class="tlaGNC">           4 :   return (index &lt; 0) ? STAND_END : index;</span></span>
<span id="L341"><span class="lineNum">     341</span>              : }</span>
<span id="L342"><span class="lineNum">     342</span>              : </span>
<span id="L343"><span class="lineNum">     343</span>              : #ifndef FLOAT16_SUPPORT</span>
<span id="L344"><span class="lineNum">     344</span>              : /**</span>
<span id="L345"><span class="lineNum">     345</span>              :  * @brief Generate error if float16 is required.</span>
<span id="L346"><span class="lineNum">     346</span>              :  */</span>
<span id="L347"><span class="lineNum">     347</span>              : static void</span>
<span id="L348"><span class="lineNum">     348</span> <span class="tlaUNC tlaBgUNC">           0 : float16_not_supported (void)</span></span>
<span id="L349"><span class="lineNum">     349</span>              : {</span>
<span id="L350"><span class="lineNum">     350</span> <span class="tlaUNC">           0 :   ml_loge</span></span>
<span id="L351"><span class="lineNum">     351</span>              :       (&quot;Tensor_transform does not support float16 operators. Apply -Denable-float16=true for meson build option if your architecture support float16. Note that tensor-transform's float16 is adhoc and does NOT perform good (slow!).\n&quot;);</span>
<span id="L352"><span class="lineNum">     352</span> <span class="tlaUNC">           0 :   g_assert (0);</span></span>
<span id="L353"><span class="lineNum">     353</span>              : }</span>
<span id="L354"><span class="lineNum">     354</span>              : #endif</span>
<span id="L355"><span class="lineNum">     355</span>              : </span>
<span id="L356"><span class="lineNum">     356</span>              : #ifdef FLOAT16_SUPPORT</span>
<span id="L357"><span class="lineNum">     357</span>              : /**</span>
<span id="L358"><span class="lineNum">     358</span>              :  * @brief Refrain from heavy operations on float16</span>
<span id="L359"><span class="lineNum">     359</span>              :  * @todo Remove this after applying SIMD or ORC</span>
<span id="L360"><span class="lineNum">     360</span>              :  */</span>
<span id="L361"><span class="lineNum">     361</span>              : static void</span>
<span id="L362"><span class="lineNum">     362</span>              : refrain_from_heavy_op_on_float16 (gulong n)</span>
<span id="L363"><span class="lineNum">     363</span>              : {</span>
<span id="L364"><span class="lineNum">     364</span>              :   static int warned = 0;</span>
<span id="L365"><span class="lineNum">     365</span>              :   /* 1 million */</span>
<span id="L366"><span class="lineNum">     366</span>              :   if (n &gt; 1000000) {</span>
<span id="L367"><span class="lineNum">     367</span>              :     if (warned)</span>
<span id="L368"><span class="lineNum">     368</span>              :       return;</span>
<span id="L369"><span class="lineNum">     369</span>              :     ml_logw</span>
<span id="L370"><span class="lineNum">     370</span>              :         (&quot;Tensor_transform implementation for float16 does not support SIMD. Heavy tensor-transform operations of float16 is not recommended. Try to apply heavy ops with other types (e.g., float32) and convert it to float16 at the time when it's really needed.\n&quot;);</span>
<span id="L371"><span class="lineNum">     371</span>              :     warned = 1;</span>
<span id="L372"><span class="lineNum">     372</span>              :   }</span>
<span id="L373"><span class="lineNum">     373</span>              : }</span>
<span id="L374"><span class="lineNum">     374</span>              : </span>
<span id="L375"><span class="lineNum">     375</span>              : /** @todo Make this use SIMD or ORC */</span>
<span id="L376"><span class="lineNum">     376</span>              : #define _conv_to_f16(intype, o, i, n) \</span>
<span id="L377"><span class="lineNum">     377</span>              :   do { \</span>
<span id="L378"><span class="lineNum">     378</span>              :     float16 *op = (gpointer) (o); \</span>
<span id="L379"><span class="lineNum">     379</span>              :     intype *ip = (gpointer) (i); \</span>
<span id="L380"><span class="lineNum">     380</span>              :     gulong idx; \</span>
<span id="L381"><span class="lineNum">     381</span>              :     refrain_from_heavy_op_on_float16 (n); \</span>
<span id="L382"><span class="lineNum">     382</span>              :     for (idx = 0; idx &lt; n; idx++) \</span>
<span id="L383"><span class="lineNum">     383</span>              :       *(op + idx) = (float16) *(ip + idx); \</span>
<span id="L384"><span class="lineNum">     384</span>              :   } while (0)</span>
<span id="L385"><span class="lineNum">     385</span>              : </span>
<span id="L386"><span class="lineNum">     386</span>              : /** @todo Make this use SIMD or ORC */</span>
<span id="L387"><span class="lineNum">     387</span>              : #define _conv_from_f16_action(n, op, ip, otypename) \</span>
<span id="L388"><span class="lineNum">     388</span>              :   do { \</span>
<span id="L389"><span class="lineNum">     389</span>              :     gulong idx; \</span>
<span id="L390"><span class="lineNum">     390</span>              :     for (idx = 0; idx &lt; n; idx++) \</span>
<span id="L391"><span class="lineNum">     391</span>              :       *(op + idx) = (otypename) *(ip + idx); \</span>
<span id="L392"><span class="lineNum">     392</span>              :   } while (0)</span>
<span id="L393"><span class="lineNum">     393</span>              : </span>
<span id="L394"><span class="lineNum">     394</span>              : /** @todo Make this use SIMD or ORC */</span>
<span id="L395"><span class="lineNum">     395</span>              : #define _conv_from_f16(otype, o, i, n) \</span>
<span id="L396"><span class="lineNum">     396</span>              :   do { \</span>
<span id="L397"><span class="lineNum">     397</span>              :     float16 *ip = (gpointer) (i); \</span>
<span id="L398"><span class="lineNum">     398</span>              :     refrain_from_heavy_op_on_float16 (n); \</span>
<span id="L399"><span class="lineNum">     399</span>              :     switch (otype) { \</span>
<span id="L400"><span class="lineNum">     400</span>              :       case _NNS_INT32: { \</span>
<span id="L401"><span class="lineNum">     401</span>              :         int32_t *op = (gpointer) (o); \</span>
<span id="L402"><span class="lineNum">     402</span>              :         _conv_from_f16_action (n, op, ip, int32_t); \</span>
<span id="L403"><span class="lineNum">     403</span>              :         break; } \</span>
<span id="L404"><span class="lineNum">     404</span>              :       case _NNS_UINT32: {  \</span>
<span id="L405"><span class="lineNum">     405</span>              :         uint32_t *op = (gpointer) (o); \</span>
<span id="L406"><span class="lineNum">     406</span>              :         _conv_from_f16_action (n, op, ip, uint32_t); \</span>
<span id="L407"><span class="lineNum">     407</span>              :         break; } \</span>
<span id="L408"><span class="lineNum">     408</span>              :       case _NNS_INT16: {  \</span>
<span id="L409"><span class="lineNum">     409</span>              :         int16_t *op = (gpointer) (o); \</span>
<span id="L410"><span class="lineNum">     410</span>              :         _conv_from_f16_action (n, op, ip, int16_t); \</span>
<span id="L411"><span class="lineNum">     411</span>              :         break; } \</span>
<span id="L412"><span class="lineNum">     412</span>              :       case _NNS_UINT16: {  \</span>
<span id="L413"><span class="lineNum">     413</span>              :         uint16_t *op = (gpointer) (o); \</span>
<span id="L414"><span class="lineNum">     414</span>              :         _conv_from_f16_action (n, op, ip, uint16_t); \</span>
<span id="L415"><span class="lineNum">     415</span>              :         break; } \</span>
<span id="L416"><span class="lineNum">     416</span>              :       case _NNS_INT8: {  \</span>
<span id="L417"><span class="lineNum">     417</span>              :         int8_t *op = (gpointer) (o); \</span>
<span id="L418"><span class="lineNum">     418</span>              :         _conv_from_f16_action (n, op, ip, int8_t); \</span>
<span id="L419"><span class="lineNum">     419</span>              :         break; } \</span>
<span id="L420"><span class="lineNum">     420</span>              :       case _NNS_UINT8: {  \</span>
<span id="L421"><span class="lineNum">     421</span>              :         uint8_t *op = (gpointer) (o); \</span>
<span id="L422"><span class="lineNum">     422</span>              :         _conv_from_f16_action (n, op, ip, uint8_t); \</span>
<span id="L423"><span class="lineNum">     423</span>              :         break; } \</span>
<span id="L424"><span class="lineNum">     424</span>              :       case _NNS_FLOAT64: {  \</span>
<span id="L425"><span class="lineNum">     425</span>              :         double *op = (gpointer) (o); \</span>
<span id="L426"><span class="lineNum">     426</span>              :         _conv_from_f16_action (n, op, ip, double); \</span>
<span id="L427"><span class="lineNum">     427</span>              :         break; } \</span>
<span id="L428"><span class="lineNum">     428</span>              :       case _NNS_FLOAT32: {  \</span>
<span id="L429"><span class="lineNum">     429</span>              :         float *op = (gpointer) (o); \</span>
<span id="L430"><span class="lineNum">     430</span>              :         _conv_from_f16_action (n, op, ip, float); \</span>
<span id="L431"><span class="lineNum">     431</span>              :         break; } \</span>
<span id="L432"><span class="lineNum">     432</span>              :       case _NNS_FLOAT16: {  \</span>
<span id="L433"><span class="lineNum">     433</span>              :         float16 *op = (gpointer) (o); \</span>
<span id="L434"><span class="lineNum">     434</span>              :         _conv_from_f16_action (n, op, ip, float16); \</span>
<span id="L435"><span class="lineNum">     435</span>              :         break; } \</span>
<span id="L436"><span class="lineNum">     436</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unsupported type %d&quot;, (otype)); g_assert (0); \</span>
<span id="L437"><span class="lineNum">     437</span>              :     } \</span>
<span id="L438"><span class="lineNum">     438</span>              :   } while (0)</span>
<span id="L439"><span class="lineNum">     439</span>              : </span>
<span id="L440"><span class="lineNum">     440</span>              : /** @todo Make this use SIMD or ORC */</span>
<span id="L441"><span class="lineNum">     441</span>              : #define _op_float16(i, n, v, op) \</span>
<span id="L442"><span class="lineNum">     442</span>              :   do { \</span>
<span id="L443"><span class="lineNum">     443</span>              :     gulong idx; \</span>
<span id="L444"><span class="lineNum">     444</span>              :     float16 *data_in = (float16 *) (i); \</span>
<span id="L445"><span class="lineNum">     445</span>              :     refrain_from_heavy_op_on_float16 (n); \</span>
<span id="L446"><span class="lineNum">     446</span>              :     switch (op) { \</span>
<span id="L447"><span class="lineNum">     447</span>              :       case GTT_OP_ADD: \</span>
<span id="L448"><span class="lineNum">     448</span>              :         for (idx = 0; idx &lt; n; idx++) \</span>
<span id="L449"><span class="lineNum">     449</span>              :           data_in[idx] = data_in[idx] + (v); \</span>
<span id="L450"><span class="lineNum">     450</span>              :         break; \</span>
<span id="L451"><span class="lineNum">     451</span>              :       case GTT_OP_MUL: \</span>
<span id="L452"><span class="lineNum">     452</span>              :         for (idx = 0; idx &lt; n; idx++) \</span>
<span id="L453"><span class="lineNum">     453</span>              :           data_in[idx] = data_in[idx] * (v); \</span>
<span id="L454"><span class="lineNum">     454</span>              :         break; \</span>
<span id="L455"><span class="lineNum">     455</span>              :       case GTT_OP_DIV: \</span>
<span id="L456"><span class="lineNum">     456</span>              :         for (idx = 0; idx &lt; n; idx++) \</span>
<span id="L457"><span class="lineNum">     457</span>              :           data_in[idx] = data_in[idx] / (v); \</span>
<span id="L458"><span class="lineNum">     458</span>              :         break; \</span>
<span id="L459"><span class="lineNum">     459</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unknown operator for float16: %d&quot;, op); break; \</span>
<span id="L460"><span class="lineNum">     460</span>              :     } \</span>
<span id="L461"><span class="lineNum">     461</span>              :   } while (0)</span>
<span id="L462"><span class="lineNum">     462</span>              : </span>
<span id="L463"><span class="lineNum">     463</span>              : #else /* ! FLOAT16_SUPPORT */</span>
<span id="L464"><span class="lineNum">     464</span>              : #define _conv_to_f16(intype, o, i, n) do { float16_not_supported (); } while (0)</span>
<span id="L465"><span class="lineNum">     465</span>              : #define _conv_from_f16(otype, o, i, n) do { float16_not_supported (); } while (0)</span>
<span id="L466"><span class="lineNum">     466</span>              : #define _op_float16(i, n, v, op) do { float16_not_supported (); } while (0)</span>
<span id="L467"><span class="lineNum">     467</span>              : #endif /* FLOAT16_SUPPORT */</span>
<span id="L468"><span class="lineNum">     468</span>              : </span>
<span id="L469"><span class="lineNum">     469</span>              : #ifdef HAVE_ORC</span>
<span id="L470"><span class="lineNum">     470</span>              : /* define macros for orc */</span>
<span id="L471"><span class="lineNum">     471</span>              : #define orc_func_conv(intype,outtype) nns_orc_conv_ ## intype ## _to_ ## outtype</span>
<span id="L472"><span class="lineNum">     472</span>              : #define orc_func_add(intype) nns_orc_add_c_ ## intype</span>
<span id="L473"><span class="lineNum">     473</span>              : #define orc_func_mul(intype) nns_orc_mul_c_ ## intype</span>
<span id="L474"><span class="lineNum">     474</span>              : #define orc_func_div(intype) nns_orc_div_c_ ## intype</span>
<span id="L475"><span class="lineNum">     475</span>              : </span>
<span id="L476"><span class="lineNum">     476</span>              : #define orc_typecast_to(i,o,n,intype,otype,intypename) do { \</span>
<span id="L477"><span class="lineNum">     477</span>              :     switch (otype) { \</span>
<span id="L478"><span class="lineNum">     478</span>              :       case _NNS_INT32: orc_func_conv (intype, s32) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L479"><span class="lineNum">     479</span>              :       case _NNS_UINT32: orc_func_conv (intype, u32) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L480"><span class="lineNum">     480</span>              :       case _NNS_INT16: orc_func_conv (intype, s16) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L481"><span class="lineNum">     481</span>              :       case _NNS_UINT16: orc_func_conv (intype, u16) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L482"><span class="lineNum">     482</span>              :       case _NNS_INT8: orc_func_conv (intype, s8) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L483"><span class="lineNum">     483</span>              :       case _NNS_UINT8: orc_func_conv (intype, u8) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L484"><span class="lineNum">     484</span>              :       case _NNS_FLOAT64: orc_func_conv (intype, f64) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L485"><span class="lineNum">     485</span>              :       case _NNS_FLOAT32: orc_func_conv (intype, f32) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L486"><span class="lineNum">     486</span>              :       case _NNS_INT64: orc_func_conv (intype, s64) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L487"><span class="lineNum">     487</span>              :       case _NNS_UINT64: orc_func_conv (intype, u64) ((gpointer) o, (gpointer) i, n); break; \</span>
<span id="L488"><span class="lineNum">     488</span>              :       case _NNS_FLOAT16: _conv_to_f16 (intypename, o, i, n); break; \</span>
<span id="L489"><span class="lineNum">     489</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unsupported output type %d&quot;, otype); g_assert (0); break; \</span>
<span id="L490"><span class="lineNum">     490</span>              :     } \</span>
<span id="L491"><span class="lineNum">     491</span>              :   } while (0)</span>
<span id="L492"><span class="lineNum">     492</span>              : </span>
<span id="L493"><span class="lineNum">     493</span>              : #define orc_typecast(i,o,n,itype,otype) do { \</span>
<span id="L494"><span class="lineNum">     494</span>              :     switch (itype) { \</span>
<span id="L495"><span class="lineNum">     495</span>              :       case _NNS_INT32: orc_typecast_to (i, o, n, s32, otype, int32_t); break; \</span>
<span id="L496"><span class="lineNum">     496</span>              :       case _NNS_UINT32: orc_typecast_to (i, o, n, u32, otype, uint32_t); break; \</span>
<span id="L497"><span class="lineNum">     497</span>              :       case _NNS_INT16: orc_typecast_to (i, o, n, s16, otype, int16_t); break; \</span>
<span id="L498"><span class="lineNum">     498</span>              :       case _NNS_UINT16: orc_typecast_to (i, o, n, u16, otype, uint16_t); break; \</span>
<span id="L499"><span class="lineNum">     499</span>              :       case _NNS_INT8: orc_typecast_to (i, o, n, s8, otype, int8_t); break; \</span>
<span id="L500"><span class="lineNum">     500</span>              :       case _NNS_UINT8: orc_typecast_to (i, o, n, u8, otype, uint8_t); break; \</span>
<span id="L501"><span class="lineNum">     501</span>              :       case _NNS_FLOAT64: orc_typecast_to (i, o, n, f64, otype, double); break; \</span>
<span id="L502"><span class="lineNum">     502</span>              :       case _NNS_FLOAT32: orc_typecast_to (i, o, n, f32, otype, float); break; \</span>
<span id="L503"><span class="lineNum">     503</span>              :       case _NNS_INT64: orc_typecast_to (i, o, n, s64, otype, int64_t); break; \</span>
<span id="L504"><span class="lineNum">     504</span>              :       case _NNS_UINT64: orc_typecast_to (i, o, n, u64, otype, uint64_t); break; \</span>
<span id="L505"><span class="lineNum">     505</span>              :       case _NNS_FLOAT16: _conv_from_f16 (otype, o, i, n); break; \</span>
<span id="L506"><span class="lineNum">     506</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unsupported input type %d&quot;, itype); g_assert (0); break; \</span>
<span id="L507"><span class="lineNum">     507</span>              :     } \</span>
<span id="L508"><span class="lineNum">     508</span>              :   } while (0)</span>
<span id="L509"><span class="lineNum">     509</span>              : </span>
<span id="L510"><span class="lineNum">     510</span>              : #define orc_typesize(size, type) do { \</span>
<span id="L511"><span class="lineNum">     511</span>              :     switch (type) { \</span>
<span id="L512"><span class="lineNum">     512</span>              :       case _NNS_INT32: size = sizeof(int32_t); break; \</span>
<span id="L513"><span class="lineNum">     513</span>              :       case _NNS_UINT32: size = sizeof(uint32_t); break; \</span>
<span id="L514"><span class="lineNum">     514</span>              :       case _NNS_INT16: size = sizeof(int16_t); break; \</span>
<span id="L515"><span class="lineNum">     515</span>              :       case _NNS_UINT16: size = sizeof(uint16_t); break; \</span>
<span id="L516"><span class="lineNum">     516</span>              :       case _NNS_INT8: size = sizeof(int8_t); break; \</span>
<span id="L517"><span class="lineNum">     517</span>              :       case _NNS_UINT8: size = sizeof(uint8_t); break; \</span>
<span id="L518"><span class="lineNum">     518</span>              :       case _NNS_FLOAT64: size = sizeof(double); break; \</span>
<span id="L519"><span class="lineNum">     519</span>              :       case _NNS_FLOAT32: size = sizeof(float); break; \</span>
<span id="L520"><span class="lineNum">     520</span>              :       case _NNS_INT64: size = sizeof(int64_t); break; \</span>
<span id="L521"><span class="lineNum">     521</span>              :       case _NNS_UINT64: size = sizeof(uint64_t); break; \</span>
<span id="L522"><span class="lineNum">     522</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unsupported type %d&quot;, type); g_assert (0); break; \</span>
<span id="L523"><span class="lineNum">     523</span>              :     } \</span>
<span id="L524"><span class="lineNum">     524</span>              :   } while (0)</span>
<span id="L525"><span class="lineNum">     525</span>              : </span>
<span id="L526"><span class="lineNum">     526</span>              : #define orc_operator_func(i,n,v,opfunc,op) do { \</span>
<span id="L527"><span class="lineNum">     527</span>              :     switch ((v)-&gt;type) { \</span>
<span id="L528"><span class="lineNum">     528</span>              :       case _NNS_INT32: opfunc (s32) ((gpointer) i, (v)-&gt;data._int32_t, n); break; \</span>
<span id="L529"><span class="lineNum">     529</span>              :       case _NNS_UINT32: opfunc (u32) ((gpointer) i, (v)-&gt;data._uint32_t, n); break; \</span>
<span id="L530"><span class="lineNum">     530</span>              :       case _NNS_INT16: opfunc (s16) ((gpointer) i, (v)-&gt;data._int16_t, n); break; \</span>
<span id="L531"><span class="lineNum">     531</span>              :       case _NNS_UINT16: opfunc (u16) ((gpointer) i, (v)-&gt;data._uint16_t, n); break; \</span>
<span id="L532"><span class="lineNum">     532</span>              :       case _NNS_INT8: opfunc (s8) ((gpointer) i, (v)-&gt;data._int8_t, n); break; \</span>
<span id="L533"><span class="lineNum">     533</span>              :       case _NNS_UINT8: opfunc (u8) ((gpointer) i, (v)-&gt;data._uint8_t, n); break; \</span>
<span id="L534"><span class="lineNum">     534</span>              :       case _NNS_FLOAT64: opfunc (f64) ((gpointer) i, (v)-&gt;data._double, n); break; \</span>
<span id="L535"><span class="lineNum">     535</span>              :       case _NNS_FLOAT32: opfunc (f32) ((gpointer) i, (v)-&gt;data._float, n); break; \</span>
<span id="L536"><span class="lineNum">     536</span>              :       case _NNS_INT64: opfunc (s64) ((gpointer) i, (v)-&gt;data._int64_t, n); break; \</span>
<span id="L537"><span class="lineNum">     537</span>              :       case _NNS_UINT64: opfunc (u64) ((gpointer) i, (v)-&gt;data._uint64_t, n); break; \</span>
<span id="L538"><span class="lineNum">     538</span>              :       case _NNS_FLOAT16: _op_float16 (i, n, (v)-&gt;data._float16, op); break; \</span>
<span id="L539"><span class="lineNum">     539</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unsupported type %d&quot;, (v)-&gt;type); g_assert (0); break; \</span>
<span id="L540"><span class="lineNum">     540</span>              :     } \</span>
<span id="L541"><span class="lineNum">     541</span>              :   } while (0)</span>
<span id="L542"><span class="lineNum">     542</span>              : </span>
<span id="L543"><span class="lineNum">     543</span>              : #define orc_operator_div_loop(i,n,val,typename) do { \</span>
<span id="L544"><span class="lineNum">     544</span>              :     gsize idx_div; \</span>
<span id="L545"><span class="lineNum">     545</span>              :     typename *data_in = (typename *) (i); \</span>
<span id="L546"><span class="lineNum">     546</span>              :     for (idx_div = 0; idx_div &lt; (n); ++idx_div) { \</span>
<span id="L547"><span class="lineNum">     547</span>              :       data_in[idx_div] = data_in[idx_div] / (val); \</span>
<span id="L548"><span class="lineNum">     548</span>              :     } \</span>
<span id="L549"><span class="lineNum">     549</span>              :   } while (0)</span>
<span id="L550"><span class="lineNum">     550</span>              : </span>
<span id="L551"><span class="lineNum">     551</span>              : #define orc_operator(i,n,v,op) do { \</span>
<span id="L552"><span class="lineNum">     552</span>              :     switch (op) { \</span>
<span id="L553"><span class="lineNum">     553</span>              :       case GTT_OP_ADD: orc_operator_func (i, n, v, orc_func_add, op); break; \</span>
<span id="L554"><span class="lineNum">     554</span>              :       case GTT_OP_MUL: orc_operator_func (i, n, v, orc_func_mul, op); break; \</span>
<span id="L555"><span class="lineNum">     555</span>              :       case GTT_OP_DIV: \</span>
<span id="L556"><span class="lineNum">     556</span>              :         switch ((v)-&gt;type) { \</span>
<span id="L557"><span class="lineNum">     557</span>              :           case _NNS_INT32: orc_operator_div_loop (i, n, (v)-&gt;data._int32_t, int32_t); break; \</span>
<span id="L558"><span class="lineNum">     558</span>              :           case _NNS_UINT32: orc_operator_div_loop (i, n, (v)-&gt;data._uint32_t, uint32_t); break; \</span>
<span id="L559"><span class="lineNum">     559</span>              :           case _NNS_INT16: orc_operator_div_loop (i, n, (v)-&gt;data._int16_t, int16_t); break; \</span>
<span id="L560"><span class="lineNum">     560</span>              :           case _NNS_UINT16: orc_operator_div_loop (i, n, (v)-&gt;data._uint16_t, uint16_t); break; \</span>
<span id="L561"><span class="lineNum">     561</span>              :           case _NNS_INT8: orc_operator_div_loop (i, n, (v)-&gt;data._int8_t, int8_t); break; \</span>
<span id="L562"><span class="lineNum">     562</span>              :           case _NNS_UINT8: orc_operator_div_loop (i, n, (v)-&gt;data._uint8_t, uint8_t); break; \</span>
<span id="L563"><span class="lineNum">     563</span>              :           case _NNS_FLOAT64: orc_func_div (f64) ((gpointer) i, (v)-&gt;data._double, n); break; \</span>
<span id="L564"><span class="lineNum">     564</span>              :           case _NNS_FLOAT32: orc_func_div (f32) ((gpointer) i, (v)-&gt;data._float, n); break; \</span>
<span id="L565"><span class="lineNum">     565</span>              :           case _NNS_INT64: orc_operator_div_loop (i, n, (v)-&gt;data._int64_t, int64_t); break; \</span>
<span id="L566"><span class="lineNum">     566</span>              :           case _NNS_UINT64: orc_operator_div_loop (i, n, (v)-&gt;data._uint64_t, uint64_t); break; \</span>
<span id="L567"><span class="lineNum">     567</span>              :           case _NNS_FLOAT16: _op_float16 (i, n, (v)-&gt;data._float16, op); break; \</span>
<span id="L568"><span class="lineNum">     568</span>              :           default: GST_ERROR_OBJECT (filter, &quot;Unsupported type %d&quot;, (v)-&gt;type); g_assert (0); break; \</span>
<span id="L569"><span class="lineNum">     569</span>              :         } \</span>
<span id="L570"><span class="lineNum">     570</span>              :         break; \</span>
<span id="L571"><span class="lineNum">     571</span>              :       default: GST_ERROR_OBJECT (filter, &quot;Unknown operator %d&quot;, op); break; \</span>
<span id="L572"><span class="lineNum">     572</span>              :     } \</span>
<span id="L573"><span class="lineNum">     573</span>              :   } while (0)</span>
<span id="L574"><span class="lineNum">     574</span>              : #endif /* HAVE_ORC */</span>
<span id="L575"><span class="lineNum">     575</span>              : </span>
<span id="L576"><span class="lineNum">     576</span>              : /**</span>
<span id="L577"><span class="lineNum">     577</span>              :  * @brief Macro for operator</span>
<span id="L578"><span class="lineNum">     578</span>              :  */</span>
<span id="L579"><span class="lineNum">     579</span>              : #define handle_operator(d,v,oper,vtype) do { \</span>
<span id="L580"><span class="lineNum">     580</span>              :     switch (oper) { \</span>
<span id="L581"><span class="lineNum">     581</span>              :       case GTT_OP_ADD: \</span>
<span id="L582"><span class="lineNum">     582</span>              :         (d)-&gt;data._##vtype += (v)-&gt;data._##vtype; \</span>
<span id="L583"><span class="lineNum">     583</span>              :         break; \</span>
<span id="L584"><span class="lineNum">     584</span>              :       case GTT_OP_MUL: \</span>
<span id="L585"><span class="lineNum">     585</span>              :         (d)-&gt;data._##vtype *= (v)-&gt;data._##vtype; \</span>
<span id="L586"><span class="lineNum">     586</span>              :         break; \</span>
<span id="L587"><span class="lineNum">     587</span>              :       case GTT_OP_DIV: \</span>
<span id="L588"><span class="lineNum">     588</span>              :         if ((v)-&gt;data._##vtype == 0) { \</span>
<span id="L589"><span class="lineNum">     589</span>              :           GST_ERROR_OBJECT (filter, &quot;Invalid state, denominator is 0.&quot;); \</span>
<span id="L590"><span class="lineNum">     590</span>              :           return FALSE; \</span>
<span id="L591"><span class="lineNum">     591</span>              :         } \</span>
<span id="L592"><span class="lineNum">     592</span>              :         (d)-&gt;data._##vtype /= (v)-&gt;data._##vtype; \</span>
<span id="L593"><span class="lineNum">     593</span>              :         break; \</span>
<span id="L594"><span class="lineNum">     594</span>              :       default: \</span>
<span id="L595"><span class="lineNum">     595</span>              :         GST_ERROR_OBJECT (filter, &quot;Unknown operator %d&quot;, oper); \</span>
<span id="L596"><span class="lineNum">     596</span>              :         return FALSE; \</span>
<span id="L597"><span class="lineNum">     597</span>              :     } \</span>
<span id="L598"><span class="lineNum">     598</span>              :   } while (0)</span>
<span id="L599"><span class="lineNum">     599</span>              : </span>
<span id="L600"><span class="lineNum">     600</span>              : /**</span>
<span id="L601"><span class="lineNum">     601</span>              :  * @brief Handle operators for tensor value</span>
<span id="L602"><span class="lineNum">     602</span>              :  * @param filter &quot;this&quot; pointer</span>
<span id="L603"><span class="lineNum">     603</span>              :  * @param desc struct for tensor value</span>
<span id="L604"><span class="lineNum">     604</span>              :  * @param val struct for tensor value</span>
<span id="L605"><span class="lineNum">     605</span>              :  * @param op operator for given tensor value</span>
<span id="L606"><span class="lineNum">     606</span>              :  * @return TRUE if no error</span>
<span id="L607"><span class="lineNum">     607</span>              :  */</span>
<span id="L608"><span class="lineNum">     608</span>              : static gboolean</span>
<span id="L609"><span class="lineNum">     609</span> <span class="tlaGNC tlaBgGNC">       61615 : gst_tensor_transform_do_operator (GstTensorTransform * filter,</span></span>
<span id="L610"><span class="lineNum">     610</span>              :     tensor_data_s * desc, const tensor_data_s * val,</span>
<span id="L611"><span class="lineNum">     611</span>              :     tensor_transform_operator op)</span>
<span id="L612"><span class="lineNum">     612</span>              : {</span>
<span id="L613"><span class="lineNum">     613</span> <span class="tlaGNC">       61615 :   g_return_val_if_fail (desc != NULL, FALSE);</span></span>
<span id="L614"><span class="lineNum">     614</span> <span class="tlaGNC">       61615 :   g_return_val_if_fail (val != NULL, FALSE);</span></span>
<span id="L615"><span class="lineNum">     615</span> <span class="tlaGNC">       61615 :   g_return_val_if_fail (desc-&gt;type == val-&gt;type, FALSE);</span></span>
<span id="L616"><span class="lineNum">     616</span>              : </span>
<span id="L617"><span class="lineNum">     617</span> <span class="tlaGNC">       61615 :   switch (desc-&gt;type) {</span></span>
<span id="L618"><span class="lineNum">     618</span> <span class="tlaGNC">        7755 :     case _NNS_INT32:</span></span>
<span id="L619"><span class="lineNum">     619</span> <span class="tlaGNC">        7755 :       handle_operator (desc, val, op, int32_t);</span></span>
<span id="L620"><span class="lineNum">     620</span> <span class="tlaGNC">        7755 :       break;</span></span>
<span id="L621"><span class="lineNum">     621</span> <span class="tlaGNC">        7680 :     case _NNS_UINT32:</span></span>
<span id="L622"><span class="lineNum">     622</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, uint32_t);</span></span>
<span id="L623"><span class="lineNum">     623</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L624"><span class="lineNum">     624</span> <span class="tlaGNC">        7680 :     case _NNS_INT16:</span></span>
<span id="L625"><span class="lineNum">     625</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, int16_t);</span></span>
<span id="L626"><span class="lineNum">     626</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L627"><span class="lineNum">     627</span> <span class="tlaGNC">        7680 :     case _NNS_UINT16:</span></span>
<span id="L628"><span class="lineNum">     628</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, uint16_t);</span></span>
<span id="L629"><span class="lineNum">     629</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L630"><span class="lineNum">     630</span> <span class="tlaGNC">        7680 :     case _NNS_INT8:</span></span>
<span id="L631"><span class="lineNum">     631</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, int8_t);</span></span>
<span id="L632"><span class="lineNum">     632</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L633"><span class="lineNum">     633</span> <span class="tlaGNC">        7680 :     case _NNS_UINT8:</span></span>
<span id="L634"><span class="lineNum">     634</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, uint8_t);</span></span>
<span id="L635"><span class="lineNum">     635</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L636"><span class="lineNum">     636</span> <span class="tlaGNC">          45 :     case _NNS_FLOAT64:</span></span>
<span id="L637"><span class="lineNum">     637</span> <span class="tlaGNC">          45 :       handle_operator (desc, val, op, double);</span></span>
<span id="L638"><span class="lineNum">     638</span> <span class="tlaGNC">          45 :       break;</span></span>
<span id="L639"><span class="lineNum">     639</span> <span class="tlaGNC">          55 :     case _NNS_FLOAT32:</span></span>
<span id="L640"><span class="lineNum">     640</span> <span class="tlaGNC">          55 :       handle_operator (desc, val, op, float);</span></span>
<span id="L641"><span class="lineNum">     641</span> <span class="tlaGNC">          55 :       break;</span></span>
<span id="L642"><span class="lineNum">     642</span> <span class="tlaUNC tlaBgUNC">           0 :     case _NNS_FLOAT16:</span></span>
<span id="L643"><span class="lineNum">     643</span>              : #ifdef FLOAT16_SUPPORT</span>
<span id="L644"><span class="lineNum">     644</span>              :       handle_operator (desc, val, op, float16);</span>
<span id="L645"><span class="lineNum">     645</span>              : #else</span>
<span id="L646"><span class="lineNum">     646</span> <span class="tlaUNC">           0 :       float16_not_supported ();</span></span>
<span id="L647"><span class="lineNum">     647</span>              : #endif</span>
<span id="L648"><span class="lineNum">     648</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L649"><span class="lineNum">     649</span> <span class="tlaGNC tlaBgGNC">        7680 :     case _NNS_INT64:</span></span>
<span id="L650"><span class="lineNum">     650</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, int64_t);</span></span>
<span id="L651"><span class="lineNum">     651</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L652"><span class="lineNum">     652</span> <span class="tlaGNC">        7680 :     case _NNS_UINT64:</span></span>
<span id="L653"><span class="lineNum">     653</span> <span class="tlaGNC">        7680 :       handle_operator (desc, val, op, uint64_t);</span></span>
<span id="L654"><span class="lineNum">     654</span> <span class="tlaGNC">        7680 :       break;</span></span>
<span id="L655"><span class="lineNum">     655</span> <span class="tlaUNC tlaBgUNC">           0 :     default:</span></span>
<span id="L656"><span class="lineNum">     656</span> <span class="tlaUNC">           0 :       GST_ERROR_OBJECT (filter, &quot;Unknown tensor type %d&quot;, desc-&gt;type);</span></span>
<span id="L657"><span class="lineNum">     657</span> <span class="tlaUNC">           0 :       return FALSE;</span></span>
<span id="L658"><span class="lineNum">     658</span>              :   }</span>
<span id="L659"><span class="lineNum">     659</span>              : </span>
<span id="L660"><span class="lineNum">     660</span> <span class="tlaGNC tlaBgGNC">       61615 :   return TRUE;</span></span>
<span id="L661"><span class="lineNum">     661</span>              : }</span>
<span id="L662"><span class="lineNum">     662</span>              : </span>
<span id="L663"><span class="lineNum">     663</span>              : /**</span>
<span id="L664"><span class="lineNum">     664</span>              :  * @brief Setup internal data (data_* in GstTensorTransform)</span>
<span id="L665"><span class="lineNum">     665</span>              :  * @param[in/out] filter &quot;this&quot; pointer. mode &amp; option MUST BE set already.</span>
<span id="L666"><span class="lineNum">     666</span>              :  * @retval TRUE if OK or operation-skipped, FALSE if fatal-error.</span>
<span id="L667"><span class="lineNum">     667</span>              :  */</span>
<span id="L668"><span class="lineNum">     668</span>              : static gboolean</span>
<span id="L669"><span class="lineNum">     669</span> <span class="tlaGNC">         541 : gst_tensor_transform_set_option_data (GstTensorTransform * filter)</span></span>
<span id="L670"><span class="lineNum">     670</span>              : {</span>
<span id="L671"><span class="lineNum">     671</span>              :   gchar *filter_name;</span>
<span id="L672"><span class="lineNum">     672</span> <span class="tlaGNC">         541 :   gboolean ret = FALSE;</span></span>
<span id="L673"><span class="lineNum">     673</span>              : </span>
<span id="L674"><span class="lineNum">     674</span> <span class="tlaGNC">         541 :   if (filter-&gt;mode == GTT_UNKNOWN || filter-&gt;option == NULL)</span></span>
<span id="L675"><span class="lineNum">     675</span> <span class="tlaGNC">         283 :     return TRUE;</span></span>
<span id="L676"><span class="lineNum">     676</span>              : </span>
<span id="L677"><span class="lineNum">     677</span> <span class="tlaGNC">         258 :   filter_name = gst_object_get_name ((GstObject *) filter);</span></span>
<span id="L678"><span class="lineNum">     678</span>              : </span>
<span id="L679"><span class="lineNum">     679</span> <span class="tlaGNC">         258 :   switch (filter-&gt;mode) {</span></span>
<span id="L680"><span class="lineNum">     680</span> <span class="tlaGNC">           8 :     case GTT_DIMCHG:</span></span>
<span id="L681"><span class="lineNum">     681</span>              :     {</span>
<span id="L682"><span class="lineNum">     682</span> <span class="tlaGNC">           8 :       gchar **strv = NULL;</span></span>
<span id="L683"><span class="lineNum">     683</span>              : </span>
<span id="L684"><span class="lineNum">     684</span> <span class="tlaGNC">           8 :       if (!g_regex_match_simple (REGEX_DIMCHG_OPTION, filter-&gt;option,</span></span>
<span id="L685"><span class="lineNum">     685</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L686"><span class="lineNum">     686</span> <span class="tlaGNC">           3 :         ml_loge</span></span>
<span id="L687"><span class="lineNum">     687</span>              :             (&quot;%s: dimchg: \'%s\' is not valid option string: it should be in the form of IDX_DIM_FROM:IDX_DIM_TO: with a regex, &quot;</span>
<span id="L688"><span class="lineNum">     688</span>              :             REGEX_DIMCHG_OPTION &quot;\n&quot;, filter_name, filter-&gt;option);</span>
<span id="L689"><span class="lineNum">     689</span> <span class="tlaGNC">           3 :         break;</span></span>
<span id="L690"><span class="lineNum">     690</span>              :       }</span>
<span id="L691"><span class="lineNum">     691</span>              : </span>
<span id="L692"><span class="lineNum">     692</span> <span class="tlaGNC">           5 :       strv = g_strsplit (filter-&gt;option, &quot;:&quot;, 2);</span></span>
<span id="L693"><span class="lineNum">     693</span>              : </span>
<span id="L694"><span class="lineNum">     694</span> <span class="tlaGNC">           5 :       filter-&gt;data_dimchg.from = (int) g_ascii_strtoll (strv[0], NULL, 10);</span></span>
<span id="L695"><span class="lineNum">     695</span> <span class="tlaGNC">           5 :       filter-&gt;data_dimchg.to = (int) g_ascii_strtoll (strv[1], NULL, 10);</span></span>
<span id="L696"><span class="lineNum">     696</span> <span class="tlaGNC">           5 :       ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L697"><span class="lineNum">     697</span> <span class="tlaGNC">           5 :       g_strfreev (strv);</span></span>
<span id="L698"><span class="lineNum">     698</span> <span class="tlaGNC">           5 :       break;</span></span>
<span id="L699"><span class="lineNum">     699</span>              :     }</span>
<span id="L700"><span class="lineNum">     700</span> <span class="tlaGNC">         117 :     case GTT_TYPECAST:</span></span>
<span id="L701"><span class="lineNum">     701</span>              :     {</span>
<span id="L702"><span class="lineNum">     702</span> <span class="tlaGNC">         117 :       if (g_regex_match_simple (REGEX_TYPECAST_OPTION, filter-&gt;option,</span></span>
<span id="L703"><span class="lineNum">     703</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L704"><span class="lineNum">     704</span> <span class="tlaGNC">         116 :         filter-&gt;data_typecast.to = gst_tensor_get_type (filter-&gt;option);</span></span>
<span id="L705"><span class="lineNum">     705</span> <span class="tlaGNC">         116 :         ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L706"><span class="lineNum">     706</span>              :       } else {</span>
<span id="L707"><span class="lineNum">     707</span> <span class="tlaGNC">           1 :         ml_loge</span></span>
<span id="L708"><span class="lineNum">     708</span>              :             (&quot;%s: typecast: \'%s\' is not valid data type for tensor: data type of tensor should be one of %s\n&quot;,</span>
<span id="L709"><span class="lineNum">     709</span>              :             filter_name, filter-&gt;option, GST_TENSOR_TYPE_ALL);</span>
<span id="L710"><span class="lineNum">     710</span>              :       }</span>
<span id="L711"><span class="lineNum">     711</span> <span class="tlaGNC">         117 :       break;</span></span>
<span id="L712"><span class="lineNum">     712</span>              :     }</span>
<span id="L713"><span class="lineNum">     713</span> <span class="tlaGNC">          90 :     case GTT_ARITHMETIC:</span></span>
<span id="L714"><span class="lineNum">     714</span>              :     {</span>
<span id="L715"><span class="lineNum">     715</span>              :       gchar *str_option;</span>
<span id="L716"><span class="lineNum">     716</span>              :       gchar **str_operators;</span>
<span id="L717"><span class="lineNum">     717</span>              :       gchar **str_op;</span>
<span id="L718"><span class="lineNum">     718</span>              :       tensor_transform_operator_s *op_s;</span>
<span id="L719"><span class="lineNum">     719</span>              :       guint i, num_operators, num_op;</span>
<span id="L720"><span class="lineNum">     720</span>              :       GRegex *regex_option_tc;</span>
<span id="L721"><span class="lineNum">     721</span>              : </span>
<span id="L722"><span class="lineNum">     722</span> <span class="tlaGNC">          90 :       filter-&gt;data_arithmetic.out_type = _NNS_END;</span></span>
<span id="L723"><span class="lineNum">     723</span> <span class="tlaGNC">          90 :       filter-&gt;data_arithmetic.per_channel_arith = FALSE;</span></span>
<span id="L724"><span class="lineNum">     724</span>              : </span>
<span id="L725"><span class="lineNum">     725</span> <span class="tlaGNC">          90 :       if (filter-&gt;operators) {</span></span>
<span id="L726"><span class="lineNum">     726</span> <span class="tlaGNC">           2 :         GST_WARNING_OBJECT (filter,</span></span>
<span id="L727"><span class="lineNum">     727</span>              :             &quot;There exists pre-defined operators (total %d), now reset these.&quot;,</span>
<span id="L728"><span class="lineNum">     728</span>              :             g_slist_length (filter-&gt;operators));</span>
<span id="L729"><span class="lineNum">     729</span>              : </span>
<span id="L730"><span class="lineNum">     730</span> <span class="tlaGNC">           2 :         g_slist_free_full (filter-&gt;operators, g_free);</span></span>
<span id="L731"><span class="lineNum">     731</span> <span class="tlaGNC">           2 :         filter-&gt;operators = NULL;</span></span>
<span id="L732"><span class="lineNum">     732</span>              :       }</span>
<span id="L733"><span class="lineNum">     733</span>              : </span>
<span id="L734"><span class="lineNum">     734</span> <span class="tlaGNC">          90 :       regex_option_tc = g_regex_new (REGEX_ARITH_OPTION_TYPECAST,</span></span>
<span id="L735"><span class="lineNum">     735</span>              :           G_REGEX_CASELESS, 0, 0);</span>
<span id="L736"><span class="lineNum">     736</span>              : </span>
<span id="L737"><span class="lineNum">     737</span> <span class="tlaGNC">          90 :       if (!regex_option_tc) {</span></span>
<span id="L738"><span class="lineNum">     738</span> <span class="tlaUNC tlaBgUNC">           0 :         GST_ERROR_OBJECT (filter,</span></span>
<span id="L739"><span class="lineNum">     739</span>              :             &quot;arithmetic: failed to create a GRegex structure for %s\n&quot;,</span>
<span id="L740"><span class="lineNum">     740</span>              :             REGEX_ARITH_OPTION_TYPECAST);</span>
<span id="L741"><span class="lineNum">     741</span> <span class="tlaUNC">           0 :         break;</span></span>
<span id="L742"><span class="lineNum">     742</span>              :       }</span>
<span id="L743"><span class="lineNum">     743</span>              : </span>
<span id="L744"><span class="lineNum">     744</span> <span class="tlaGNC tlaBgGNC">          90 :       if (g_regex_match_full (regex_option_tc, filter-&gt;option, -1,</span></span>
<span id="L745"><span class="lineNum">     745</span>              :               1, 0, NULL, NULL)) {</span>
<span id="L746"><span class="lineNum">     746</span> <span class="tlaGNC">           2 :         str_option = g_regex_replace (regex_option_tc, filter-&gt;option, -1, 1,</span></span>
<span id="L747"><span class="lineNum">     747</span>              :             &quot;&quot;, 0, 0);</span>
<span id="L748"><span class="lineNum">     748</span> <span class="tlaGNC">           2 :         ml_loge</span></span>
<span id="L749"><span class="lineNum">     749</span>              :             (&quot;%s: arithmetic: [typecast:TYPE,] should be located at the first to prevent memory re-allocation: typecast(s) in the middle of \'%s\' will be ignored\n&quot;,</span>
<span id="L750"><span class="lineNum">     750</span>              :             filter_name, filter-&gt;option);</span>
<span id="L751"><span class="lineNum">     751</span>              :       } else {</span>
<span id="L752"><span class="lineNum">     752</span> <span class="tlaGNC">         176 :         str_option = g_strdup (filter-&gt;option);</span></span>
<span id="L753"><span class="lineNum">     753</span>              :       }</span>
<span id="L754"><span class="lineNum">     754</span> <span class="tlaGNC">          90 :       g_regex_unref (regex_option_tc);</span></span>
<span id="L755"><span class="lineNum">     755</span>              : </span>
<span id="L756"><span class="lineNum">     756</span> <span class="tlaGNC">          90 :       if (!g_regex_match_simple (REGEX_ARITH_OPTION, str_option,</span></span>
<span id="L757"><span class="lineNum">     757</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L758"><span class="lineNum">     758</span> <span class="tlaGNC">          13 :         ml_loge</span></span>
<span id="L759"><span class="lineNum">     759</span>              :             (&quot;%s: arithmetic: \'%s\' is not valid option string: it should be in the form of [typecast:TYPE,][per-channel:(false|true@DIM),]add|mul|div:NUMBER[@CH_IDX]..., ...\n&quot;,</span>
<span id="L760"><span class="lineNum">     760</span>              :             filter_name, str_option);</span>
<span id="L761"><span class="lineNum">     761</span> <span class="tlaGNC">          13 :         g_free (str_option);</span></span>
<span id="L762"><span class="lineNum">     762</span> <span class="tlaGNC">          13 :         break;</span></span>
<span id="L763"><span class="lineNum">     763</span>              :       }</span>
<span id="L764"><span class="lineNum">     764</span> <span class="tlaGNC">          77 :       str_operators = g_strsplit (str_option, &quot;,&quot;, -1);</span></span>
<span id="L765"><span class="lineNum">     765</span> <span class="tlaGNC">          77 :       num_operators = g_strv_length (str_operators);</span></span>
<span id="L766"><span class="lineNum">     766</span>              : </span>
<span id="L767"><span class="lineNum">     767</span> <span class="tlaGNC">         256 :       for (i = 0; i &lt; num_operators; ++i) {</span></span>
<span id="L768"><span class="lineNum">     768</span> <span class="tlaGNC">         179 :         str_op = g_strsplit (str_operators[i], &quot;:&quot;, -1);</span></span>
<span id="L769"><span class="lineNum">     769</span> <span class="tlaGNC">         179 :         num_op = g_strv_length (str_op);</span></span>
<span id="L770"><span class="lineNum">     770</span>              : </span>
<span id="L771"><span class="lineNum">     771</span> <span class="tlaGNC">         179 :         if (str_op[0]) {</span></span>
<span id="L772"><span class="lineNum">     772</span> <span class="tlaGNC">         177 :           gchar **values = g_strsplit (str_op[1], &quot;@&quot;, -1);</span></span>
<span id="L773"><span class="lineNum">     773</span> <span class="tlaGNC">         177 :           guint num_values = g_strv_length (values);</span></span>
<span id="L774"><span class="lineNum">     774</span>              : </span>
<span id="L775"><span class="lineNum">     775</span>              :           /* check whether per-channel */</span>
<span id="L776"><span class="lineNum">     776</span> <span class="tlaGNC">         177 :           if (g_ascii_strcasecmp (str_op[0], &quot;per-channel&quot;) == 0) {</span></span>
<span id="L777"><span class="lineNum">     777</span> <span class="tlaGNC">           2 :             if (num_values &gt; 1 &amp;&amp; g_ascii_strcasecmp (values[0], &quot;true&quot;) == 0) {</span></span>
<span id="L778"><span class="lineNum">     778</span> <span class="tlaGNC">           2 :               ml_logi</span></span>
<span id="L779"><span class="lineNum">     779</span>              :                   (&quot;Set per-channel for arithmetic and assume that %s-th dim is the channel&quot;,</span>
<span id="L780"><span class="lineNum">     780</span>              :                   values[1]);</span>
<span id="L781"><span class="lineNum">     781</span> <span class="tlaGNC">           2 :               filter-&gt;data_arithmetic.per_channel_arith = TRUE;</span></span>
<span id="L782"><span class="lineNum">     782</span> <span class="tlaGNC">           2 :               filter-&gt;data_arithmetic.ch_dim =</span></span>
<span id="L783"><span class="lineNum">     783</span> <span class="tlaGNC">           2 :                   (guint) g_ascii_strtoull (values[1], NULL, 10);</span></span>
<span id="L784"><span class="lineNum">     784</span>              :             }</span>
<span id="L785"><span class="lineNum">     785</span>              : </span>
<span id="L786"><span class="lineNum">     786</span> <span class="tlaGNC">           2 :             g_strfreev (values);</span></span>
<span id="L787"><span class="lineNum">     787</span> <span class="tlaGNC">           2 :             g_strfreev (str_op);</span></span>
<span id="L788"><span class="lineNum">     788</span> <span class="tlaGNC">           2 :             continue;</span></span>
<span id="L789"><span class="lineNum">     789</span>              :           }</span>
<span id="L790"><span class="lineNum">     790</span>              : </span>
<span id="L791"><span class="lineNum">     791</span> <span class="tlaGNC">         175 :           op_s = g_new0 (tensor_transform_operator_s, 1);</span></span>
<span id="L792"><span class="lineNum">     792</span> <span class="tlaGNC">         175 :           g_assert (op_s);</span></span>
<span id="L793"><span class="lineNum">     793</span>              : </span>
<span id="L794"><span class="lineNum">     794</span> <span class="tlaGNC">         175 :           op_s-&gt;op = gst_tensor_transform_get_operator (str_op[0]);</span></span>
<span id="L795"><span class="lineNum">     795</span> <span class="tlaGNC">         175 :           op_s-&gt;applying_ch = -1;       /* -1 means applying to all channels */</span></span>
<span id="L796"><span class="lineNum">     796</span> <span class="tlaGNC">         175 :           switch (op_s-&gt;op) {</span></span>
<span id="L797"><span class="lineNum">     797</span> <span class="tlaGNC">          60 :             case GTT_OP_TYPECAST:</span></span>
<span id="L798"><span class="lineNum">     798</span> <span class="tlaGNC">          60 :               if (num_op &gt; 1 &amp;&amp; str_op[1]) {</span></span>
<span id="L799"><span class="lineNum">     799</span> <span class="tlaGNC">          60 :                 op_s-&gt;value.type = gst_tensor_get_type (values[0]);</span></span>
<span id="L800"><span class="lineNum">     800</span> <span class="tlaGNC">          60 :                 filter-&gt;data_arithmetic.out_type = op_s-&gt;value.type;</span></span>
<span id="L801"><span class="lineNum">     801</span>              :               } else {</span>
<span id="L802"><span class="lineNum">     802</span> <span class="tlaUNC tlaBgUNC">           0 :                 GST_WARNING_OBJECT (filter, &quot;Invalid option for typecast %s&quot;,</span></span>
<span id="L803"><span class="lineNum">     803</span>              :                     str_operators[i]);</span>
<span id="L804"><span class="lineNum">     804</span> <span class="tlaUNC">           0 :                 op_s-&gt;op = GTT_OP_UNKNOWN;</span></span>
<span id="L805"><span class="lineNum">     805</span>              :               }</span>
<span id="L806"><span class="lineNum">     806</span> <span class="tlaGNC tlaBgGNC">          60 :               break;</span></span>
<span id="L807"><span class="lineNum">     807</span> <span class="tlaGNC">         115 :             case GTT_OP_ADD:</span></span>
<span id="L808"><span class="lineNum">     808</span>              :             case GTT_OP_MUL:</span>
<span id="L809"><span class="lineNum">     809</span>              :             case GTT_OP_DIV:</span>
<span id="L810"><span class="lineNum">     810</span> <span class="tlaGNC">         115 :               if (num_op &gt; 1 &amp;&amp; str_op[1]) {</span></span>
<span id="L811"><span class="lineNum">     811</span>              :                 /* get operand */</span>
<span id="L812"><span class="lineNum">     812</span> <span class="tlaGNC">         115 :                 if (strchr (values[0], '.') || strchr (values[0], 'e') ||</span></span>
<span id="L813"><span class="lineNum">     813</span> <span class="tlaGNC">         115 :                     strchr (values[0], 'E')) {</span></span>
<span id="L814"><span class="lineNum">     814</span>              :                   double val;</span>
<span id="L815"><span class="lineNum">     815</span>              : </span>
<span id="L816"><span class="lineNum">     816</span> <span class="tlaGNC">          79 :                   val = g_ascii_strtod (values[0], NULL);</span></span>
<span id="L817"><span class="lineNum">     817</span> <span class="tlaGNC">          79 :                   gst_tensor_data_set (&amp;op_s-&gt;value, _NNS_FLOAT64, &amp;val);</span></span>
<span id="L818"><span class="lineNum">     818</span>              :                 } else {</span>
<span id="L819"><span class="lineNum">     819</span>              :                   int64_t val;</span>
<span id="L820"><span class="lineNum">     820</span>              : </span>
<span id="L821"><span class="lineNum">     821</span> <span class="tlaGNC">          36 :                   val = g_ascii_strtoll (values[0], NULL, 10);</span></span>
<span id="L822"><span class="lineNum">     822</span> <span class="tlaGNC">          36 :                   gst_tensor_data_set (&amp;op_s-&gt;value, _NNS_INT64, &amp;val);</span></span>
<span id="L823"><span class="lineNum">     823</span>              :                 }</span>
<span id="L824"><span class="lineNum">     824</span>              : </span>
<span id="L825"><span class="lineNum">     825</span> <span class="tlaGNC">         115 :                 if (filter-&gt;data_arithmetic.per_channel_arith &amp;&amp; num_values &gt; 1) {</span></span>
<span id="L826"><span class="lineNum">     826</span> <span class="tlaGNC">          11 :                   op_s-&gt;applying_ch = g_ascii_strtoll (values[1], NULL, 10);</span></span>
<span id="L827"><span class="lineNum">     827</span>              :                 }</span>
<span id="L828"><span class="lineNum">     828</span>              : </span>
<span id="L829"><span class="lineNum">     829</span>              :               } else {</span>
<span id="L830"><span class="lineNum">     830</span> <span class="tlaUNC tlaBgUNC">           0 :                 GST_WARNING_OBJECT (filter,</span></span>
<span id="L831"><span class="lineNum">     831</span>              :                     &quot;Invalid option for arithmetic %s&quot;, str_operators[i]);</span>
<span id="L832"><span class="lineNum">     832</span> <span class="tlaUNC">           0 :                 op_s-&gt;op = GTT_OP_UNKNOWN;</span></span>
<span id="L833"><span class="lineNum">     833</span>              :               }</span>
<span id="L834"><span class="lineNum">     834</span> <span class="tlaGNC tlaBgGNC">         115 :               break;</span></span>
<span id="L835"><span class="lineNum">     835</span> <span class="tlaUNC tlaBgUNC">           0 :             default:</span></span>
<span id="L836"><span class="lineNum">     836</span> <span class="tlaUNC">           0 :               GST_WARNING_OBJECT (filter, &quot;Unknown operator %s&quot;, str_op[0]);</span></span>
<span id="L837"><span class="lineNum">     837</span> <span class="tlaUNC">           0 :               break;</span></span>
<span id="L838"><span class="lineNum">     838</span>              :           }</span>
<span id="L839"><span class="lineNum">     839</span>              : </span>
<span id="L840"><span class="lineNum">     840</span>              :           /* append operator */</span>
<span id="L841"><span class="lineNum">     841</span> <span class="tlaGNC tlaBgGNC">         175 :           if (op_s-&gt;op != GTT_OP_UNKNOWN) {</span></span>
<span id="L842"><span class="lineNum">     842</span> <span class="tlaGNC">         175 :             filter-&gt;operators = g_slist_append (filter-&gt;operators, op_s);</span></span>
<span id="L843"><span class="lineNum">     843</span>              :           } else {</span>
<span id="L844"><span class="lineNum">     844</span> <span class="tlaUNC tlaBgUNC">           0 :             g_free (op_s);</span></span>
<span id="L845"><span class="lineNum">     845</span>              :           }</span>
<span id="L846"><span class="lineNum">     846</span>              : </span>
<span id="L847"><span class="lineNum">     847</span> <span class="tlaGNC tlaBgGNC">         175 :           g_strfreev (values);</span></span>
<span id="L848"><span class="lineNum">     848</span>              :         } else {</span>
<span id="L849"><span class="lineNum">     849</span> <span class="tlaGNC">           2 :           GST_WARNING_OBJECT (filter, &quot;Invalid option %s&quot;, str_operators[i]);</span></span>
<span id="L850"><span class="lineNum">     850</span>              :         }</span>
<span id="L851"><span class="lineNum">     851</span>              : </span>
<span id="L852"><span class="lineNum">     852</span> <span class="tlaGNC">         177 :         g_strfreev (str_op);</span></span>
<span id="L853"><span class="lineNum">     853</span>              :       }</span>
<span id="L854"><span class="lineNum">     854</span>              : </span>
<span id="L855"><span class="lineNum">     855</span> <span class="tlaGNC">          77 :       ret = filter-&gt;loaded = (filter-&gt;operators != NULL);</span></span>
<span id="L856"><span class="lineNum">     856</span> <span class="tlaGNC">          77 :       g_strfreev (str_operators);</span></span>
<span id="L857"><span class="lineNum">     857</span> <span class="tlaGNC">          77 :       g_free (str_option);</span></span>
<span id="L858"><span class="lineNum">     858</span> <span class="tlaGNC">          77 :       break;</span></span>
<span id="L859"><span class="lineNum">     859</span>              :     }</span>
<span id="L860"><span class="lineNum">     860</span> <span class="tlaGNC">          20 :     case GTT_TRANSPOSE:</span></span>
<span id="L861"><span class="lineNum">     861</span>              :     {</span>
<span id="L862"><span class="lineNum">     862</span>              :       int i;</span>
<span id="L863"><span class="lineNum">     863</span> <span class="tlaGNC">          20 :       gchar **strv = NULL;</span></span>
<span id="L864"><span class="lineNum">     864</span>              : </span>
<span id="L865"><span class="lineNum">     865</span> <span class="tlaGNC">          20 :       if (!g_regex_match_simple (REGEX_TRANSPOSE_OPTION, filter-&gt;option,</span></span>
<span id="L866"><span class="lineNum">     866</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L867"><span class="lineNum">     867</span> <span class="tlaGNC">           4 :         ml_loge</span></span>
<span id="L868"><span class="lineNum">     868</span>              :             (&quot;%s: transpose: \'%s\' is not valid option string: it should be in the form of NEW_IDX_DIM0:NEW_IDX_DIM1:NEW_IDX_DIM2:3 (Now transpose mode's rank is fixed to 3. Note that the index of the last dim is always fixed to 3)\n&quot;,</span>
<span id="L869"><span class="lineNum">     869</span>              :             filter_name, filter-&gt;option);</span>
<span id="L870"><span class="lineNum">     870</span> <span class="tlaGNC">           4 :         break;</span></span>
<span id="L871"><span class="lineNum">     871</span>              :       }</span>
<span id="L872"><span class="lineNum">     872</span>              : </span>
<span id="L873"><span class="lineNum">     873</span> <span class="tlaGNC">          16 :       strv = g_strsplit (filter-&gt;option, &quot;:&quot;, NNS_TENSOR_TRANSPOSE_RANK_LIMIT);</span></span>
<span id="L874"><span class="lineNum">     874</span> <span class="tlaGNC">          80 :       for (i = 0; i &lt; NNS_TENSOR_TRANSPOSE_RANK_LIMIT; i++) {</span></span>
<span id="L875"><span class="lineNum">     875</span> <span class="tlaGNC">          64 :         filter-&gt;data_transpose.trans_order[i] =</span></span>
<span id="L876"><span class="lineNum">     876</span> <span class="tlaGNC">          64 :             (uint8_t) g_ascii_strtoull (strv[i], NULL, 10);</span></span>
<span id="L877"><span class="lineNum">     877</span>              :       }</span>
<span id="L878"><span class="lineNum">     878</span>              : </span>
<span id="L879"><span class="lineNum">     879</span> <span class="tlaGNC">          16 :       ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L880"><span class="lineNum">     880</span> <span class="tlaGNC">          16 :       g_strfreev (strv);</span></span>
<span id="L881"><span class="lineNum">     881</span> <span class="tlaGNC">          16 :       break;</span></span>
<span id="L882"><span class="lineNum">     882</span>              :     }</span>
<span id="L883"><span class="lineNum">     883</span> <span class="tlaGNC">           9 :     case GTT_STAND:</span></span>
<span id="L884"><span class="lineNum">     884</span>              :     {</span>
<span id="L885"><span class="lineNum">     885</span> <span class="tlaGNC">           9 :       gchar **options = NULL;</span></span>
<span id="L886"><span class="lineNum">     886</span>              :       guint i, num_options;</span>
<span id="L887"><span class="lineNum">     887</span>              : </span>
<span id="L888"><span class="lineNum">     888</span> <span class="tlaGNC">           9 :       if (!g_regex_match_simple (REGEX_STAND_OPTION, filter-&gt;option,</span></span>
<span id="L889"><span class="lineNum">     889</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L890"><span class="lineNum">     890</span> <span class="tlaGNC">           5 :         ml_loge</span></span>
<span id="L891"><span class="lineNum">     891</span>              :             (&quot;%s: stand: \'%s\' is not a valid option string: it should be in the form of (default|dc-average)[:TYPE][,per-channel:(false|true)]\n&quot;,</span>
<span id="L892"><span class="lineNum">     892</span>              :             filter_name, filter-&gt;option);</span>
<span id="L893"><span class="lineNum">     893</span> <span class="tlaGNC">           5 :         break;</span></span>
<span id="L894"><span class="lineNum">     894</span>              :       }</span>
<span id="L895"><span class="lineNum">     895</span>              : </span>
<span id="L896"><span class="lineNum">     896</span> <span class="tlaGNC">           4 :       filter-&gt;data_stand.out_type = _NNS_END;</span></span>
<span id="L897"><span class="lineNum">     897</span> <span class="tlaGNC">           4 :       filter-&gt;data_stand.per_channel = FALSE;</span></span>
<span id="L898"><span class="lineNum">     898</span>              : </span>
<span id="L899"><span class="lineNum">     899</span> <span class="tlaGNC">           4 :       options = g_strsplit (filter-&gt;option, &quot;,&quot;, -1);</span></span>
<span id="L900"><span class="lineNum">     900</span> <span class="tlaGNC">           4 :       num_options = g_strv_length (options);</span></span>
<span id="L901"><span class="lineNum">     901</span>              : </span>
<span id="L902"><span class="lineNum">     902</span> <span class="tlaGNC">          10 :       for (i = 0; i &lt; num_options; i++) {</span></span>
<span id="L903"><span class="lineNum">     903</span> <span class="tlaGNC">           6 :         gchar **strv = g_strsplit (options[i], &quot;:&quot;, -1);</span></span>
<span id="L904"><span class="lineNum">     904</span>              : </span>
<span id="L905"><span class="lineNum">     905</span> <span class="tlaGNC">           6 :         if (g_ascii_strcasecmp (strv[0], &quot;default&quot;) == 0 ||</span></span>
<span id="L906"><span class="lineNum">     906</span> <span class="tlaGNC">           4 :             g_ascii_strcasecmp (strv[0], &quot;dc-average&quot;) == 0) {</span></span>
<span id="L907"><span class="lineNum">     907</span> <span class="tlaGNC">           4 :           filter-&gt;data_stand.mode =</span></span>
<span id="L908"><span class="lineNum">     908</span> <span class="tlaGNC">           4 :               gst_tensor_transform_get_stand_mode (strv[0]);</span></span>
<span id="L909"><span class="lineNum">     909</span> <span class="tlaGNC">           6 :           if (g_strv_length (strv) &gt; 1)</span></span>
<span id="L910"><span class="lineNum">     910</span> <span class="tlaGNC">           2 :             filter-&gt;data_stand.out_type = gst_tensor_get_type (strv[1]);</span></span>
<span id="L911"><span class="lineNum">     911</span> <span class="tlaGNC">           2 :         } else if (g_ascii_strcasecmp (strv[0], &quot;per-channel&quot;) == 0) {</span></span>
<span id="L912"><span class="lineNum">     912</span> <span class="tlaGNC">           2 :           if (g_strv_length (strv) &gt; 1 &amp;&amp;</span></span>
<span id="L913"><span class="lineNum">     913</span> <span class="tlaGNC">           2 :               g_ascii_strcasecmp (strv[1], &quot;true&quot;) == 0)</span></span>
<span id="L914"><span class="lineNum">     914</span> <span class="tlaGNC">           2 :             filter-&gt;data_stand.per_channel = TRUE;</span></span>
<span id="L915"><span class="lineNum">     915</span>              :         } else {</span>
<span id="L916"><span class="lineNum">     916</span> <span class="tlaUNC tlaBgUNC">           0 :           filter-&gt;data_stand.mode = STAND_END;</span></span>
<span id="L917"><span class="lineNum">     917</span> <span class="tlaUNC">           0 :           ml_logw (&quot;Unknown option for stand mode: %s&quot;, strv[0]);</span></span>
<span id="L918"><span class="lineNum">     918</span>              :         }</span>
<span id="L919"><span class="lineNum">     919</span>              : </span>
<span id="L920"><span class="lineNum">     920</span> <span class="tlaGNC tlaBgGNC">           6 :         g_strfreev (strv);</span></span>
<span id="L921"><span class="lineNum">     921</span>              :       }</span>
<span id="L922"><span class="lineNum">     922</span>              : </span>
<span id="L923"><span class="lineNum">     923</span> <span class="tlaGNC">           4 :       g_strfreev (options);</span></span>
<span id="L924"><span class="lineNum">     924</span> <span class="tlaGNC">           4 :       ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L925"><span class="lineNum">     925</span> <span class="tlaGNC">           4 :       break;</span></span>
<span id="L926"><span class="lineNum">     926</span>              :     }</span>
<span id="L927"><span class="lineNum">     927</span> <span class="tlaGNC">          10 :     case GTT_CLAMP:</span></span>
<span id="L928"><span class="lineNum">     928</span>              :     {</span>
<span id="L929"><span class="lineNum">     929</span> <span class="tlaGNC">          10 :       gchar **strv = NULL;</span></span>
<span id="L930"><span class="lineNum">     930</span>              : </span>
<span id="L931"><span class="lineNum">     931</span> <span class="tlaGNC">          10 :       if (!g_regex_match_simple (REGEX_CLAMP_OPTION, filter-&gt;option,</span></span>
<span id="L932"><span class="lineNum">     932</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L933"><span class="lineNum">     933</span> <span class="tlaGNC">           1 :         ml_loge</span></span>
<span id="L934"><span class="lineNum">     934</span>              :             (&quot;%s: clamp: \'%s\' is not valid option string: it should be in the form of [CLAMP_MIN:CLAMP_MAX]\n&quot;,</span>
<span id="L935"><span class="lineNum">     935</span>              :             filter_name, filter-&gt;option);</span>
<span id="L936"><span class="lineNum">     936</span> <span class="tlaGNC">           1 :         break;</span></span>
<span id="L937"><span class="lineNum">     937</span>              :       }</span>
<span id="L938"><span class="lineNum">     938</span>              : </span>
<span id="L939"><span class="lineNum">     939</span> <span class="tlaGNC">           9 :       strv = g_strsplit (filter-&gt;option, &quot;:&quot;, 2);</span></span>
<span id="L940"><span class="lineNum">     940</span>              : </span>
<span id="L941"><span class="lineNum">     941</span> <span class="tlaGNC">           9 :       filter-&gt;data_clamp.min = g_ascii_strtod (strv[0], NULL);</span></span>
<span id="L942"><span class="lineNum">     942</span> <span class="tlaGNC">           9 :       if (errno == ERANGE) {</span></span>
<span id="L943"><span class="lineNum">     943</span> <span class="tlaGNC">           1 :         ml_loge (&quot;%s: clamp: CLAMP_MIN value has an invalid range\n&quot;,</span></span>
<span id="L944"><span class="lineNum">     944</span>              :             filter_name);</span>
<span id="L945"><span class="lineNum">     945</span> <span class="tlaGNC">           1 :         g_strfreev (strv);</span></span>
<span id="L946"><span class="lineNum">     946</span> <span class="tlaGNC">           1 :         break;</span></span>
<span id="L947"><span class="lineNum">     947</span>              :       }</span>
<span id="L948"><span class="lineNum">     948</span> <span class="tlaGNC">           8 :       filter-&gt;data_clamp.max = g_ascii_strtod (strv[1], NULL);</span></span>
<span id="L949"><span class="lineNum">     949</span> <span class="tlaGNC">           8 :       if (errno == ERANGE) {</span></span>
<span id="L950"><span class="lineNum">     950</span> <span class="tlaGNC">           1 :         ml_loge (&quot;%s: clamp: CLAMP_MAX value has an invalid range\n&quot;,</span></span>
<span id="L951"><span class="lineNum">     951</span>              :             filter_name);</span>
<span id="L952"><span class="lineNum">     952</span> <span class="tlaGNC">           1 :         g_strfreev (strv);</span></span>
<span id="L953"><span class="lineNum">     953</span> <span class="tlaGNC">           1 :         break;</span></span>
<span id="L954"><span class="lineNum">     954</span>              :       }</span>
<span id="L955"><span class="lineNum">     955</span>              : </span>
<span id="L956"><span class="lineNum">     956</span> <span class="tlaGNC">           7 :       g_strfreev (strv);</span></span>
<span id="L957"><span class="lineNum">     957</span>              : </span>
<span id="L958"><span class="lineNum">     958</span> <span class="tlaGNC">           7 :       if (filter-&gt;data_clamp.min &gt; filter-&gt;data_clamp.max) {</span></span>
<span id="L959"><span class="lineNum">     959</span> <span class="tlaGNC">           2 :         ml_loge (&quot;%s: clamp: CLAMP_MIN is larger than CLAMP_MAX\n&quot;,</span></span>
<span id="L960"><span class="lineNum">     960</span>              :             filter_name);</span>
<span id="L961"><span class="lineNum">     961</span> <span class="tlaGNC">           2 :         break;</span></span>
<span id="L962"><span class="lineNum">     962</span>              :       }</span>
<span id="L963"><span class="lineNum">     963</span>              : </span>
<span id="L964"><span class="lineNum">     964</span> <span class="tlaGNC">           5 :       ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L965"><span class="lineNum">     965</span> <span class="tlaGNC">           5 :       break;</span></span>
<span id="L966"><span class="lineNum">     966</span>              :     }</span>
<span id="L967"><span class="lineNum">     967</span> <span class="tlaGNC">           4 :     case GTT_PADDING:</span></span>
<span id="L968"><span class="lineNum">     968</span>              :     {</span>
<span id="L969"><span class="lineNum">     969</span> <span class="tlaGNC">           4 :       gchar **options = NULL;</span></span>
<span id="L970"><span class="lineNum">     970</span>              :       guint i, num_options;</span>
<span id="L971"><span class="lineNum">     971</span>              : </span>
<span id="L972"><span class="lineNum">     972</span> <span class="tlaGNC">           4 :       if (!g_regex_match_simple (REGEX_PADDING_OPTION, filter-&gt;option,</span></span>
<span id="L973"><span class="lineNum">     973</span>              :               G_REGEX_CASELESS, 0)) {</span>
<span id="L974"><span class="lineNum">     974</span> <span class="tlaUNC tlaBgUNC">           0 :         ml_loge</span></span>
<span id="L975"><span class="lineNum">     975</span>              :             (&quot;%s: padding: \'%s\' is not valid option string: it should be in the form of left|right|top|bottom|front|back:PADDING,[layout:(NCHW|NHWC)]\n&quot;,</span>
<span id="L976"><span class="lineNum">     976</span>              :             filter_name, filter-&gt;option);</span>
<span id="L977"><span class="lineNum">     977</span> <span class="tlaUNC">           0 :         break;</span></span>
<span id="L978"><span class="lineNum">     978</span>              :       }</span>
<span id="L979"><span class="lineNum">     979</span>              : </span>
<span id="L980"><span class="lineNum">     980</span> <span class="tlaGNC tlaBgGNC">          68 :       for (i = 0; i &lt; NNS_TENSOR_RANK_LIMIT; i++)</span></span>
<span id="L981"><span class="lineNum">     981</span> <span class="tlaGNC">          64 :         filter-&gt;data_padding.pad[i] = 0;</span></span>
<span id="L982"><span class="lineNum">     982</span> <span class="tlaGNC">           4 :       filter-&gt;data_padding.layout = _NNS_LAYOUT_ANY;</span></span>
<span id="L983"><span class="lineNum">     983</span>              : </span>
<span id="L984"><span class="lineNum">     984</span> <span class="tlaGNC">           4 :       options = g_strsplit (filter-&gt;option, &quot;,&quot;, -1);</span></span>
<span id="L985"><span class="lineNum">     985</span> <span class="tlaGNC">           4 :       num_options = g_strv_length (options);</span></span>
<span id="L986"><span class="lineNum">     986</span>              : </span>
<span id="L987"><span class="lineNum">     987</span> <span class="tlaGNC">          23 :       for (i = 0; i &lt; num_options; i++) {</span></span>
<span id="L988"><span class="lineNum">     988</span> <span class="tlaGNC">          19 :         gchar **strv = g_strsplit (options[i], &quot;:&quot;, 2);</span></span>
<span id="L989"><span class="lineNum">     989</span> <span class="tlaGNC">          19 :         if (g_ascii_strcasecmp (strv[0], &quot;left&quot;) == 0) {</span></span>
<span id="L990"><span class="lineNum">     990</span> <span class="tlaGNC">           4 :           filter-&gt;data_padding.pad[PADDING_LEFT] =</span></span>
<span id="L991"><span class="lineNum">     991</span> <span class="tlaGNC">           4 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L992"><span class="lineNum">     992</span> <span class="tlaGNC">          15 :         } else if (g_ascii_strcasecmp (strv[0], &quot;right&quot;) == 0) {</span></span>
<span id="L993"><span class="lineNum">     993</span> <span class="tlaGNC">           4 :           filter-&gt;data_padding.pad[PADDING_RIGHT] =</span></span>
<span id="L994"><span class="lineNum">     994</span> <span class="tlaGNC">           4 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L995"><span class="lineNum">     995</span> <span class="tlaGNC">          11 :         } else if (g_ascii_strcasecmp (strv[0], &quot;top&quot;) == 0) {</span></span>
<span id="L996"><span class="lineNum">     996</span> <span class="tlaGNC">           3 :           filter-&gt;data_padding.pad[PADDING_TOP] =</span></span>
<span id="L997"><span class="lineNum">     997</span> <span class="tlaGNC">           3 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L998"><span class="lineNum">     998</span> <span class="tlaGNC">           8 :         } else if (g_ascii_strcasecmp (strv[0], &quot;bottom&quot;) == 0) {</span></span>
<span id="L999"><span class="lineNum">     999</span> <span class="tlaGNC">           3 :           filter-&gt;data_padding.pad[PADDING_BOTTOM] =</span></span>
<span id="L1000"><span class="lineNum">    1000</span> <span class="tlaGNC">           3 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L1001"><span class="lineNum">    1001</span> <span class="tlaGNC">           5 :         } else if (g_ascii_strcasecmp (strv[0], &quot;front&quot;) == 0) {</span></span>
<span id="L1002"><span class="lineNum">    1002</span> <span class="tlaGNC">           2 :           filter-&gt;data_padding.pad[PADDING_FRONT] =</span></span>
<span id="L1003"><span class="lineNum">    1003</span> <span class="tlaGNC">           2 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L1004"><span class="lineNum">    1004</span> <span class="tlaGNC">           3 :         } else if (g_ascii_strcasecmp (strv[0], &quot;back&quot;) == 0) {</span></span>
<span id="L1005"><span class="lineNum">    1005</span> <span class="tlaGNC">           2 :           filter-&gt;data_padding.pad[PADDING_BACK] =</span></span>
<span id="L1006"><span class="lineNum">    1006</span> <span class="tlaGNC">           2 :               (guint) g_ascii_strtoull (strv[1], NULL, 10);</span></span>
<span id="L1007"><span class="lineNum">    1007</span> <span class="tlaGNC">           1 :         } else if (g_ascii_strcasecmp (strv[0], &quot;layout&quot;) == 0) {</span></span>
<span id="L1008"><span class="lineNum">    1008</span> <span class="tlaGNC">           1 :           if (g_ascii_strcasecmp (strv[1], &quot;NHWC&quot;) == 0)</span></span>
<span id="L1009"><span class="lineNum">    1009</span> <span class="tlaGNC">           1 :             filter-&gt;data_padding.layout = _NNS_LAYOUT_NHWC;</span></span>
<span id="L1010"><span class="lineNum">    1010</span>              :           else</span>
<span id="L1011"><span class="lineNum">    1011</span> <span class="tlaUNC tlaBgUNC">           0 :             filter-&gt;data_padding.layout = _NNS_LAYOUT_NCHW;</span></span>
<span id="L1012"><span class="lineNum">    1012</span>              :         } else {</span>
<span id="L1013"><span class="lineNum">    1013</span> <span class="tlaUNC">           0 :           ml_logw (&quot;Unknown option for padding mode: %s&quot;, strv[0]);</span></span>
<span id="L1014"><span class="lineNum">    1014</span>              :         }</span>
<span id="L1015"><span class="lineNum">    1015</span> <span class="tlaGNC tlaBgGNC">          19 :         g_strfreev (strv);</span></span>
<span id="L1016"><span class="lineNum">    1016</span>              :       }</span>
<span id="L1017"><span class="lineNum">    1017</span> <span class="tlaGNC">           4 :       g_strfreev (options);</span></span>
<span id="L1018"><span class="lineNum">    1018</span>              : </span>
<span id="L1019"><span class="lineNum">    1019</span> <span class="tlaGNC">           4 :       if (filter-&gt;data_padding.layout == _NNS_LAYOUT_NHWC) {</span></span>
<span id="L1020"><span class="lineNum">    1020</span> <span class="tlaGNC">           1 :         guint prev_left = filter-&gt;data_padding.pad[PADDING_LEFT],</span></span>
<span id="L1021"><span class="lineNum">    1021</span> <span class="tlaGNC">           1 :             prev_right = filter-&gt;data_padding.pad[PADDING_RIGHT];</span></span>
<span id="L1022"><span class="lineNum">    1022</span> <span class="tlaGNC">           1 :         filter-&gt;data_padding.pad[PADDING_LEFT] =</span></span>
<span id="L1023"><span class="lineNum">    1023</span> <span class="tlaGNC">           1 :             filter-&gt;data_padding.pad[PADDING_FRONT];</span></span>
<span id="L1024"><span class="lineNum">    1024</span> <span class="tlaGNC">           1 :         filter-&gt;data_padding.pad[PADDING_RIGHT] =</span></span>
<span id="L1025"><span class="lineNum">    1025</span> <span class="tlaGNC">           1 :             filter-&gt;data_padding.pad[PADDING_BACK];</span></span>
<span id="L1026"><span class="lineNum">    1026</span> <span class="tlaGNC">           1 :         filter-&gt;data_padding.pad[PADDING_FRONT] = prev_left;</span></span>
<span id="L1027"><span class="lineNum">    1027</span> <span class="tlaGNC">           1 :         filter-&gt;data_padding.pad[PADDING_BACK] = prev_right;</span></span>
<span id="L1028"><span class="lineNum">    1028</span>              :       }</span>
<span id="L1029"><span class="lineNum">    1029</span>              : </span>
<span id="L1030"><span class="lineNum">    1030</span> <span class="tlaGNC">           4 :       ret = filter-&gt;loaded = TRUE;</span></span>
<span id="L1031"><span class="lineNum">    1031</span> <span class="tlaGNC">           4 :       break;</span></span>
<span id="L1032"><span class="lineNum">    1032</span>              :     }</span>
<span id="L1033"><span class="lineNum">    1033</span> <span class="tlaUNC tlaBgUNC">           0 :     default:</span></span>
<span id="L1034"><span class="lineNum">    1034</span> <span class="tlaUNC">           0 :       GST_ERROR_OBJECT (filter, &quot;Cannot identify mode\n&quot;);</span></span>
<span id="L1035"><span class="lineNum">    1035</span> <span class="tlaUNC">           0 :       ret = FALSE;</span></span>
<span id="L1036"><span class="lineNum">    1036</span>              :   }</span>
<span id="L1037"><span class="lineNum">    1037</span>              : </span>
<span id="L1038"><span class="lineNum">    1038</span> <span class="tlaGNC tlaBgGNC">         258 :   g_free (filter_name);</span></span>
<span id="L1039"><span class="lineNum">    1039</span> <span class="tlaGNC">         258 :   return ret;</span></span>
<span id="L1040"><span class="lineNum">    1040</span>              : }</span>
<span id="L1041"><span class="lineNum">    1041</span>              : </span>
<span id="L1042"><span class="lineNum">    1042</span>              : /**</span>
<span id="L1043"><span class="lineNum">    1043</span>              :  * @brief Set property (gst element vmethod)</span>
<span id="L1044"><span class="lineNum">    1044</span>              :  */</span>
<span id="L1045"><span class="lineNum">    1045</span>              : static void</span>
<span id="L1046"><span class="lineNum">    1046</span> <span class="tlaGNC">         572 : gst_tensor_transform_set_property (GObject * object, guint prop_id,</span></span>
<span id="L1047"><span class="lineNum">    1047</span>              :     const GValue * value, GParamSpec * pspec)</span>
<span id="L1048"><span class="lineNum">    1048</span>              : {</span>
<span id="L1049"><span class="lineNum">    1049</span> <span class="tlaGNC">         572 :   GstTensorTransform *filter = GST_TENSOR_TRANSFORM (object);</span></span>
<span id="L1050"><span class="lineNum">    1050</span>              : </span>
<span id="L1051"><span class="lineNum">    1051</span> <span class="tlaGNC">         572 :   switch (prop_id) {</span></span>
<span id="L1052"><span class="lineNum">    1052</span> <span class="tlaGNC">           1 :     case PROP_SILENT:</span></span>
<span id="L1053"><span class="lineNum">    1053</span> <span class="tlaGNC">           1 :       filter-&gt;silent = g_value_get_boolean (value);</span></span>
<span id="L1054"><span class="lineNum">    1054</span> <span class="tlaGNC">           1 :       break;</span></span>
<span id="L1055"><span class="lineNum">    1055</span> <span class="tlaGNC">         253 :     case PROP_MODE:</span></span>
<span id="L1056"><span class="lineNum">    1056</span> <span class="tlaGNC">         253 :       filter-&gt;mode = g_value_get_enum (value);</span></span>
<span id="L1057"><span class="lineNum">    1057</span> <span class="tlaGNC">         253 :       gst_tensor_transform_set_option_data (filter);</span></span>
<span id="L1058"><span class="lineNum">    1058</span> <span class="tlaGNC">         253 :       break;</span></span>
<span id="L1059"><span class="lineNum">    1059</span> <span class="tlaGNC">         257 :     case PROP_OPTION:</span></span>
<span id="L1060"><span class="lineNum">    1060</span>              :     {</span>
<span id="L1061"><span class="lineNum">    1061</span> <span class="tlaGNC">         257 :       gchar *backup_option = filter-&gt;option;</span></span>
<span id="L1062"><span class="lineNum">    1062</span> <span class="tlaGNC">         257 :       filter-&gt;option = g_value_dup_string (value);</span></span>
<span id="L1063"><span class="lineNum">    1063</span> <span class="tlaGNC">         257 :       if (gst_tensor_transform_set_option_data (filter)) {</span></span>
<span id="L1064"><span class="lineNum">    1064</span> <span class="tlaGNC">         226 :         silent_debug (filter, &quot;Option = %s --&gt; %s\n&quot;, backup_option,</span></span>
<span id="L1065"><span class="lineNum">    1065</span>              :             filter-&gt;option);</span>
<span id="L1066"><span class="lineNum">    1066</span> <span class="tlaGNC">         226 :         g_free (backup_option);</span></span>
<span id="L1067"><span class="lineNum">    1067</span>              :       } else {</span>
<span id="L1068"><span class="lineNum">    1068</span>              :         /* ERROR! Revert the change! */</span>
<span id="L1069"><span class="lineNum">    1069</span> <span class="tlaGNC">          31 :         g_free (filter-&gt;option);</span></span>
<span id="L1070"><span class="lineNum">    1070</span> <span class="tlaGNC">          31 :         filter-&gt;option = backup_option;</span></span>
<span id="L1071"><span class="lineNum">    1071</span> <span class="tlaGNC">          31 :         gst_tensor_transform_set_option_data (filter);</span></span>
<span id="L1072"><span class="lineNum">    1072</span>              :       }</span>
<span id="L1073"><span class="lineNum">    1073</span> <span class="tlaGNC">         257 :       break;</span></span>
<span id="L1074"><span class="lineNum">    1074</span>              :     }</span>
<span id="L1075"><span class="lineNum">    1075</span> <span class="tlaGNC">          58 :     case PROP_ACCELERATION:</span></span>
<span id="L1076"><span class="lineNum">    1076</span>              : #ifdef HAVE_ORC</span>
<span id="L1077"><span class="lineNum">    1077</span> <span class="tlaGNC">          58 :       filter-&gt;acceleration = g_value_get_boolean (value);</span></span>
<span id="L1078"><span class="lineNum">    1078</span> <span class="tlaGNC">          58 :       silent_debug (filter, &quot;acceleration = %d\n&quot;, filter-&gt;acceleration);</span></span>
<span id="L1079"><span class="lineNum">    1079</span>              : #else</span>
<span id="L1080"><span class="lineNum">    1080</span>              :       GST_WARNING_OBJECT (filter, &quot;Orc acceleration is not supported&quot;);</span>
<span id="L1081"><span class="lineNum">    1081</span>              :       filter-&gt;acceleration = FALSE;</span>
<span id="L1082"><span class="lineNum">    1082</span>              : #endif</span>
<span id="L1083"><span class="lineNum">    1083</span> <span class="tlaGNC">          58 :       break;</span></span>
<span id="L1084"><span class="lineNum">    1084</span> <span class="tlaGNC">           3 :     case PROP_APPLY:</span></span>
<span id="L1085"><span class="lineNum">    1085</span>              :     {</span>
<span id="L1086"><span class="lineNum">    1086</span>              :       gint64 val;</span>
<span id="L1087"><span class="lineNum">    1087</span> <span class="tlaGNC">           3 :       const gchar *param = g_value_get_string (value);</span></span>
<span id="L1088"><span class="lineNum">    1088</span> <span class="tlaGNC">           3 :       gchar **strv = g_strsplit_set (param, &quot;,&quot;, -1);</span></span>
<span id="L1089"><span class="lineNum">    1089</span> <span class="tlaGNC">           3 :       guint i, num = g_strv_length (strv);</span></span>
<span id="L1090"><span class="lineNum">    1090</span> <span class="tlaGNC">           3 :       gchar *endptr = NULL;</span></span>
<span id="L1091"><span class="lineNum">    1091</span>              : </span>
<span id="L1092"><span class="lineNum">    1092</span> <span class="tlaGNC">          10 :       for (i = 0; i &lt; num; i++) {</span></span>
<span id="L1093"><span class="lineNum">    1093</span> <span class="tlaGNC">           7 :         errno = 0;</span></span>
<span id="L1094"><span class="lineNum">    1094</span> <span class="tlaGNC">           7 :         val = g_ascii_strtoll (strv[i], &amp;endptr, 10);</span></span>
<span id="L1095"><span class="lineNum">    1095</span> <span class="tlaGNC">           7 :         if (errno == ERANGE || errno == EINVAL || (endptr == strv[i])) {</span></span>
<span id="L1096"><span class="lineNum">    1096</span> <span class="tlaUNC tlaBgUNC">           0 :           ml_loge (&quot;Cannot convert string %s to a gint64 value&quot;, strv[i]);</span></span>
<span id="L1097"><span class="lineNum">    1097</span>              :         }</span>
<span id="L1098"><span class="lineNum">    1098</span> <span class="tlaGNC tlaBgGNC">           7 :         filter-&gt;apply = g_list_append (filter-&gt;apply, GINT_TO_POINTER (val));</span></span>
<span id="L1099"><span class="lineNum">    1099</span>              :       }</span>
<span id="L1100"><span class="lineNum">    1100</span> <span class="tlaGNC">           3 :       g_strfreev (strv);</span></span>
<span id="L1101"><span class="lineNum">    1101</span> <span class="tlaGNC">           3 :       break;</span></span>
<span id="L1102"><span class="lineNum">    1102</span>              :     }</span>
<span id="L1103"><span class="lineNum">    1103</span> <span class="tlaUNC tlaBgUNC">           0 :     default:</span></span>
<span id="L1104"><span class="lineNum">    1104</span> <span class="tlaUNC">           0 :       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);</span></span>
<span id="L1105"><span class="lineNum">    1105</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L1106"><span class="lineNum">    1106</span>              :   }</span>
<span id="L1107"><span class="lineNum">    1107</span> <span class="tlaGNC tlaBgGNC">         572 : }</span></span>
<span id="L1108"><span class="lineNum">    1108</span>              : </span>
<span id="L1109"><span class="lineNum">    1109</span>              : /**</span>
<span id="L1110"><span class="lineNum">    1110</span>              :  * @brief Get property (gst element vmethod)</span>
<span id="L1111"><span class="lineNum">    1111</span>              :  */</span>
<span id="L1112"><span class="lineNum">    1112</span>              : static void</span>
<span id="L1113"><span class="lineNum">    1113</span> <span class="tlaGNC">          41 : gst_tensor_transform_get_property (GObject * object, guint prop_id,</span></span>
<span id="L1114"><span class="lineNum">    1114</span>              :     GValue * value, GParamSpec * pspec)</span>
<span id="L1115"><span class="lineNum">    1115</span>              : {</span>
<span id="L1116"><span class="lineNum">    1116</span> <span class="tlaGNC">          41 :   GstTensorTransform *filter = GST_TENSOR_TRANSFORM (object);</span></span>
<span id="L1117"><span class="lineNum">    1117</span>              : </span>
<span id="L1118"><span class="lineNum">    1118</span> <span class="tlaGNC">          41 :   switch (prop_id) {</span></span>
<span id="L1119"><span class="lineNum">    1119</span> <span class="tlaGNC">           2 :     case PROP_SILENT:</span></span>
<span id="L1120"><span class="lineNum">    1120</span> <span class="tlaGNC">           2 :       g_value_set_boolean (value, filter-&gt;silent);</span></span>
<span id="L1121"><span class="lineNum">    1121</span> <span class="tlaGNC">           2 :       break;</span></span>
<span id="L1122"><span class="lineNum">    1122</span> <span class="tlaGNC">           1 :     case PROP_MODE:</span></span>
<span id="L1123"><span class="lineNum">    1123</span> <span class="tlaGNC">           1 :       g_value_set_enum (value, filter-&gt;mode);</span></span>
<span id="L1124"><span class="lineNum">    1124</span> <span class="tlaGNC">           1 :       break;</span></span>
<span id="L1125"><span class="lineNum">    1125</span> <span class="tlaGNC">          36 :     case PROP_OPTION:</span></span>
<span id="L1126"><span class="lineNum">    1126</span> <span class="tlaGNC">          36 :       g_value_set_string (value, filter-&gt;option);</span></span>
<span id="L1127"><span class="lineNum">    1127</span> <span class="tlaGNC">          36 :       break;</span></span>
<span id="L1128"><span class="lineNum">    1128</span> <span class="tlaGNC">           2 :     case PROP_ACCELERATION:</span></span>
<span id="L1129"><span class="lineNum">    1129</span> <span class="tlaGNC">           2 :       g_value_set_boolean (value, filter-&gt;acceleration);</span></span>
<span id="L1130"><span class="lineNum">    1130</span> <span class="tlaGNC">           2 :       break;</span></span>
<span id="L1131"><span class="lineNum">    1131</span> <span class="tlaUNC tlaBgUNC">           0 :     case PROP_APPLY:</span></span>
<span id="L1132"><span class="lineNum">    1132</span>              :     {</span>
<span id="L1133"><span class="lineNum">    1133</span>              :       GList *list;</span>
<span id="L1134"><span class="lineNum">    1134</span>              :       gchar *p;</span>
<span id="L1135"><span class="lineNum">    1135</span>              :       GPtrArray *arr;</span>
<span id="L1136"><span class="lineNum">    1136</span>              :       gchar **strings;</span>
<span id="L1137"><span class="lineNum">    1137</span>              : </span>
<span id="L1138"><span class="lineNum">    1138</span> <span class="tlaUNC">           0 :       if (filter-&gt;apply == NULL) {</span></span>
<span id="L1139"><span class="lineNum">    1139</span> <span class="tlaUNC">           0 :         g_value_set_string (value, &quot;&quot;);</span></span>
<span id="L1140"><span class="lineNum">    1140</span> <span class="tlaUNC">           0 :         return;</span></span>
<span id="L1141"><span class="lineNum">    1141</span>              :       }</span>
<span id="L1142"><span class="lineNum">    1142</span>              : </span>
<span id="L1143"><span class="lineNum">    1143</span> <span class="tlaUNC">           0 :       arr = g_ptr_array_new ();</span></span>
<span id="L1144"><span class="lineNum">    1144</span> <span class="tlaUNC">           0 :       for (list = filter-&gt;apply; list != NULL; list = list-&gt;next) {</span></span>
<span id="L1145"><span class="lineNum">    1145</span> <span class="tlaUNC">           0 :         g_ptr_array_add (arr, g_strdup_printf (&quot;%i&quot;,</span></span>
<span id="L1146"><span class="lineNum">    1146</span> <span class="tlaUNC">           0 :                 GPOINTER_TO_INT (list-&gt;data)));</span></span>
<span id="L1147"><span class="lineNum">    1147</span>              :       }</span>
<span id="L1148"><span class="lineNum">    1148</span> <span class="tlaUNC">           0 :       g_ptr_array_add (arr, NULL);</span></span>
<span id="L1149"><span class="lineNum">    1149</span> <span class="tlaUNC">           0 :       strings = (gchar **) g_ptr_array_free (arr, FALSE);</span></span>
<span id="L1150"><span class="lineNum">    1150</span> <span class="tlaUNC">           0 :       p = g_strjoinv (&quot;,&quot;, strings);</span></span>
<span id="L1151"><span class="lineNum">    1151</span>              : </span>
<span id="L1152"><span class="lineNum">    1152</span> <span class="tlaUNC">           0 :       g_strfreev (strings);</span></span>
<span id="L1153"><span class="lineNum">    1153</span> <span class="tlaUNC">           0 :       g_value_take_string (value, p);</span></span>
<span id="L1154"><span class="lineNum">    1154</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L1155"><span class="lineNum">    1155</span>              :     }</span>
<span id="L1156"><span class="lineNum">    1156</span> <span class="tlaUNC">           0 :     case PROP_TRANSPOSE_RANK_LIMIT:</span></span>
<span id="L1157"><span class="lineNum">    1157</span> <span class="tlaUNC">           0 :       g_value_set_uint (value, NNS_TENSOR_TRANSPOSE_RANK_LIMIT);</span></span>
<span id="L1158"><span class="lineNum">    1158</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L1159"><span class="lineNum">    1159</span> <span class="tlaUNC">           0 :     default:</span></span>
<span id="L1160"><span class="lineNum">    1160</span> <span class="tlaUNC">           0 :       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);</span></span>
<span id="L1161"><span class="lineNum">    1161</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L1162"><span class="lineNum">    1162</span>              :   }</span>
<span id="L1163"><span class="lineNum">    1163</span>              : }</span>
<span id="L1164"><span class="lineNum">    1164</span>              : </span>
<span id="L1165"><span class="lineNum">    1165</span>              : /**</span>
<span id="L1166"><span class="lineNum">    1166</span>              :  * @brief Function to finalize instance (gst element vmethod)</span>
<span id="L1167"><span class="lineNum">    1167</span>              :  */</span>
<span id="L1168"><span class="lineNum">    1168</span>              : static void</span>
<span id="L1169"><span class="lineNum">    1169</span> <span class="tlaGNC tlaBgGNC">         239 : gst_tensor_transform_finalize (GObject * object)</span></span>
<span id="L1170"><span class="lineNum">    1170</span>              : {</span>
<span id="L1171"><span class="lineNum">    1171</span>              :   GstTensorTransform *filter;</span>
<span id="L1172"><span class="lineNum">    1172</span>              : </span>
<span id="L1173"><span class="lineNum">    1173</span> <span class="tlaGNC">         239 :   filter = GST_TENSOR_TRANSFORM (object);</span></span>
<span id="L1174"><span class="lineNum">    1174</span>              : </span>
<span id="L1175"><span class="lineNum">    1175</span> <span class="tlaGNC">         239 :   if (filter-&gt;option) {</span></span>
<span id="L1176"><span class="lineNum">    1176</span> <span class="tlaGNC">         200 :     g_free (filter-&gt;option);</span></span>
<span id="L1177"><span class="lineNum">    1177</span> <span class="tlaGNC">         200 :     filter-&gt;option = NULL;</span></span>
<span id="L1178"><span class="lineNum">    1178</span>              :   }</span>
<span id="L1179"><span class="lineNum">    1179</span>              : </span>
<span id="L1180"><span class="lineNum">    1180</span> <span class="tlaGNC">         239 :   if (filter-&gt;operators) {</span></span>
<span id="L1181"><span class="lineNum">    1181</span> <span class="tlaGNC">          60 :     g_slist_free_full (filter-&gt;operators, g_free);</span></span>
<span id="L1182"><span class="lineNum">    1182</span> <span class="tlaGNC">          60 :     filter-&gt;operators = NULL;</span></span>
<span id="L1183"><span class="lineNum">    1183</span>              :   }</span>
<span id="L1184"><span class="lineNum">    1184</span>              : </span>
<span id="L1185"><span class="lineNum">    1185</span> <span class="tlaGNC">         239 :   if (filter-&gt;apply) {</span></span>
<span id="L1186"><span class="lineNum">    1186</span> <span class="tlaGNC">           3 :     g_list_free (filter-&gt;apply);</span></span>
<span id="L1187"><span class="lineNum">    1187</span> <span class="tlaGNC">           3 :     filter-&gt;apply = NULL;</span></span>
<span id="L1188"><span class="lineNum">    1188</span>              :   }</span>
<span id="L1189"><span class="lineNum">    1189</span>              : </span>
<span id="L1190"><span class="lineNum">    1190</span> <span class="tlaGNC">         239 :   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);</span></span>
<span id="L1191"><span class="lineNum">    1191</span> <span class="tlaGNC">         239 : }</span></span>
<span id="L1192"><span class="lineNum">    1192</span>              : </span>
<span id="L1193"><span class="lineNum">    1193</span>              : /**</span>
<span id="L1194"><span class="lineNum">    1194</span>              :  * @brief subrouting for tensor-transform, &quot;dimchg&quot; case.</span>
<span id="L1195"><span class="lineNum">    1195</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1196"><span class="lineNum">    1196</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1197"><span class="lineNum">    1197</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1198"><span class="lineNum">    1198</span>              :  * @param[in] inptr input tensor</span>
<span id="L1199"><span class="lineNum">    1199</span>              :  * @param[out] outptr output tensor</span>
<span id="L1200"><span class="lineNum">    1200</span>              :  * @return Gst flow status</span>
<span id="L1201"><span class="lineNum">    1201</span>              :  */</span>
<span id="L1202"><span class="lineNum">    1202</span>              : static GstFlowReturn</span>
<span id="L1203"><span class="lineNum">    1203</span> <span class="tlaGNC">          52 : gst_tensor_transform_dimchg (GstTensorTransform * filter,</span></span>
<span id="L1204"><span class="lineNum">    1204</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1205"><span class="lineNum">    1205</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1206"><span class="lineNum">    1206</span>              : {</span>
<span id="L1207"><span class="lineNum">    1207</span> <span class="tlaGNC">          52 :   uint32_t *fromDim = in_info-&gt;dimension;</span></span>
<span id="L1208"><span class="lineNum">    1208</span> <span class="tlaGNC">          52 :   uint32_t *toDim = out_info-&gt;dimension;</span></span>
<span id="L1209"><span class="lineNum">    1209</span> <span class="tlaGNC">          52 :   unsigned int from = filter-&gt;data_dimchg.from;</span></span>
<span id="L1210"><span class="lineNum">    1210</span> <span class="tlaGNC">          52 :   unsigned int to = filter-&gt;data_dimchg.to;</span></span>
<span id="L1211"><span class="lineNum">    1211</span>              :   unsigned int i, j, k;</span>
<span id="L1212"><span class="lineNum">    1212</span> <span class="tlaGNC">          52 :   unsigned int loopLimit = 1;</span></span>
<span id="L1213"><span class="lineNum">    1213</span>              :   gsize loopBlockSize, copyblocksize, copyblocklimit;</span>
<span id="L1214"><span class="lineNum">    1214</span>              : </span>
<span id="L1215"><span class="lineNum">    1215</span> <span class="tlaGNC">          52 :   if (from == to) {</span></span>
<span id="L1216"><span class="lineNum">    1216</span>              :     /** Useless memcpy. Do not call this or @todo do &quot;IP&quot; operation */</span>
<span id="L1217"><span class="lineNum">    1217</span> <span class="tlaUNC tlaBgUNC">           0 :     nns_memcpy (outptr, inptr, gst_tensor_info_get_size (in_info));</span></span>
<span id="L1218"><span class="lineNum">    1218</span> <span class="tlaUNC">           0 :     GST_WARNING_OBJECT (filter,</span></span>
<span id="L1219"><span class="lineNum">    1219</span>              :         &quot;Calling tensor_transform with high memcpy overhead WITHOUT any effects! Check your stream whether you really need tensor_transform.\n&quot;);</span>
<span id="L1220"><span class="lineNum">    1220</span> <span class="tlaUNC">           0 :     return GST_FLOW_OK;</span></span>
<span id="L1221"><span class="lineNum">    1221</span>              :   }</span>
<span id="L1222"><span class="lineNum">    1222</span>              : </span>
<span id="L1223"><span class="lineNum">    1223</span> <span class="tlaGNC tlaBgGNC">          52 :   g_assert (from &lt; NNS_TENSOR_RANK_LIMIT);</span></span>
<span id="L1224"><span class="lineNum">    1224</span> <span class="tlaGNC">          52 :   g_assert (to &lt; NNS_TENSOR_RANK_LIMIT);</span></span>
<span id="L1225"><span class="lineNum">    1225</span> <span class="tlaGNC">          52 :   g_assert (fromDim[from] == toDim[to]);</span></span>
<span id="L1226"><span class="lineNum">    1226</span>              : </span>
<span id="L1227"><span class="lineNum">    1227</span> <span class="tlaGNC">          52 :   loopBlockSize = copyblocksize = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1228"><span class="lineNum">    1228</span> <span class="tlaGNC">          52 :   copyblocklimit = 1;</span></span>
<span id="L1229"><span class="lineNum">    1229</span>              : </span>
<span id="L1230"><span class="lineNum">    1230</span> <span class="tlaGNC">          52 :   if (from &lt; to) {</span></span>
<span id="L1231"><span class="lineNum">    1231</span>              :     /**</span>
<span id="L1232"><span class="lineNum">    1232</span>              :      * Smaller-loop-ed a to larger-loop-ed b</span>
<span id="L1233"><span class="lineNum">    1233</span>              :      * E.g., [N][H][W][c] (c:W:H:N) --&gt; [N][c][H][W] (W:H:c:N)</span>
<span id="L1234"><span class="lineNum">    1234</span>              :      *</span>
<span id="L1235"><span class="lineNum">    1235</span>              :      * @todo CRITICAL-TODO: Optimize the performance!</span>
<span id="L1236"><span class="lineNum">    1236</span>              :      */</span>
<span id="L1237"><span class="lineNum">    1237</span> <span class="tlaGNC">         726 :     for (i = NNS_TENSOR_RANK_LIMIT - 1; i &gt; to; i--) {</span></span>
<span id="L1238"><span class="lineNum">    1238</span> <span class="tlaGNC">         674 :       if (toDim[i] == 0)</span></span>
<span id="L1239"><span class="lineNum">    1239</span> <span class="tlaGNC">         620 :         continue;</span></span>
<span id="L1240"><span class="lineNum">    1240</span> <span class="tlaGNC">          54 :       loopLimit *= toDim[i];</span></span>
<span id="L1241"><span class="lineNum">    1241</span>              :     }</span>
<span id="L1242"><span class="lineNum">    1242</span>              : </span>
<span id="L1243"><span class="lineNum">    1243</span> <span class="tlaGNC">         158 :     for (i = 0; i &lt; to; i++) {</span></span>
<span id="L1244"><span class="lineNum">    1244</span> <span class="tlaGNC">         106 :       if (toDim[i] == 0)</span></span>
<span id="L1245"><span class="lineNum">    1245</span> <span class="tlaUNC tlaBgUNC">           0 :         break;</span></span>
<span id="L1246"><span class="lineNum">    1246</span> <span class="tlaGNC tlaBgGNC">         106 :       loopBlockSize *= toDim[i];</span></span>
<span id="L1247"><span class="lineNum">    1247</span>              :     }</span>
<span id="L1248"><span class="lineNum">    1248</span>              : </span>
<span id="L1249"><span class="lineNum">    1249</span> <span class="tlaGNC">          52 :     for (i = 0; i &lt; from; i++) {</span></span>
<span id="L1250"><span class="lineNum">    1250</span> <span class="tlaUNC tlaBgUNC">           0 :       if (fromDim[i] == 0)</span></span>
<span id="L1251"><span class="lineNum">    1251</span> <span class="tlaUNC">           0 :         break;</span></span>
<span id="L1252"><span class="lineNum">    1252</span> <span class="tlaUNC">           0 :       copyblocksize *= fromDim[i];</span></span>
<span id="L1253"><span class="lineNum">    1253</span>              :     }</span>
<span id="L1254"><span class="lineNum">    1254</span> <span class="tlaGNC tlaBgGNC">         158 :     for (i = 0; i &lt; to; i++) {</span></span>
<span id="L1255"><span class="lineNum">    1255</span> <span class="tlaGNC">         106 :       if (toDim[i] == 0)</span></span>
<span id="L1256"><span class="lineNum">    1256</span> <span class="tlaUNC tlaBgUNC">           0 :         break;</span></span>
<span id="L1257"><span class="lineNum">    1257</span> <span class="tlaGNC tlaBgGNC">         106 :       copyblocklimit *= toDim[i];</span></span>
<span id="L1258"><span class="lineNum">    1258</span>              :     }</span>
<span id="L1259"><span class="lineNum">    1259</span>              : </span>
<span id="L1260"><span class="lineNum">    1260</span> <span class="tlaGNC">         228 :     for (i = 0; i &lt; loopLimit; i++) {</span></span>
<span id="L1261"><span class="lineNum">    1261</span>              :       /* [i1][i2][...][iN][b][...] i = i1 x i2 x ... x iN */</span>
<span id="L1262"><span class="lineNum">    1262</span> <span class="tlaGNC">         176 :       uint8_t *destptr = outptr + loopBlockSize * toDim[to] * i;</span></span>
<span id="L1263"><span class="lineNum">    1263</span> <span class="tlaGNC">         176 :       const uint8_t *srcptr = inptr + loopBlockSize * toDim[to] * i;</span></span>
<span id="L1264"><span class="lineNum">    1264</span>              : </span>
<span id="L1265"><span class="lineNum">    1265</span> <span class="tlaGNC">         744 :       for (j = 0; j &lt; toDim[to]; j++) {</span></span>
<span id="L1266"><span class="lineNum">    1266</span> <span class="tlaGNC">         568 :         uint8_t *j_destptr = destptr + loopBlockSize * j;</span></span>
<span id="L1267"><span class="lineNum">    1267</span> <span class="tlaGNC">      121208 :         for (k = 0; k &lt; copyblocklimit; k++) {</span></span>
<span id="L1268"><span class="lineNum">    1268</span> <span class="tlaGNC">      120640 :           nns_memcpy (j_destptr + copyblocksize * k,</span></span>
<span id="L1269"><span class="lineNum">    1269</span>              :               srcptr + k * copyblocksize * toDim[to] + j * copyblocksize,</span>
<span id="L1270"><span class="lineNum">    1270</span>              :               copyblocksize);</span>
<span id="L1271"><span class="lineNum">    1271</span>              :         }</span>
<span id="L1272"><span class="lineNum">    1272</span>              :       }</span>
<span id="L1273"><span class="lineNum">    1273</span>              :     }</span>
<span id="L1274"><span class="lineNum">    1274</span>              :   } else {</span>
<span id="L1275"><span class="lineNum">    1275</span>              :     /**</span>
<span id="L1276"><span class="lineNum">    1276</span>              :      * Larger-loop-ed a to smaller-loop-ed b</span>
<span id="L1277"><span class="lineNum">    1277</span>              :      * E.g., [N][c][H][W] (W:H:c:N) --&gt; [N][H][W][c] (c:W:H:N)</span>
<span id="L1278"><span class="lineNum">    1278</span>              :      * @todo NYI</span>
<span id="L1279"><span class="lineNum">    1279</span>              :      */</span>
<span id="L1280"><span class="lineNum">    1280</span> <span class="tlaUNC tlaBgUNC">           0 :     ml_loge</span></span>
<span id="L1281"><span class="lineNum">    1281</span>              :         (&quot;tensor-transform/dimchg operation is not permitted if from &gt;= to.\n&quot;);</span>
<span id="L1282"><span class="lineNum">    1282</span> <span class="tlaUNC">           0 :     return GST_FLOW_ERROR;</span></span>
<span id="L1283"><span class="lineNum">    1283</span>              :   }</span>
<span id="L1284"><span class="lineNum">    1284</span>              : </span>
<span id="L1285"><span class="lineNum">    1285</span> <span class="tlaGNC tlaBgGNC">          52 :   return GST_FLOW_OK;</span></span>
<span id="L1286"><span class="lineNum">    1286</span>              : }</span>
<span id="L1287"><span class="lineNum">    1287</span>              : </span>
<span id="L1288"><span class="lineNum">    1288</span>              : /**</span>
<span id="L1289"><span class="lineNum">    1289</span>              :  * @brief subrouting for tensor-transform, &quot;typecast&quot; case.</span>
<span id="L1290"><span class="lineNum">    1290</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1291"><span class="lineNum">    1291</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1292"><span class="lineNum">    1292</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1293"><span class="lineNum">    1293</span>              :  * @param[in] inptr input tensor</span>
<span id="L1294"><span class="lineNum">    1294</span>              :  * @param[out] outptr output tensor</span>
<span id="L1295"><span class="lineNum">    1295</span>              :  * @return Gst flow status</span>
<span id="L1296"><span class="lineNum">    1296</span>              :  */</span>
<span id="L1297"><span class="lineNum">    1297</span>              : static GstFlowReturn</span>
<span id="L1298"><span class="lineNum">    1298</span> <span class="tlaGNC">         579 : gst_tensor_transform_typecast (GstTensorTransform * filter,</span></span>
<span id="L1299"><span class="lineNum">    1299</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1300"><span class="lineNum">    1300</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1301"><span class="lineNum">    1301</span>              : {</span>
<span id="L1302"><span class="lineNum">    1302</span>              :   gulong i, num;</span>
<span id="L1303"><span class="lineNum">    1303</span>              :   gsize in_element_size, out_element_size;</span>
<span id="L1304"><span class="lineNum">    1304</span>              : </span>
<span id="L1305"><span class="lineNum">    1305</span> <span class="tlaGNC">         579 :   num = gst_tensor_get_element_count (in_info-&gt;dimension);</span></span>
<span id="L1306"><span class="lineNum">    1306</span>              : </span>
<span id="L1307"><span class="lineNum">    1307</span>              : #ifdef HAVE_ORC</span>
<span id="L1308"><span class="lineNum">    1308</span> <span class="tlaGNC">         579 :   if (filter-&gt;acceleration) {</span></span>
<span id="L1309"><span class="lineNum">    1309</span> <span class="tlaGNC">         457 :     orc_typecast (inptr, outptr, num, in_info-&gt;type, out_info-&gt;type);</span></span>
<span id="L1310"><span class="lineNum">    1310</span> <span class="tlaGNC">         457 :     return GST_FLOW_OK;</span></span>
<span id="L1311"><span class="lineNum">    1311</span>              :   }</span>
<span id="L1312"><span class="lineNum">    1312</span>              : #endif</span>
<span id="L1313"><span class="lineNum">    1313</span>              : </span>
<span id="L1314"><span class="lineNum">    1314</span> <span class="tlaGNC">         122 :   in_element_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1315"><span class="lineNum">    1315</span> <span class="tlaGNC">         122 :   out_element_size = gst_tensor_get_element_size (out_info-&gt;type);</span></span>
<span id="L1316"><span class="lineNum">    1316</span>              : </span>
<span id="L1317"><span class="lineNum">    1317</span> <span class="tlaGNC">       61772 :   for (i = 0; i &lt; num; ++i) {</span></span>
<span id="L1318"><span class="lineNum">    1318</span> <span class="tlaGNC">       61650 :     gst_tensor_data_raw_typecast (</span></span>
<span id="L1319"><span class="lineNum">    1319</span> <span class="tlaGNC">       61650 :         (gpointer) (inptr + in_element_size * i), in_info-&gt;type,</span></span>
<span id="L1320"><span class="lineNum">    1320</span> <span class="tlaGNC">       61650 :         (gpointer) (outptr + out_element_size * i), out_info-&gt;type);</span></span>
<span id="L1321"><span class="lineNum">    1321</span>              :   }</span>
<span id="L1322"><span class="lineNum">    1322</span>              : </span>
<span id="L1323"><span class="lineNum">    1323</span> <span class="tlaGNC">         122 :   return GST_FLOW_OK;</span></span>
<span id="L1324"><span class="lineNum">    1324</span>              : }</span>
<span id="L1325"><span class="lineNum">    1325</span>              : </span>
<span id="L1326"><span class="lineNum">    1326</span>              : /**</span>
<span id="L1327"><span class="lineNum">    1327</span>              :  * @brief subrouting for tensor-transform, &quot;arithmetic&quot; case.</span>
<span id="L1328"><span class="lineNum">    1328</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1329"><span class="lineNum">    1329</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1330"><span class="lineNum">    1330</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1331"><span class="lineNum">    1331</span>              :  * @param[in] inptr input tensor</span>
<span id="L1332"><span class="lineNum">    1332</span>              :  * @param[out] outptr output tensor</span>
<span id="L1333"><span class="lineNum">    1333</span>              :  * @return Gst flow status</span>
<span id="L1334"><span class="lineNum">    1334</span>              :  */</span>
<span id="L1335"><span class="lineNum">    1335</span>              : static GstFlowReturn</span>
<span id="L1336"><span class="lineNum">    1336</span> <span class="tlaGNC">       21495 : gst_tensor_transform_arithmetic (GstTensorTransform * filter,</span></span>
<span id="L1337"><span class="lineNum">    1337</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1338"><span class="lineNum">    1338</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1339"><span class="lineNum">    1339</span>              : {</span>
<span id="L1340"><span class="lineNum">    1340</span>              :   gulong i, num, j, ch;</span>
<span id="L1341"><span class="lineNum">    1341</span>              :   gsize in_element_size, out_element_size;</span>
<span id="L1342"><span class="lineNum">    1342</span>              : </span>
<span id="L1343"><span class="lineNum">    1343</span>              :   GSList *walk;</span>
<span id="L1344"><span class="lineNum">    1344</span>              :   tensor_transform_operator_s *op_s;</span>
<span id="L1345"><span class="lineNum">    1345</span>              :   tensor_data_s value;</span>
<span id="L1346"><span class="lineNum">    1346</span>              : </span>
<span id="L1347"><span class="lineNum">    1347</span> <span class="tlaGNC">       21495 :   num = gst_tensor_get_element_count (in_info-&gt;dimension);</span></span>
<span id="L1348"><span class="lineNum">    1348</span>              : </span>
<span id="L1349"><span class="lineNum">    1349</span>              : #ifdef HAVE_ORC</span>
<span id="L1350"><span class="lineNum">    1350</span> <span class="tlaGNC">       21495 :   if (filter-&gt;acceleration) {</span></span>
<span id="L1351"><span class="lineNum">    1351</span> <span class="tlaGNC">       21395 :     walk = filter-&gt;operators;</span></span>
<span id="L1352"><span class="lineNum">    1352</span>              :     /**</span>
<span id="L1353"><span class="lineNum">    1353</span>              :      * Typecast should be called at the first.</span>
<span id="L1354"><span class="lineNum">    1354</span>              :      * Do the typecast. If in/out type is same, this will copy the input array to output.</span>
<span id="L1355"><span class="lineNum">    1355</span>              :      */</span>
<span id="L1356"><span class="lineNum">    1356</span> <span class="tlaGNC">       21395 :     orc_typecast (inptr, outptr, num, in_info-&gt;type, out_info-&gt;type);</span></span>
<span id="L1357"><span class="lineNum">    1357</span>              : </span>
<span id="L1358"><span class="lineNum">    1358</span> <span class="tlaGNC">       21395 :     if (!filter-&gt;data_arithmetic.per_channel_arith) {</span></span>
<span id="L1359"><span class="lineNum">    1359</span> <span class="tlaGNC">       65372 :       while (walk) {</span></span>
<span id="L1360"><span class="lineNum">    1360</span> <span class="tlaGNC">       43978 :         op_s = (tensor_transform_operator_s *) walk-&gt;data;</span></span>
<span id="L1361"><span class="lineNum">    1361</span>              : </span>
<span id="L1362"><span class="lineNum">    1362</span> <span class="tlaGNC">       43978 :         if (op_s-&gt;op != GTT_OP_TYPECAST) {</span></span>
<span id="L1363"><span class="lineNum">    1363</span> <span class="tlaGNC">       22662 :           gst_tensor_data_typecast (&amp;op_s-&gt;value, out_info-&gt;type);</span></span>
<span id="L1364"><span class="lineNum">    1364</span> <span class="tlaGNC">       23690 :           orc_operator (outptr, num, &amp;op_s-&gt;value, op_s-&gt;op);</span></span>
<span id="L1365"><span class="lineNum">    1365</span>              :         }</span>
<span id="L1366"><span class="lineNum">    1366</span>              : </span>
<span id="L1367"><span class="lineNum">    1367</span> <span class="tlaGNC">       43978 :         walk = g_slist_next (walk);</span></span>
<span id="L1368"><span class="lineNum">    1368</span>              :       }</span>
<span id="L1369"><span class="lineNum">    1369</span>              :     } else {</span>
<span id="L1370"><span class="lineNum">    1370</span> <span class="tlaGNC">           1 :       gsize typesize = 0;</span></span>
<span id="L1371"><span class="lineNum">    1371</span> <span class="tlaGNC">           1 :       guint ch_dim = filter-&gt;data_arithmetic.ch_dim;</span></span>
<span id="L1372"><span class="lineNum">    1372</span> <span class="tlaGNC">           1 :       gsize ch_offset, ch_size = 1;</span></span>
<span id="L1373"><span class="lineNum">    1373</span> <span class="tlaGNC">           1 :       uint8_t *tmp_outptr = NULL;</span></span>
<span id="L1374"><span class="lineNum">    1374</span>              : </span>
<span id="L1375"><span class="lineNum">    1375</span> <span class="tlaGNC">           1 :       for (i = 0; i &lt; ch_dim; ++i) {</span></span>
<span id="L1376"><span class="lineNum">    1376</span> <span class="tlaUNC tlaBgUNC">           0 :         ch_size *= in_info-&gt;dimension[i];</span></span>
<span id="L1377"><span class="lineNum">    1377</span>              :       }</span>
<span id="L1378"><span class="lineNum">    1378</span> <span class="tlaGNC tlaBgGNC">           1 :       ch_offset = ch_size * in_info-&gt;dimension[ch_dim];</span></span>
<span id="L1379"><span class="lineNum">    1379</span> <span class="tlaGNC">           1 :       orc_typesize (typesize, out_info-&gt;type);</span></span>
<span id="L1380"><span class="lineNum">    1380</span>              : </span>
<span id="L1381"><span class="lineNum">    1381</span> <span class="tlaGNC">           2 :       while (walk) {</span></span>
<span id="L1382"><span class="lineNum">    1382</span> <span class="tlaGNC">           1 :         op_s = (tensor_transform_operator_s *) walk-&gt;data;</span></span>
<span id="L1383"><span class="lineNum">    1383</span> <span class="tlaGNC">           1 :         if (op_s-&gt;op == GTT_OP_TYPECAST) {</span></span>
<span id="L1384"><span class="lineNum">    1384</span> <span class="tlaUNC tlaBgUNC">           0 :           walk = g_slist_next (walk);</span></span>
<span id="L1385"><span class="lineNum">    1385</span> <span class="tlaUNC">           0 :           continue;</span></span>
<span id="L1386"><span class="lineNum">    1386</span>              :         }</span>
<span id="L1387"><span class="lineNum">    1387</span>              : </span>
<span id="L1388"><span class="lineNum">    1388</span> <span class="tlaGNC tlaBgGNC">           1 :         if (op_s-&gt;applying_ch == -1) {</span></span>
<span id="L1389"><span class="lineNum">    1389</span> <span class="tlaUNC tlaBgUNC">           0 :           gst_tensor_data_typecast (&amp;op_s-&gt;value, out_info-&gt;type);</span></span>
<span id="L1390"><span class="lineNum">    1390</span> <span class="tlaUNC">           0 :           orc_operator (outptr, num, &amp;op_s-&gt;value, op_s-&gt;op);</span></span>
<span id="L1391"><span class="lineNum">    1391</span>              :         } else {</span>
<span id="L1392"><span class="lineNum">    1392</span> <span class="tlaGNC tlaBgGNC">          33 :           for (i = 0; i &lt; num / ch_offset; ++i) {</span></span>
<span id="L1393"><span class="lineNum">    1393</span> <span class="tlaGNC">          32 :             tmp_outptr =</span></span>
<span id="L1394"><span class="lineNum">    1394</span> <span class="tlaGNC">          32 :                 outptr + (ch_size * op_s-&gt;applying_ch +</span></span>
<span id="L1395"><span class="lineNum">    1395</span> <span class="tlaGNC">          32 :                 ch_offset * i) * typesize;</span></span>
<span id="L1396"><span class="lineNum">    1396</span> <span class="tlaGNC">          32 :             gst_tensor_data_typecast (&amp;op_s-&gt;value, out_info-&gt;type);</span></span>
<span id="L1397"><span class="lineNum">    1397</span> <span class="tlaGNC">          32 :             orc_operator (tmp_outptr, ch_size, &amp;op_s-&gt;value, op_s-&gt;op);</span></span>
<span id="L1398"><span class="lineNum">    1398</span>              :           }</span>
<span id="L1399"><span class="lineNum">    1399</span>              :         }</span>
<span id="L1400"><span class="lineNum">    1400</span> <span class="tlaGNC">           1 :         walk = g_slist_next (walk);</span></span>
<span id="L1401"><span class="lineNum">    1401</span>              :       }</span>
<span id="L1402"><span class="lineNum">    1402</span>              :     }</span>
<span id="L1403"><span class="lineNum">    1403</span> <span class="tlaGNC">       21495 :     return GST_FLOW_OK;</span></span>
<span id="L1404"><span class="lineNum">    1404</span>              :   }</span>
<span id="L1405"><span class="lineNum">    1405</span>              : #endif</span>
<span id="L1406"><span class="lineNum">    1406</span>              : </span>
<span id="L1407"><span class="lineNum">    1407</span> <span class="tlaGNC">         100 :   in_element_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1408"><span class="lineNum">    1408</span> <span class="tlaGNC">         100 :   out_element_size = gst_tensor_get_element_size (out_info-&gt;type);</span></span>
<span id="L1409"><span class="lineNum">    1409</span>              : </span>
<span id="L1410"><span class="lineNum">    1410</span>              :   /* per-channel */</span>
<span id="L1411"><span class="lineNum">    1411</span> <span class="tlaGNC">         100 :   if (filter-&gt;data_arithmetic.per_channel_arith) {</span></span>
<span id="L1412"><span class="lineNum">    1412</span> <span class="tlaGNC">           3 :     guint ch_dim = filter-&gt;data_arithmetic.ch_dim;</span></span>
<span id="L1413"><span class="lineNum">    1413</span> <span class="tlaGNC">           3 :     gsize ch_offset, ch_size = 1;</span></span>
<span id="L1414"><span class="lineNum">    1414</span> <span class="tlaGNC">           3 :     for (i = 0; i &lt; ch_dim; ++i) {</span></span>
<span id="L1415"><span class="lineNum">    1415</span> <span class="tlaUNC tlaBgUNC">           0 :       ch_size *= in_info-&gt;dimension[i];</span></span>
<span id="L1416"><span class="lineNum">    1416</span>              :     }</span>
<span id="L1417"><span class="lineNum">    1417</span> <span class="tlaGNC tlaBgGNC">           3 :     ch_offset = ch_size * in_info-&gt;dimension[ch_dim];</span></span>
<span id="L1418"><span class="lineNum">    1418</span>              : </span>
<span id="L1419"><span class="lineNum">    1419</span>              :     /** In case of 3:4:4:1,</span>
<span id="L1420"><span class="lineNum">    1420</span>              :      * ch_dim:0 -&gt; #ch: 3, ch_size: 1, ch_offset: 3</span>
<span id="L1421"><span class="lineNum">    1421</span>              :      * ch_dim:1 -&gt; #ch: 4, ch_size: 3, ch_offset: 12</span>
<span id="L1422"><span class="lineNum">    1422</span>              :      * ch_dim:2 -&gt; #ch: 4, ch_size: 12, ch_offset: 48</span>
<span id="L1423"><span class="lineNum">    1423</span>              :      * ch_dim:3 -&gt; #ch: 1, ch_size: 48, ch_offset: 48 * 4</span>
<span id="L1424"><span class="lineNum">    1424</span>              :      */</span>
<span id="L1425"><span class="lineNum">    1425</span>              : </span>
<span id="L1426"><span class="lineNum">    1426</span> <span class="tlaGNC">           6 :     for (i = 0; i &lt; num / ch_offset; ++i) {</span></span>
<span id="L1427"><span class="lineNum">    1427</span> <span class="tlaGNC">          18 :       for (ch = 0; ch &lt; in_info-&gt;dimension[ch_dim]; ++ch) {</span></span>
<span id="L1428"><span class="lineNum">    1428</span> <span class="tlaGNC">          30 :         for (j = 0; j &lt; ch_size; ++j) {</span></span>
<span id="L1429"><span class="lineNum">    1429</span> <span class="tlaGNC">          15 :           gulong data_idx = (i * ch_offset) + (ch * ch_size) + j;</span></span>
<span id="L1430"><span class="lineNum">    1430</span> <span class="tlaGNC">          15 :           gst_tensor_data_set (&amp;value, in_info-&gt;type,</span></span>
<span id="L1431"><span class="lineNum">    1431</span> <span class="tlaGNC">          15 :               (gpointer) (inptr + in_element_size * data_idx));</span></span>
<span id="L1432"><span class="lineNum">    1432</span>              : </span>
<span id="L1433"><span class="lineNum">    1433</span> <span class="tlaGNC">          15 :           walk = filter-&gt;operators;</span></span>
<span id="L1434"><span class="lineNum">    1434</span> <span class="tlaGNC">         180 :           while (walk) {</span></span>
<span id="L1435"><span class="lineNum">    1435</span> <span class="tlaGNC">         165 :             op_s = (tensor_transform_operator_s *) walk-&gt;data;</span></span>
<span id="L1436"><span class="lineNum">    1436</span> <span class="tlaGNC">         165 :             switch (op_s-&gt;op) {</span></span>
<span id="L1437"><span class="lineNum">    1437</span> <span class="tlaGNC">          15 :               case GTT_OP_TYPECAST:</span></span>
<span id="L1438"><span class="lineNum">    1438</span> <span class="tlaGNC">          15 :                 gst_tensor_data_typecast (&amp;value, op_s-&gt;value.type);</span></span>
<span id="L1439"><span class="lineNum">    1439</span> <span class="tlaGNC">          15 :                 break;</span></span>
<span id="L1440"><span class="lineNum">    1440</span> <span class="tlaGNC">         150 :               case GTT_OP_ADD:</span></span>
<span id="L1441"><span class="lineNum">    1441</span>              :               case GTT_OP_MUL:</span>
<span id="L1442"><span class="lineNum">    1442</span>              :               case GTT_OP_DIV:</span>
<span id="L1443"><span class="lineNum">    1443</span>              :               {</span>
<span id="L1444"><span class="lineNum">    1444</span> <span class="tlaGNC">         150 :                 gst_tensor_data_typecast (&amp;op_s-&gt;value, value.type);</span></span>
<span id="L1445"><span class="lineNum">    1445</span>              : </span>
<span id="L1446"><span class="lineNum">    1446</span> <span class="tlaGNC">         150 :                 if (op_s-&gt;applying_ch == (int) ch || op_s-&gt;applying_ch == -1) {</span></span>
<span id="L1447"><span class="lineNum">    1447</span> <span class="tlaGNC">          30 :                   gst_tensor_transform_do_operator (filter, &amp;value,</span></span>
<span id="L1448"><span class="lineNum">    1448</span> <span class="tlaGNC">          30 :                       &amp;op_s-&gt;value, op_s-&gt;op);</span></span>
<span id="L1449"><span class="lineNum">    1449</span>              :                 }</span>
<span id="L1450"><span class="lineNum">    1450</span> <span class="tlaGNC">         150 :                 break;</span></span>
<span id="L1451"><span class="lineNum">    1451</span>              :               }</span>
<span id="L1452"><span class="lineNum">    1452</span> <span class="tlaUNC tlaBgUNC">           0 :               default:</span></span>
<span id="L1453"><span class="lineNum">    1453</span> <span class="tlaUNC">           0 :                 g_assert (0);</span></span>
<span id="L1454"><span class="lineNum">    1454</span>              :                 return GST_FLOW_ERROR;</span>
<span id="L1455"><span class="lineNum">    1455</span>              :             }</span>
<span id="L1456"><span class="lineNum">    1456</span>              : </span>
<span id="L1457"><span class="lineNum">    1457</span> <span class="tlaGNC tlaBgGNC">         165 :             walk = g_slist_next (walk);</span></span>
<span id="L1458"><span class="lineNum">    1458</span>              :           }</span>
<span id="L1459"><span class="lineNum">    1459</span>              : </span>
<span id="L1460"><span class="lineNum">    1460</span>              :           /* set output value */</span>
<span id="L1461"><span class="lineNum">    1461</span> <span class="tlaGNC">          15 :           g_assert (out_info-&gt;type == value.type);</span></span>
<span id="L1462"><span class="lineNum">    1462</span> <span class="tlaGNC">          15 :           gst_tensor_data_get (&amp;value, outptr + out_element_size * data_idx);</span></span>
<span id="L1463"><span class="lineNum">    1463</span>              :         }</span>
<span id="L1464"><span class="lineNum">    1464</span>              :       }</span>
<span id="L1465"><span class="lineNum">    1465</span>              :     }</span>
<span id="L1466"><span class="lineNum">    1466</span>              : </span>
<span id="L1467"><span class="lineNum">    1467</span> <span class="tlaGNC">           3 :     return GST_FLOW_OK;</span></span>
<span id="L1468"><span class="lineNum">    1468</span>              :   }</span>
<span id="L1469"><span class="lineNum">    1469</span>              : </span>
<span id="L1470"><span class="lineNum">    1470</span> <span class="tlaGNC">       61622 :   for (i = 0; i &lt; num; ++i) {</span></span>
<span id="L1471"><span class="lineNum">    1471</span>              :     /* init value with input tensor type */</span>
<span id="L1472"><span class="lineNum">    1472</span> <span class="tlaGNC">       61525 :     gst_tensor_data_set (&amp;value, in_info-&gt;type,</span></span>
<span id="L1473"><span class="lineNum">    1473</span> <span class="tlaGNC">       61525 :         (gpointer) (inptr + in_element_size * i));</span></span>
<span id="L1474"><span class="lineNum">    1474</span>              : </span>
<span id="L1475"><span class="lineNum">    1475</span> <span class="tlaGNC">       61525 :     walk = filter-&gt;operators;</span></span>
<span id="L1476"><span class="lineNum">    1476</span> <span class="tlaGNC">      184595 :     while (walk) {</span></span>
<span id="L1477"><span class="lineNum">    1477</span> <span class="tlaGNC">      123070 :       op_s = (tensor_transform_operator_s *) walk-&gt;data;</span></span>
<span id="L1478"><span class="lineNum">    1478</span>              : </span>
<span id="L1479"><span class="lineNum">    1479</span>              :       /**</span>
<span id="L1480"><span class="lineNum">    1480</span>              :        * @todo add more options</span>
<span id="L1481"><span class="lineNum">    1481</span>              :        */</span>
<span id="L1482"><span class="lineNum">    1482</span> <span class="tlaGNC">      123070 :       switch (op_s-&gt;op) {</span></span>
<span id="L1483"><span class="lineNum">    1483</span> <span class="tlaGNC">       61485 :         case GTT_OP_TYPECAST:</span></span>
<span id="L1484"><span class="lineNum">    1484</span> <span class="tlaGNC">       61485 :           gst_tensor_data_typecast (&amp;value, op_s-&gt;value.type);</span></span>
<span id="L1485"><span class="lineNum">    1485</span> <span class="tlaGNC">       61485 :           break;</span></span>
<span id="L1486"><span class="lineNum">    1486</span> <span class="tlaGNC">       61585 :         case GTT_OP_ADD:</span></span>
<span id="L1487"><span class="lineNum">    1487</span>              :         case GTT_OP_MUL:</span>
<span id="L1488"><span class="lineNum">    1488</span>              :         case GTT_OP_DIV:</span>
<span id="L1489"><span class="lineNum">    1489</span> <span class="tlaGNC">       61585 :           gst_tensor_data_typecast (&amp;op_s-&gt;value, value.type);</span></span>
<span id="L1490"><span class="lineNum">    1490</span> <span class="tlaGNC">       61585 :           gst_tensor_transform_do_operator (filter, &amp;value, &amp;op_s-&gt;value,</span></span>
<span id="L1491"><span class="lineNum">    1491</span>              :               op_s-&gt;op);</span>
<span id="L1492"><span class="lineNum">    1492</span> <span class="tlaGNC">       61585 :           break;</span></span>
<span id="L1493"><span class="lineNum">    1493</span> <span class="tlaUNC tlaBgUNC">           0 :         default:</span></span>
<span id="L1494"><span class="lineNum">    1494</span> <span class="tlaUNC">           0 :           g_assert (0);</span></span>
<span id="L1495"><span class="lineNum">    1495</span>              :           return GST_FLOW_ERROR;</span>
<span id="L1496"><span class="lineNum">    1496</span>              :       }</span>
<span id="L1497"><span class="lineNum">    1497</span>              : </span>
<span id="L1498"><span class="lineNum">    1498</span> <span class="tlaGNC tlaBgGNC">      123070 :       walk = g_slist_next (walk);</span></span>
<span id="L1499"><span class="lineNum">    1499</span>              :     }</span>
<span id="L1500"><span class="lineNum">    1500</span>              : </span>
<span id="L1501"><span class="lineNum">    1501</span>              :     /* set output value */</span>
<span id="L1502"><span class="lineNum">    1502</span> <span class="tlaGNC">       61525 :     g_assert (out_info-&gt;type == value.type);</span></span>
<span id="L1503"><span class="lineNum">    1503</span> <span class="tlaGNC">       61525 :     gst_tensor_data_get (&amp;value, outptr + out_element_size * i);</span></span>
<span id="L1504"><span class="lineNum">    1504</span>              :   }</span>
<span id="L1505"><span class="lineNum">    1505</span>              : </span>
<span id="L1506"><span class="lineNum">    1506</span> <span class="tlaGNC">          97 :   return GST_FLOW_OK;</span></span>
<span id="L1507"><span class="lineNum">    1507</span>              : }</span>
<span id="L1508"><span class="lineNum">    1508</span>              : </span>
<span id="L1509"><span class="lineNum">    1509</span>              : /**</span>
<span id="L1510"><span class="lineNum">    1510</span>              :  * Macro to run loop for various data types with transpose</span>
<span id="L1511"><span class="lineNum">    1511</span>              :  */</span>
<span id="L1512"><span class="lineNum">    1512</span>              : #define transposeloop(cl,ck,cj,ci,sl,sk,sj,si,typesize) do { \</span>
<span id="L1513"><span class="lineNum">    1513</span>              :     size_t i, j, k, l;                                  \</span>
<span id="L1514"><span class="lineNum">    1514</span>              :     int inidx = 0, outidx=0;                            \</span>
<span id="L1515"><span class="lineNum">    1515</span>              :     for(cl=0;cl&lt;sl;cl++)                      \</span>
<span id="L1516"><span class="lineNum">    1516</span>              :       for(ci=0;ci&lt;si;ci++)                    \</span>
<span id="L1517"><span class="lineNum">    1517</span>              :         for(cj=0;cj&lt;sj;cj++)                  \</span>
<span id="L1518"><span class="lineNum">    1518</span>              :           for(ck=0;ck&lt;sk;ck++){               \</span>
<span id="L1519"><span class="lineNum">    1519</span>              :             const uint8_t *_in; \</span>
<span id="L1520"><span class="lineNum">    1520</span>              :             uint8_t *_out; \</span>
<span id="L1521"><span class="lineNum">    1521</span>              :             outidx = si*sj*sk*cl + sj*sk*ci + sk*cj + ck; \</span>
<span id="L1522"><span class="lineNum">    1522</span>              :             inidx = SK*SJ*SI*l + SJ*SI*k + SI*j + i; \</span>
<span id="L1523"><span class="lineNum">    1523</span>              :             _in = inptr + inidx * typesize; \</span>
<span id="L1524"><span class="lineNum">    1524</span>              :             _out = outptr + outidx * typesize; \</span>
<span id="L1525"><span class="lineNum">    1525</span>              :             nns_memcpy(_out, _in, typesize); \</span>
<span id="L1526"><span class="lineNum">    1526</span>              :           }                                                      \</span>
<span id="L1527"><span class="lineNum">    1527</span>              :   } while(0);</span>
<span id="L1528"><span class="lineNum">    1528</span>              : </span>
<span id="L1529"><span class="lineNum">    1529</span>              : /**</span>
<span id="L1530"><span class="lineNum">    1530</span>              :  * @brief subrouting for tensor-transform, &quot;transpose&quot; case.</span>
<span id="L1531"><span class="lineNum">    1531</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1532"><span class="lineNum">    1532</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1533"><span class="lineNum">    1533</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1534"><span class="lineNum">    1534</span>              :  * @param[in] inptr input tensor</span>
<span id="L1535"><span class="lineNum">    1535</span>              :  * @param[out] outptr output tensor</span>
<span id="L1536"><span class="lineNum">    1536</span>              :  * @return Gst flow status</span>
<span id="L1537"><span class="lineNum">    1537</span>              :  */</span>
<span id="L1538"><span class="lineNum">    1538</span>              : static GstFlowReturn</span>
<span id="L1539"><span class="lineNum">    1539</span> <span class="tlaGNC">          58 : gst_tensor_transform_transpose (GstTensorTransform * filter,</span></span>
<span id="L1540"><span class="lineNum">    1540</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1541"><span class="lineNum">    1541</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1542"><span class="lineNum">    1542</span>              : {</span>
<span id="L1543"><span class="lineNum">    1543</span>              :   int i, from, to;</span>
<span id="L1544"><span class="lineNum">    1544</span> <span class="tlaGNC">          58 :   gboolean checkdim = FALSE;</span></span>
<span id="L1545"><span class="lineNum">    1545</span> <span class="tlaGNC">          58 :   uint32_t *fromDim = in_info-&gt;dimension;</span></span>
<span id="L1546"><span class="lineNum">    1546</span> <span class="tlaGNC">          58 :   gsize type_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1547"><span class="lineNum">    1547</span>              :   gsize indexI, indexJ, SL, SI, SJ, SK;</span>
<span id="L1548"><span class="lineNum">    1548</span>              :   UNUSED (out_info);</span>
<span id="L1549"><span class="lineNum">    1549</span>              : </span>
<span id="L1550"><span class="lineNum">    1550</span> <span class="tlaGNC">          58 :   for (i = 0; i &lt; NNS_TENSOR_TRANSPOSE_RANK_LIMIT; i++) {</span></span>
<span id="L1551"><span class="lineNum">    1551</span> <span class="tlaGNC">          58 :     from = i;</span></span>
<span id="L1552"><span class="lineNum">    1552</span> <span class="tlaGNC">          58 :     to = filter-&gt;data_transpose.trans_order[i];</span></span>
<span id="L1553"><span class="lineNum">    1553</span> <span class="tlaGNC">          58 :     if (from != to) {</span></span>
<span id="L1554"><span class="lineNum">    1554</span> <span class="tlaGNC">          58 :       checkdim = TRUE;</span></span>
<span id="L1555"><span class="lineNum">    1555</span> <span class="tlaGNC">          58 :       break;</span></span>
<span id="L1556"><span class="lineNum">    1556</span>              :     }</span>
<span id="L1557"><span class="lineNum">    1557</span>              :   }</span>
<span id="L1558"><span class="lineNum">    1558</span>              : </span>
<span id="L1559"><span class="lineNum">    1559</span> <span class="tlaGNC">          58 :   if (!checkdim) {</span></span>
<span id="L1560"><span class="lineNum">    1560</span> <span class="tlaUNC tlaBgUNC">           0 :     nns_memcpy (outptr, inptr, gst_tensor_info_get_size (in_info));</span></span>
<span id="L1561"><span class="lineNum">    1561</span> <span class="tlaUNC">           0 :     GST_WARNING_OBJECT (filter,</span></span>
<span id="L1562"><span class="lineNum">    1562</span>              :         &quot;Calling tensor_transform with high memcpy overhead WITHOUT any effects!&quot;);</span>
<span id="L1563"><span class="lineNum">    1563</span> <span class="tlaUNC">           0 :     return GST_FLOW_OK;</span></span>
<span id="L1564"><span class="lineNum">    1564</span>              :   }</span>
<span id="L1565"><span class="lineNum">    1565</span>              : </span>
<span id="L1566"><span class="lineNum">    1566</span> <span class="tlaGNC tlaBgGNC">          58 :   indexI = filter-&gt;data_transpose.trans_order[0];</span></span>
<span id="L1567"><span class="lineNum">    1567</span> <span class="tlaGNC">          58 :   indexJ = filter-&gt;data_transpose.trans_order[1];</span></span>
<span id="L1568"><span class="lineNum">    1568</span> <span class="tlaGNC">          58 :   SL = fromDim[3] &gt; 0 ? fromDim[3] : 1;</span></span>
<span id="L1569"><span class="lineNum">    1569</span> <span class="tlaGNC">          58 :   SI = fromDim[0] &gt; 0 ? fromDim[0] : 1;</span></span>
<span id="L1570"><span class="lineNum">    1570</span> <span class="tlaGNC">          58 :   SJ = fromDim[1] &gt; 0 ? fromDim[1] : 1;</span></span>
<span id="L1571"><span class="lineNum">    1571</span> <span class="tlaGNC">          58 :   SK = fromDim[2] &gt; 0 ? fromDim[2] : 1;</span></span>
<span id="L1572"><span class="lineNum">    1572</span>              : </span>
<span id="L1573"><span class="lineNum">    1573</span> <span class="tlaGNC">          58 :   switch (indexI) {</span></span>
<span id="L1574"><span class="lineNum">    1574</span> <span class="tlaUNC tlaBgUNC">           0 :     case 0:</span></span>
<span id="L1575"><span class="lineNum">    1575</span> <span class="tlaUNC">           0 :       if (indexJ == 1) {</span></span>
<span id="L1576"><span class="lineNum">    1576</span> <span class="tlaUNC">           0 :         transposeloop (l, i, j, k, SL, SI, SJ, SK, type_size);</span></span>
<span id="L1577"><span class="lineNum">    1577</span>              :       } else {</span>
<span id="L1578"><span class="lineNum">    1578</span> <span class="tlaUNC">           0 :         transposeloop (l, i, k, j, SL, SI, SK, SJ, type_size);</span></span>
<span id="L1579"><span class="lineNum">    1579</span>              :       }</span>
<span id="L1580"><span class="lineNum">    1580</span> <span class="tlaUNC">           0 :       break;</span></span>
<span id="L1581"><span class="lineNum">    1581</span> <span class="tlaGNC tlaBgGNC">          54 :     case 1:</span></span>
<span id="L1582"><span class="lineNum">    1582</span> <span class="tlaGNC">          54 :       if (indexJ == 0) {</span></span>
<span id="L1583"><span class="lineNum">    1583</span> <span class="tlaGNC">      242420 :         transposeloop (l, j, i, k, SL, SJ, SI, SK, type_size);</span></span>
<span id="L1584"><span class="lineNum">    1584</span>              :       } else {</span>
<span id="L1585"><span class="lineNum">    1585</span> <span class="tlaGNC">     1231478 :         transposeloop (l, j, k, i, SL, SJ, SK, SI, type_size);</span></span>
<span id="L1586"><span class="lineNum">    1586</span>              :       }</span>
<span id="L1587"><span class="lineNum">    1587</span> <span class="tlaGNC">          54 :       break;</span></span>
<span id="L1588"><span class="lineNum">    1588</span> <span class="tlaGNC">           4 :     case 2:</span></span>
<span id="L1589"><span class="lineNum">    1589</span> <span class="tlaGNC">           4 :       if (indexJ == 0) {</span></span>
<span id="L1590"><span class="lineNum">    1590</span> <span class="tlaGNC">      140258 :         transposeloop (l, k, i, j, SL, SK, SI, SJ, type_size);</span></span>
<span id="L1591"><span class="lineNum">    1591</span>              :       } else {</span>
<span id="L1592"><span class="lineNum">    1592</span> <span class="tlaUNC tlaBgUNC">           0 :         transposeloop (l, k, j, i, SL, SK, SJ, SI, type_size);</span></span>
<span id="L1593"><span class="lineNum">    1593</span>              :       }</span>
<span id="L1594"><span class="lineNum">    1594</span> <span class="tlaGNC tlaBgGNC">           4 :       break;</span></span>
<span id="L1595"><span class="lineNum">    1595</span>              :   }</span>
<span id="L1596"><span class="lineNum">    1596</span>              : </span>
<span id="L1597"><span class="lineNum">    1597</span> <span class="tlaGNC">          58 :   return GST_FLOW_OK;</span></span>
<span id="L1598"><span class="lineNum">    1598</span>              : }</span>
<span id="L1599"><span class="lineNum">    1599</span>              : </span>
<span id="L1600"><span class="lineNum">    1600</span>              : /**</span>
<span id="L1601"><span class="lineNum">    1601</span>              :  * @brief subrouting for tensor-transform, &quot;stand&quot; case.</span>
<span id="L1602"><span class="lineNum">    1602</span>              :  *        : pixel = abs((pixel - average(tensor))/(std(tensor) + val))</span>
<span id="L1603"><span class="lineNum">    1603</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1604"><span class="lineNum">    1604</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1605"><span class="lineNum">    1605</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1606"><span class="lineNum">    1606</span>              :  * @param[in] inptr input tensor</span>
<span id="L1607"><span class="lineNum">    1607</span>              :  * @param[out] outptr output tensor</span>
<span id="L1608"><span class="lineNum">    1608</span>              :  * @return Gst flow status</span>
<span id="L1609"><span class="lineNum">    1609</span>              :  */</span>
<span id="L1610"><span class="lineNum">    1610</span>              : static GstFlowReturn</span>
<span id="L1611"><span class="lineNum">    1611</span> <span class="tlaGNC">          16 : gst_tensor_transform_stand (GstTensorTransform * filter,</span></span>
<span id="L1612"><span class="lineNum">    1612</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1613"><span class="lineNum">    1613</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1614"><span class="lineNum">    1614</span>              : {</span>
<span id="L1615"><span class="lineNum">    1615</span> <span class="tlaGNC">          16 :   GstFlowReturn ret = GST_FLOW_OK;</span></span>
<span id="L1616"><span class="lineNum">    1616</span>              :   gsize in_element_size, out_element_size, data_size, ch_size;</span>
<span id="L1617"><span class="lineNum">    1617</span>              :   gulong i, num, data_idx, ch;</span>
<span id="L1618"><span class="lineNum">    1618</span>              :   gdouble tmp, *average, *std;</span>
<span id="L1619"><span class="lineNum">    1619</span>              : </span>
<span id="L1620"><span class="lineNum">    1620</span> <span class="tlaGNC">          16 :   in_element_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1621"><span class="lineNum">    1621</span> <span class="tlaGNC">          16 :   out_element_size = gst_tensor_get_element_size (out_info-&gt;type);</span></span>
<span id="L1622"><span class="lineNum">    1622</span> <span class="tlaGNC">          16 :   num = gst_tensor_get_element_count (in_info-&gt;dimension);</span></span>
<span id="L1623"><span class="lineNum">    1623</span>              : </span>
<span id="L1624"><span class="lineNum">    1624</span> <span class="tlaGNC">          16 :   data_size = gst_tensor_info_get_size (in_info);</span></span>
<span id="L1625"><span class="lineNum">    1625</span> <span class="tlaGNC">          16 :   ch_size = in_info-&gt;dimension[0];</span></span>
<span id="L1626"><span class="lineNum">    1626</span>              : </span>
<span id="L1627"><span class="lineNum">    1627</span>              :   /* calc average and std */</span>
<span id="L1628"><span class="lineNum">    1628</span> <span class="tlaGNC">          16 :   average = std = NULL;</span></span>
<span id="L1629"><span class="lineNum">    1629</span> <span class="tlaGNC">          16 :   if (filter-&gt;data_stand.per_channel) {</span></span>
<span id="L1630"><span class="lineNum">    1630</span> <span class="tlaGNC">           8 :     gst_tensor_data_raw_average_per_channel ((gpointer) inptr, data_size,</span></span>
<span id="L1631"><span class="lineNum">    1631</span> <span class="tlaGNC">           8 :         in_info-&gt;type, in_info-&gt;dimension, &amp;average);</span></span>
<span id="L1632"><span class="lineNum">    1632</span>              :     /* calculate std only for default mode */</span>
<span id="L1633"><span class="lineNum">    1633</span> <span class="tlaGNC">           8 :     if (filter-&gt;data_stand.mode == STAND_DEFAULT)</span></span>
<span id="L1634"><span class="lineNum">    1634</span> <span class="tlaGNC">           4 :       gst_tensor_data_raw_std_per_channel ((gpointer) inptr, data_size,</span></span>
<span id="L1635"><span class="lineNum">    1635</span> <span class="tlaGNC">           4 :           in_info-&gt;type, in_info-&gt;dimension, average, &amp;std);</span></span>
<span id="L1636"><span class="lineNum">    1636</span>              :   } else {</span>
<span id="L1637"><span class="lineNum">    1637</span> <span class="tlaGNC">           8 :     gst_tensor_data_raw_average ((gpointer) inptr, data_size,</span></span>
<span id="L1638"><span class="lineNum">    1638</span>              :         in_info-&gt;type, &amp;average);</span>
<span id="L1639"><span class="lineNum">    1639</span>              :     /* calculate std only for default mode */</span>
<span id="L1640"><span class="lineNum">    1640</span> <span class="tlaGNC">           8 :     if (filter-&gt;data_stand.mode == STAND_DEFAULT)</span></span>
<span id="L1641"><span class="lineNum">    1641</span> <span class="tlaGNC">           4 :       gst_tensor_data_raw_std ((gpointer) inptr, data_size, in_info-&gt;type,</span></span>
<span id="L1642"><span class="lineNum">    1642</span>              :           average, &amp;std);</span>
<span id="L1643"><span class="lineNum">    1643</span>              :   }</span>
<span id="L1644"><span class="lineNum">    1644</span>              : </span>
<span id="L1645"><span class="lineNum">    1645</span> <span class="tlaGNC">          16 :   switch (filter-&gt;data_stand.mode) {</span></span>
<span id="L1646"><span class="lineNum">    1646</span> <span class="tlaGNC">           8 :     case STAND_DEFAULT:</span></span>
<span id="L1647"><span class="lineNum">    1647</span>              :     {</span>
<span id="L1648"><span class="lineNum">    1648</span> <span class="tlaGNC">           8 :       if (!filter-&gt;data_stand.per_channel) {</span></span>
<span id="L1649"><span class="lineNum">    1649</span> <span class="tlaGNC">       20004 :         for (i = 0; i &lt; num; i++) {</span></span>
<span id="L1650"><span class="lineNum">    1650</span> <span class="tlaGNC">       20000 :           data_idx = in_element_size * i;</span></span>
<span id="L1651"><span class="lineNum">    1651</span> <span class="tlaGNC">       20000 :           gst_tensor_data_raw_typecast ((gpointer) (inptr + data_idx),</span></span>
<span id="L1652"><span class="lineNum">    1652</span>              :               in_info-&gt;type, &amp;tmp, _NNS_FLOAT64);</span>
<span id="L1653"><span class="lineNum">    1653</span>              : </span>
<span id="L1654"><span class="lineNum">    1654</span> <span class="tlaGNC">       20000 :           tmp = fabs ((tmp - *average) / *std);</span></span>
<span id="L1655"><span class="lineNum">    1655</span>              : </span>
<span id="L1656"><span class="lineNum">    1656</span> <span class="tlaGNC">       20000 :           data_idx = out_element_size * i;</span></span>
<span id="L1657"><span class="lineNum">    1657</span> <span class="tlaGNC">       20000 :           gst_tensor_data_raw_typecast (&amp;tmp, _NNS_FLOAT64,</span></span>
<span id="L1658"><span class="lineNum">    1658</span> <span class="tlaGNC">       20000 :               (gpointer) (outptr + data_idx), out_info-&gt;type);</span></span>
<span id="L1659"><span class="lineNum">    1659</span>              :         }</span>
<span id="L1660"><span class="lineNum">    1660</span>              :       } else {</span>
<span id="L1661"><span class="lineNum">    1661</span> <span class="tlaGNC">         204 :         for (ch = 0; ch &lt; ch_size; ++ch) {</span></span>
<span id="L1662"><span class="lineNum">    1662</span> <span class="tlaGNC">       20200 :           for (i = 0; i &lt; num / ch_size; i++) {</span></span>
<span id="L1663"><span class="lineNum">    1663</span> <span class="tlaGNC">       20000 :             data_idx = in_element_size * ((i * ch_size) + ch);</span></span>
<span id="L1664"><span class="lineNum">    1664</span> <span class="tlaGNC">       20000 :             gst_tensor_data_raw_typecast ((gpointer) (inptr + data_idx),</span></span>
<span id="L1665"><span class="lineNum">    1665</span>              :                 in_info-&gt;type, &amp;tmp, _NNS_FLOAT64);</span>
<span id="L1666"><span class="lineNum">    1666</span>              : </span>
<span id="L1667"><span class="lineNum">    1667</span> <span class="tlaGNC">       20000 :             tmp = fabs ((tmp - average[ch]) / std[ch]);</span></span>
<span id="L1668"><span class="lineNum">    1668</span>              : </span>
<span id="L1669"><span class="lineNum">    1669</span> <span class="tlaGNC">       20000 :             data_idx = out_element_size * ((i * ch_size) + ch);</span></span>
<span id="L1670"><span class="lineNum">    1670</span> <span class="tlaGNC">       20000 :             gst_tensor_data_raw_typecast (&amp;tmp, _NNS_FLOAT64,</span></span>
<span id="L1671"><span class="lineNum">    1671</span> <span class="tlaGNC">       20000 :                 (gpointer) (outptr + data_idx), out_info-&gt;type);</span></span>
<span id="L1672"><span class="lineNum">    1672</span>              :           }</span>
<span id="L1673"><span class="lineNum">    1673</span>              :         }</span>
<span id="L1674"><span class="lineNum">    1674</span>              :       }</span>
<span id="L1675"><span class="lineNum">    1675</span> <span class="tlaGNC">           8 :       break;</span></span>
<span id="L1676"><span class="lineNum">    1676</span>              :     }</span>
<span id="L1677"><span class="lineNum">    1677</span> <span class="tlaGNC">           8 :     case STAND_DC_AVERAGE:</span></span>
<span id="L1678"><span class="lineNum">    1678</span>              :     {</span>
<span id="L1679"><span class="lineNum">    1679</span> <span class="tlaGNC">           8 :       if (!filter-&gt;data_stand.per_channel) {</span></span>
<span id="L1680"><span class="lineNum">    1680</span> <span class="tlaGNC">       20004 :         for (i = 0; i &lt; num; i++) {</span></span>
<span id="L1681"><span class="lineNum">    1681</span> <span class="tlaGNC">       20000 :           data_idx = in_element_size * i;</span></span>
<span id="L1682"><span class="lineNum">    1682</span> <span class="tlaGNC">       20000 :           gst_tensor_data_raw_typecast ((gpointer) (inptr + data_idx),</span></span>
<span id="L1683"><span class="lineNum">    1683</span>              :               in_info-&gt;type, &amp;tmp, _NNS_FLOAT64);</span>
<span id="L1684"><span class="lineNum">    1684</span>              : </span>
<span id="L1685"><span class="lineNum">    1685</span> <span class="tlaGNC">       20000 :           tmp -= *average;</span></span>
<span id="L1686"><span class="lineNum">    1686</span>              : </span>
<span id="L1687"><span class="lineNum">    1687</span> <span class="tlaGNC">       20000 :           data_idx = out_element_size * i;</span></span>
<span id="L1688"><span class="lineNum">    1688</span> <span class="tlaGNC">       20000 :           gst_tensor_data_raw_typecast (&amp;tmp, _NNS_FLOAT64,</span></span>
<span id="L1689"><span class="lineNum">    1689</span> <span class="tlaGNC">       20000 :               (gpointer) (outptr + data_idx), out_info-&gt;type);</span></span>
<span id="L1690"><span class="lineNum">    1690</span>              :         }</span>
<span id="L1691"><span class="lineNum">    1691</span>              :       } else {</span>
<span id="L1692"><span class="lineNum">    1692</span> <span class="tlaGNC">         204 :         for (ch = 0; ch &lt; ch_size; ++ch) {</span></span>
<span id="L1693"><span class="lineNum">    1693</span> <span class="tlaGNC">       20200 :           for (i = 0; i &lt; num / ch_size; i++) {</span></span>
<span id="L1694"><span class="lineNum">    1694</span> <span class="tlaGNC">       20000 :             data_idx = in_element_size * ((i * ch_size) + ch);</span></span>
<span id="L1695"><span class="lineNum">    1695</span> <span class="tlaGNC">       20000 :             gst_tensor_data_raw_typecast ((gpointer) (inptr + data_idx),</span></span>
<span id="L1696"><span class="lineNum">    1696</span>              :                 in_info-&gt;type, &amp;tmp, _NNS_FLOAT64);</span>
<span id="L1697"><span class="lineNum">    1697</span>              : </span>
<span id="L1698"><span class="lineNum">    1698</span> <span class="tlaGNC">       20000 :             tmp -= average[ch];</span></span>
<span id="L1699"><span class="lineNum">    1699</span>              : </span>
<span id="L1700"><span class="lineNum">    1700</span> <span class="tlaGNC">       20000 :             data_idx = out_element_size * ((i * ch_size) + ch);</span></span>
<span id="L1701"><span class="lineNum">    1701</span> <span class="tlaGNC">       20000 :             gst_tensor_data_raw_typecast (&amp;tmp, _NNS_FLOAT64,</span></span>
<span id="L1702"><span class="lineNum">    1702</span> <span class="tlaGNC">       20000 :                 (gpointer) (outptr + data_idx), out_info-&gt;type);</span></span>
<span id="L1703"><span class="lineNum">    1703</span>              :           }</span>
<span id="L1704"><span class="lineNum">    1704</span>              :         }</span>
<span id="L1705"><span class="lineNum">    1705</span>              :       }</span>
<span id="L1706"><span class="lineNum">    1706</span> <span class="tlaGNC">           8 :       break;</span></span>
<span id="L1707"><span class="lineNum">    1707</span>              :     }</span>
<span id="L1708"><span class="lineNum">    1708</span> <span class="tlaUNC tlaBgUNC">           0 :     default:</span></span>
<span id="L1709"><span class="lineNum">    1709</span> <span class="tlaUNC">           0 :       GST_ERROR_OBJECT (filter, &quot;Cannot identify mode\n&quot;);</span></span>
<span id="L1710"><span class="lineNum">    1710</span> <span class="tlaUNC">           0 :       ret = GST_FLOW_ERROR;</span></span>
<span id="L1711"><span class="lineNum">    1711</span>              :   }</span>
<span id="L1712"><span class="lineNum">    1712</span>              : </span>
<span id="L1713"><span class="lineNum">    1713</span> <span class="tlaGNC tlaBgGNC">          16 :   g_free (average);</span></span>
<span id="L1714"><span class="lineNum">    1714</span> <span class="tlaGNC">          16 :   g_free (std);</span></span>
<span id="L1715"><span class="lineNum">    1715</span>              : </span>
<span id="L1716"><span class="lineNum">    1716</span> <span class="tlaGNC">          16 :   return ret;</span></span>
<span id="L1717"><span class="lineNum">    1717</span>              : }</span>
<span id="L1718"><span class="lineNum">    1718</span>              : </span>
<span id="L1719"><span class="lineNum">    1719</span>              : /**</span>
<span id="L1720"><span class="lineNum">    1720</span>              :  * @brief subrouting for tensor-transform, &quot;clamp&quot; case.</span>
<span id="L1721"><span class="lineNum">    1721</span>              :  *        : pixel = if (pixel &gt; max) ? max :</span>
<span id="L1722"><span class="lineNum">    1722</span>              :  *                  if (pixel &lt; min) ? min : pixel</span>
<span id="L1723"><span class="lineNum">    1723</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1724"><span class="lineNum">    1724</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1725"><span class="lineNum">    1725</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1726"><span class="lineNum">    1726</span>              :  * @param[in] inptr input tensor</span>
<span id="L1727"><span class="lineNum">    1727</span>              :  * @param[out] outptr output tensor</span>
<span id="L1728"><span class="lineNum">    1728</span>              :  * @return Gst flow status</span>
<span id="L1729"><span class="lineNum">    1729</span>              :  */</span>
<span id="L1730"><span class="lineNum">    1730</span>              : static GstFlowReturn</span>
<span id="L1731"><span class="lineNum">    1731</span> <span class="tlaGNC">          16 : gst_tensor_transform_clamp (GstTensorTransform * filter,</span></span>
<span id="L1732"><span class="lineNum">    1732</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info,</span>
<span id="L1733"><span class="lineNum">    1733</span>              :     const uint8_t * inptr, uint8_t * outptr)</span>
<span id="L1734"><span class="lineNum">    1734</span>              : {</span>
<span id="L1735"><span class="lineNum">    1735</span>              :   gsize in_element_size, out_element_size;</span>
<span id="L1736"><span class="lineNum">    1736</span>              :   gulong i, num, data_idx;</span>
<span id="L1737"><span class="lineNum">    1737</span>              :   gdouble tmp;</span>
<span id="L1738"><span class="lineNum">    1738</span>              : </span>
<span id="L1739"><span class="lineNum">    1739</span> <span class="tlaGNC">          16 :   in_element_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1740"><span class="lineNum">    1740</span> <span class="tlaGNC">          16 :   out_element_size = gst_tensor_get_element_size (out_info-&gt;type);</span></span>
<span id="L1741"><span class="lineNum">    1741</span> <span class="tlaGNC">          16 :   num = gst_tensor_get_element_count (in_info-&gt;dimension);</span></span>
<span id="L1742"><span class="lineNum">    1742</span>              : </span>
<span id="L1743"><span class="lineNum">    1743</span> <span class="tlaGNC">      606016 :   for (i = 0; i &lt; num; ++i) {</span></span>
<span id="L1744"><span class="lineNum">    1744</span> <span class="tlaGNC">      606000 :     data_idx = in_element_size * i;</span></span>
<span id="L1745"><span class="lineNum">    1745</span> <span class="tlaGNC">      606000 :     gst_tensor_data_raw_typecast ((gpointer) (inptr + data_idx), in_info-&gt;type,</span></span>
<span id="L1746"><span class="lineNum">    1746</span>              :         &amp;tmp, _NNS_FLOAT64);</span>
<span id="L1747"><span class="lineNum">    1747</span>              : </span>
<span id="L1748"><span class="lineNum">    1748</span> <span class="tlaGNC">      606000 :     tmp = CLAMP (tmp, filter-&gt;data_clamp.min, filter-&gt;data_clamp.max);</span></span>
<span id="L1749"><span class="lineNum">    1749</span>              : </span>
<span id="L1750"><span class="lineNum">    1750</span> <span class="tlaGNC">      606000 :     data_idx = out_element_size * i;</span></span>
<span id="L1751"><span class="lineNum">    1751</span> <span class="tlaGNC">      606000 :     gst_tensor_data_raw_typecast (&amp;tmp, _NNS_FLOAT64, outptr + data_idx,</span></span>
<span id="L1752"><span class="lineNum">    1752</span>              :         out_info-&gt;type);</span>
<span id="L1753"><span class="lineNum">    1753</span>              :   }</span>
<span id="L1754"><span class="lineNum">    1754</span>              : </span>
<span id="L1755"><span class="lineNum">    1755</span> <span class="tlaGNC">          16 :   return GST_FLOW_OK;</span></span>
<span id="L1756"><span class="lineNum">    1756</span>              : }</span>
<span id="L1757"><span class="lineNum">    1757</span>              : </span>
<span id="L1758"><span class="lineNum">    1758</span>              : /**</span>
<span id="L1759"><span class="lineNum">    1759</span>              :  * @brief subrouting for tensor-transform, &quot;padding&quot; case.</span>
<span id="L1760"><span class="lineNum">    1760</span>              :  * @param[in/out] filter &quot;this&quot; pointer</span>
<span id="L1761"><span class="lineNum">    1761</span>              :  * @param[in] in_info input tensor info</span>
<span id="L1762"><span class="lineNum">    1762</span>              :  * @param[in] out_info output tensor info</span>
<span id="L1763"><span class="lineNum">    1763</span>              :  * @param[in] inptr input tensor</span>
<span id="L1764"><span class="lineNum">    1764</span>              :  * @param[out] outptr output tensor</span>
<span id="L1765"><span class="lineNum">    1765</span>              :  * @return Gst flow status</span>
<span id="L1766"><span class="lineNum">    1766</span>              :  */</span>
<span id="L1767"><span class="lineNum">    1767</span>              : static GstFlowReturn</span>
<span id="L1768"><span class="lineNum">    1768</span> <span class="tlaGNC">           6 : gst_tensor_transform_padding (GstTensorTransform * filter,</span></span>
<span id="L1769"><span class="lineNum">    1769</span>              :     GstTensorInfo * in_info, GstTensorInfo * out_info, const uint8_t * inptr,</span>
<span id="L1770"><span class="lineNum">    1770</span>              :     uint8_t * outptr)</span>
<span id="L1771"><span class="lineNum">    1771</span>              : {</span>
<span id="L1772"><span class="lineNum">    1772</span>              :   gsize element_size, in_loop_size, out_loop_size, copy_block_size;</span>
<span id="L1773"><span class="lineNum">    1773</span> <span class="tlaGNC">           6 :   guint i, j, k, left, top, front, loop_limit = 1;</span></span>
<span id="L1774"><span class="lineNum">    1774</span> <span class="tlaGNC">           6 :   element_size = gst_tensor_get_element_size (in_info-&gt;type);</span></span>
<span id="L1775"><span class="lineNum">    1775</span>              : </span>
<span id="L1776"><span class="lineNum">    1776</span> <span class="tlaGNC">           6 :   in_loop_size = (gsize) in_info-&gt;dimension[2] * in_info-&gt;dimension[1]</span></span>
<span id="L1777"><span class="lineNum">    1777</span> <span class="tlaGNC">           6 :       * in_info-&gt;dimension[0] * element_size;</span></span>
<span id="L1778"><span class="lineNum">    1778</span> <span class="tlaGNC">           6 :   out_loop_size =(gsize) out_info-&gt;dimension[2] * out_info-&gt;dimension[1]</span></span>
<span id="L1779"><span class="lineNum">    1779</span> <span class="tlaGNC">           6 :       * out_info-&gt;dimension[0] * element_size;</span></span>
<span id="L1780"><span class="lineNum">    1780</span> <span class="tlaGNC">           6 :   copy_block_size = in_info-&gt;dimension[0] * element_size;</span></span>
<span id="L1781"><span class="lineNum">    1781</span>              : </span>
<span id="L1782"><span class="lineNum">    1782</span> <span class="tlaGNC">           9 :   for (i = NNS_TENSOR_PADDING_RANK_LIMIT; i &lt; NNS_TENSOR_RANK_LIMIT; i++) {</span></span>
<span id="L1783"><span class="lineNum">    1783</span> <span class="tlaGNC">           9 :     if (in_info-&gt;dimension[i] == 0)</span></span>
<span id="L1784"><span class="lineNum">    1784</span> <span class="tlaGNC">           6 :       break;</span></span>
<span id="L1785"><span class="lineNum">    1785</span> <span class="tlaGNC">           3 :     loop_limit *= in_info-&gt;dimension[i];</span></span>
<span id="L1786"><span class="lineNum">    1786</span>              :   }</span>
<span id="L1787"><span class="lineNum">    1787</span>              : </span>
<span id="L1788"><span class="lineNum">    1788</span> <span class="tlaGNC">           6 :   left = filter-&gt;data_padding.pad[PADDING_LEFT];</span></span>
<span id="L1789"><span class="lineNum">    1789</span> <span class="tlaGNC">           6 :   top = filter-&gt;data_padding.pad[PADDING_TOP];</span></span>
<span id="L1790"><span class="lineNum">    1790</span> <span class="tlaGNC">           6 :   front = filter-&gt;data_padding.pad[PADDING_FRONT];</span></span>
<span id="L1791"><span class="lineNum">    1791</span>              : </span>
<span id="L1792"><span class="lineNum">    1792</span>              :   /** @todo Add constant option instead of using zero padding value */</span>
<span id="L1793"><span class="lineNum">    1793</span> <span class="tlaGNC">           6 :   memset (outptr, 0, out_loop_size * loop_limit);</span></span>
<span id="L1794"><span class="lineNum">    1794</span>              : </span>
<span id="L1795"><span class="lineNum">    1795</span> <span class="tlaGNC">          20 :   for (i = 0; i &lt; loop_limit; i++)</span></span>
<span id="L1796"><span class="lineNum">    1796</span> <span class="tlaGNC">          56 :     for (j = 0; j &lt; in_info-&gt;dimension[2]; j++)</span></span>
<span id="L1797"><span class="lineNum">    1797</span> <span class="tlaGNC">        2142 :       for (k = 0; k &lt; in_info-&gt;dimension[1]; k++) {</span></span>
<span id="L1798"><span class="lineNum">    1798</span> <span class="tlaGNC">        2100 :         guint in_idx = j * in_info-&gt;dimension[1] * in_info-&gt;dimension[0]</span></span>
<span id="L1799"><span class="lineNum">    1799</span> <span class="tlaGNC">        2100 :             + k * in_info-&gt;dimension[0];</span></span>
<span id="L1800"><span class="lineNum">    1800</span> <span class="tlaGNC">        2100 :         guint out_idx = j * out_info-&gt;dimension[1] * out_info-&gt;dimension[0]</span></span>
<span id="L1801"><span class="lineNum">    1801</span> <span class="tlaGNC">        2100 :             + k * out_info-&gt;dimension[0];</span></span>
<span id="L1802"><span class="lineNum">    1802</span>              : </span>
<span id="L1803"><span class="lineNum">    1803</span> <span class="tlaGNC">        2100 :         out_idx += left + top * out_info-&gt;dimension[0]</span></span>
<span id="L1804"><span class="lineNum">    1804</span> <span class="tlaGNC">        2100 :             + front * out_info-&gt;dimension[1] * out_info-&gt;dimension[0];</span></span>
<span id="L1805"><span class="lineNum">    1805</span>              : </span>
<span id="L1806"><span class="lineNum">    1806</span> <span class="tlaGNC">        2100 :         memcpy (outptr + out_idx * element_size + out_loop_size * i,</span></span>
<span id="L1807"><span class="lineNum">    1807</span> <span class="tlaGNC">        2100 :             inptr + in_idx * element_size + in_loop_size * i, copy_block_size);</span></span>
<span id="L1808"><span class="lineNum">    1808</span>              :       }</span>
<span id="L1809"><span class="lineNum">    1809</span>              : </span>
<span id="L1810"><span class="lineNum">    1810</span> <span class="tlaGNC">           6 :   return GST_FLOW_OK;</span></span>
<span id="L1811"><span class="lineNum">    1811</span>              : }</span>
<span id="L1812"><span class="lineNum">    1812</span>              : </span>
<span id="L1813"><span class="lineNum">    1813</span>              : /**</span>
<span id="L1814"><span class="lineNum">    1814</span>              :  * @brief non-ip transform. required vmethod for BaseTransform class.</span>
<span id="L1815"><span class="lineNum">    1815</span>              :  * @param[in/out] trans &quot;super&quot; pointer</span>
<span id="L1816"><span class="lineNum">    1816</span>              :  * @param[in] inbuf The input gst buffer</span>
<span id="L1817"><span class="lineNum">    1817</span>              :  * @param[out] outbuf The output gst buffer</span>
<span id="L1818"><span class="lineNum">    1818</span>              :  * @return Gst Flow Status</span>
<span id="L1819"><span class="lineNum">    1819</span>              :  */</span>
<span id="L1820"><span class="lineNum">    1820</span>              : static GstFlowReturn</span>
<span id="L1821"><span class="lineNum">    1821</span> <span class="tlaGNC">       22155 : gst_tensor_transform_transform (GstBaseTransform * trans,</span></span>
<span id="L1822"><span class="lineNum">    1822</span>              :     GstBuffer * inbuf, GstBuffer * outbuf)</span>
<span id="L1823"><span class="lineNum">    1823</span>              : {</span>
<span id="L1824"><span class="lineNum">    1824</span>              :   GstTensorTransform *filter;</span>
<span id="L1825"><span class="lineNum">    1825</span>              :   GstTensorInfo *in_info, *out_info;</span>
<span id="L1826"><span class="lineNum">    1826</span> <span class="tlaGNC">       22155 :   GstFlowReturn res = GST_FLOW_ERROR;</span></span>
<span id="L1827"><span class="lineNum">    1827</span> <span class="tlaGNC">       22155 :   GstMemory *in_mem[NNS_TENSOR_SIZE_LIMIT] = { 0, };</span></span>
<span id="L1828"><span class="lineNum">    1828</span> <span class="tlaGNC">       22155 :   GstMemory *out_mem[NNS_TENSOR_SIZE_LIMIT] = { 0, };</span></span>
<span id="L1829"><span class="lineNum">    1829</span>              :   GstMapInfo in_map[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L1830"><span class="lineNum">    1830</span>              :   GstMapInfo out_map[NNS_TENSOR_SIZE_LIMIT];</span>
<span id="L1831"><span class="lineNum">    1831</span>              :   uint8_t *inptr, *outptr;</span>
<span id="L1832"><span class="lineNum">    1832</span>              :   guint i, num_tensors, num_mems;</span>
<span id="L1833"><span class="lineNum">    1833</span>              :   gsize buf_size, hsize;</span>
<span id="L1834"><span class="lineNum">    1834</span>              :   GstTensorMetaInfo meta;</span>
<span id="L1835"><span class="lineNum">    1835</span>              :   GstTensorInfo in_flex_info, out_flex_info;</span>
<span id="L1836"><span class="lineNum">    1836</span>              :   gboolean in_flexible, out_flexible;</span>
<span id="L1837"><span class="lineNum">    1837</span>              : </span>
<span id="L1838"><span class="lineNum">    1838</span> <span class="tlaGNC">       22155 :   filter = GST_TENSOR_TRANSFORM_CAST (trans);</span></span>
<span id="L1839"><span class="lineNum">    1839</span>              : </span>
<span id="L1840"><span class="lineNum">    1840</span> <span class="tlaGNC">       44306 :   g_return_val_if_fail (filter-&gt;loaded, GST_FLOW_ERROR);</span></span>
<span id="L1841"><span class="lineNum">    1841</span> <span class="tlaGNC">       22151 :   inbuf = gst_tensor_buffer_from_config (inbuf, &amp;filter-&gt;in_config);</span></span>
<span id="L1842"><span class="lineNum">    1842</span>              : </span>
<span id="L1843"><span class="lineNum">    1843</span> <span class="tlaGNC">       22151 :   in_flexible =</span></span>
<span id="L1844"><span class="lineNum">    1844</span> <span class="tlaGNC">       22151 :       gst_tensor_pad_caps_is_flexible (GST_BASE_TRANSFORM_SINK_PAD (trans));</span></span>
<span id="L1845"><span class="lineNum">    1845</span> <span class="tlaGNC">       22151 :   out_flexible =</span></span>
<span id="L1846"><span class="lineNum">    1846</span> <span class="tlaGNC">       22151 :       gst_tensor_pad_caps_is_flexible (GST_BASE_TRANSFORM_SRC_PAD (trans));</span></span>
<span id="L1847"><span class="lineNum">    1847</span>              : </span>
<span id="L1848"><span class="lineNum">    1848</span> <span class="tlaGNC">       22151 :   num_mems = gst_tensor_buffer_get_count (inbuf);</span></span>
<span id="L1849"><span class="lineNum">    1849</span> <span class="tlaGNC">       22151 :   if (in_flexible) {</span></span>
<span id="L1850"><span class="lineNum">    1850</span> <span class="tlaGNC">           8 :     num_tensors = num_mems;</span></span>
<span id="L1851"><span class="lineNum">    1851</span> <span class="tlaGNC">           8 :     g_return_val_if_fail (out_flexible, GST_FLOW_ERROR);</span></span>
<span id="L1852"><span class="lineNum">    1852</span>              :   } else {</span>
<span id="L1853"><span class="lineNum">    1853</span> <span class="tlaGNC">       22143 :     num_tensors = filter-&gt;in_config.info.num_tensors;</span></span>
<span id="L1854"><span class="lineNum">    1854</span> <span class="tlaGNC">       22143 :     g_return_val_if_fail (num_mems == num_tensors, GST_FLOW_ERROR);</span></span>
<span id="L1855"><span class="lineNum">    1855</span>              :   }</span>
<span id="L1856"><span class="lineNum">    1856</span>              : </span>
<span id="L1857"><span class="lineNum">    1857</span> <span class="tlaGNC">       44388 :   for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L1858"><span class="lineNum">    1858</span> <span class="tlaGNC">       22237 :     in_info = gst_tensors_info_get_nth_info (&amp;filter-&gt;in_config.info, i);</span></span>
<span id="L1859"><span class="lineNum">    1859</span> <span class="tlaGNC">       22237 :     out_info = gst_tensors_info_get_nth_info (&amp;filter-&gt;out_config.info, i);</span></span>
<span id="L1860"><span class="lineNum">    1860</span>              : </span>
<span id="L1861"><span class="lineNum">    1861</span> <span class="tlaGNC">       22237 :     if (filter-&gt;apply &amp;&amp; !g_list_find (filter-&gt;apply, GINT_TO_POINTER (i))) {</span></span>
<span id="L1862"><span class="lineNum">    1862</span> <span class="tlaGNC">          15 :       GstMemory *mem = gst_tensor_buffer_get_nth_memory (inbuf, i);</span></span>
<span id="L1863"><span class="lineNum">    1863</span>              : </span>
<span id="L1864"><span class="lineNum">    1864</span> <span class="tlaGNC">          15 :       if (!in_flexible &amp;&amp; out_flexible) {</span></span>
<span id="L1865"><span class="lineNum">    1865</span> <span class="tlaUNC tlaBgUNC">           0 :         GstMemory *old = mem;</span></span>
<span id="L1866"><span class="lineNum">    1866</span>              : </span>
<span id="L1867"><span class="lineNum">    1867</span>              :         /* append meta */</span>
<span id="L1868"><span class="lineNum">    1868</span> <span class="tlaUNC">           0 :         gst_tensor_info_convert_to_meta (out_info, &amp;meta);</span></span>
<span id="L1869"><span class="lineNum">    1869</span> <span class="tlaUNC">           0 :         mem = gst_tensor_meta_info_append_header (&amp;meta, old);</span></span>
<span id="L1870"><span class="lineNum">    1870</span> <span class="tlaUNC">           0 :         gst_memory_unref (old);</span></span>
<span id="L1871"><span class="lineNum">    1871</span>              :       }</span>
<span id="L1872"><span class="lineNum">    1872</span>              : </span>
<span id="L1873"><span class="lineNum">    1873</span> <span class="tlaGNC tlaBgGNC">          15 :       gst_tensor_buffer_append_memory (outbuf, mem, out_info);</span></span>
<span id="L1874"><span class="lineNum">    1874</span> <span class="tlaGNC">          15 :       continue;</span></span>
<span id="L1875"><span class="lineNum">    1875</span>              :     }</span>
<span id="L1876"><span class="lineNum">    1876</span>              : </span>
<span id="L1877"><span class="lineNum">    1877</span>              :     /* parse input buffer */</span>
<span id="L1878"><span class="lineNum">    1878</span> <span class="tlaGNC">       22222 :     in_mem[i] = gst_tensor_buffer_get_nth_memory (inbuf, i);</span></span>
<span id="L1879"><span class="lineNum">    1879</span> <span class="tlaGNC">       22222 :     if (!gst_memory_map (in_mem[i], &amp;in_map[i], GST_MAP_READ)) {</span></span>
<span id="L1880"><span class="lineNum">    1880</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_loge (&quot;Cannot map input buffer to gst-buf at tensor-transform.\n&quot;);</span></span>
<span id="L1881"><span class="lineNum">    1881</span> <span class="tlaUNC">           0 :       res = GST_FLOW_ERROR;</span></span>
<span id="L1882"><span class="lineNum">    1882</span> <span class="tlaUNC">           0 :       goto done;</span></span>
<span id="L1883"><span class="lineNum">    1883</span>              :     }</span>
<span id="L1884"><span class="lineNum">    1884</span> <span class="tlaGNC tlaBgGNC">       22222 :     inptr = in_map[i].data;</span></span>
<span id="L1885"><span class="lineNum">    1885</span>              : </span>
<span id="L1886"><span class="lineNum">    1886</span> <span class="tlaGNC">       22222 :     if (in_flexible) {</span></span>
<span id="L1887"><span class="lineNum">    1887</span> <span class="tlaGNC">           8 :       in_info = &amp;in_flex_info;</span></span>
<span id="L1888"><span class="lineNum">    1888</span> <span class="tlaGNC">           8 :       out_info = &amp;out_flex_info;</span></span>
<span id="L1889"><span class="lineNum">    1889</span>              : </span>
<span id="L1890"><span class="lineNum">    1890</span> <span class="tlaGNC">           8 :       gst_tensor_meta_info_parse_header (&amp;meta, inptr);</span></span>
<span id="L1891"><span class="lineNum">    1891</span>              :       /** @todo max rank supported in tensor-transform is 4 */</span>
<span id="L1892"><span class="lineNum">    1892</span> <span class="tlaGNC">           8 :       if (!gst_tensor_meta_info_convert (&amp;meta, in_info)) {</span></span>
<span id="L1893"><span class="lineNum">    1893</span> <span class="tlaUNC tlaBgUNC">           0 :         res = GST_FLOW_ERROR;</span></span>
<span id="L1894"><span class="lineNum">    1894</span> <span class="tlaUNC">           0 :         goto done;</span></span>
<span id="L1895"><span class="lineNum">    1895</span>              :       }</span>
<span id="L1896"><span class="lineNum">    1896</span>              : </span>
<span id="L1897"><span class="lineNum">    1897</span> <span class="tlaGNC tlaBgGNC">           8 :       gst_tensor_transform_convert_dimension (filter, GST_PAD_SINK,</span></span>
<span id="L1898"><span class="lineNum">    1898</span>              :           i, in_info, out_info);</span>
<span id="L1899"><span class="lineNum">    1899</span>              : </span>
<span id="L1900"><span class="lineNum">    1900</span> <span class="tlaGNC">           8 :       hsize = gst_tensor_meta_info_get_header_size (&amp;meta);</span></span>
<span id="L1901"><span class="lineNum">    1901</span> <span class="tlaGNC">           8 :       inptr += hsize;</span></span>
<span id="L1902"><span class="lineNum">    1902</span>              :     }</span>
<span id="L1903"><span class="lineNum">    1903</span>              : </span>
<span id="L1904"><span class="lineNum">    1904</span>              :     /* prepare output buffer */</span>
<span id="L1905"><span class="lineNum">    1905</span> <span class="tlaGNC">       22222 :     buf_size = gst_tensor_info_get_size (out_info);</span></span>
<span id="L1906"><span class="lineNum">    1906</span> <span class="tlaGNC">       22222 :     if (out_flexible) {</span></span>
<span id="L1907"><span class="lineNum">    1907</span> <span class="tlaGNC">           8 :       gst_tensor_info_convert_to_meta (out_info, &amp;meta);</span></span>
<span id="L1908"><span class="lineNum">    1908</span> <span class="tlaGNC">           8 :       hsize = gst_tensor_meta_info_get_header_size (&amp;meta);</span></span>
<span id="L1909"><span class="lineNum">    1909</span> <span class="tlaGNC">           8 :       buf_size += hsize;</span></span>
<span id="L1910"><span class="lineNum">    1910</span>              :     }</span>
<span id="L1911"><span class="lineNum">    1911</span>              : </span>
<span id="L1912"><span class="lineNum">    1912</span> <span class="tlaGNC">       22222 :     out_mem[i] = gst_allocator_alloc (NULL, buf_size, NULL);</span></span>
<span id="L1913"><span class="lineNum">    1913</span> <span class="tlaGNC">       22222 :     gst_tensor_buffer_append_memory (outbuf, out_mem[i], out_info);</span></span>
<span id="L1914"><span class="lineNum">    1914</span>              : </span>
<span id="L1915"><span class="lineNum">    1915</span> <span class="tlaGNC">       22222 :     if (!gst_memory_map (out_mem[i], &amp;out_map[i], GST_MAP_WRITE)) {</span></span>
<span id="L1916"><span class="lineNum">    1916</span> <span class="tlaUNC tlaBgUNC">           0 :       ml_loge (&quot;Cannot map output buffer to gst-buf at tensor-transform.\n&quot;);</span></span>
<span id="L1917"><span class="lineNum">    1917</span> <span class="tlaUNC">           0 :       res = GST_FLOW_ERROR;</span></span>
<span id="L1918"><span class="lineNum">    1918</span> <span class="tlaUNC">           0 :       goto done;</span></span>
<span id="L1919"><span class="lineNum">    1919</span>              :     }</span>
<span id="L1920"><span class="lineNum">    1920</span> <span class="tlaGNC tlaBgGNC">       22222 :     outptr = out_map[i].data;</span></span>
<span id="L1921"><span class="lineNum">    1921</span>              : </span>
<span id="L1922"><span class="lineNum">    1922</span> <span class="tlaGNC">       22222 :     if (out_flexible) {</span></span>
<span id="L1923"><span class="lineNum">    1923</span> <span class="tlaGNC">           8 :       gst_tensor_meta_info_update_header (&amp;meta, outptr);</span></span>
<span id="L1924"><span class="lineNum">    1924</span> <span class="tlaGNC">           8 :       outptr += hsize;</span></span>
<span id="L1925"><span class="lineNum">    1925</span>              :     }</span>
<span id="L1926"><span class="lineNum">    1926</span>              : </span>
<span id="L1927"><span class="lineNum">    1927</span> <span class="tlaGNC">       22222 :     switch (filter-&gt;mode) {</span></span>
<span id="L1928"><span class="lineNum">    1928</span> <span class="tlaGNC">          52 :       case GTT_DIMCHG:</span></span>
<span id="L1929"><span class="lineNum">    1929</span> <span class="tlaGNC">          52 :         res = gst_tensor_transform_dimchg (filter, in_info, out_info,</span></span>
<span id="L1930"><span class="lineNum">    1930</span>              :             inptr, outptr);</span>
<span id="L1931"><span class="lineNum">    1931</span> <span class="tlaGNC">          52 :         break;</span></span>
<span id="L1932"><span class="lineNum">    1932</span> <span class="tlaGNC">         579 :       case GTT_TYPECAST:</span></span>
<span id="L1933"><span class="lineNum">    1933</span> <span class="tlaGNC">         579 :         res = gst_tensor_transform_typecast (filter, in_info, out_info,</span></span>
<span id="L1934"><span class="lineNum">    1934</span>              :             inptr, outptr);</span>
<span id="L1935"><span class="lineNum">    1935</span> <span class="tlaGNC">         579 :         break;</span></span>
<span id="L1936"><span class="lineNum">    1936</span> <span class="tlaGNC">       21495 :       case GTT_ARITHMETIC:</span></span>
<span id="L1937"><span class="lineNum">    1937</span> <span class="tlaGNC">       21495 :         res = gst_tensor_transform_arithmetic (filter, in_info, out_info,</span></span>
<span id="L1938"><span class="lineNum">    1938</span>              :             inptr, outptr);</span>
<span id="L1939"><span class="lineNum">    1939</span> <span class="tlaGNC">       21495 :         break;</span></span>
<span id="L1940"><span class="lineNum">    1940</span> <span class="tlaGNC">          58 :       case GTT_TRANSPOSE:</span></span>
<span id="L1941"><span class="lineNum">    1941</span> <span class="tlaGNC">          58 :         res = gst_tensor_transform_transpose (filter, in_info, out_info,</span></span>
<span id="L1942"><span class="lineNum">    1942</span>              :             inptr, outptr);</span>
<span id="L1943"><span class="lineNum">    1943</span> <span class="tlaGNC">          58 :         break;</span></span>
<span id="L1944"><span class="lineNum">    1944</span> <span class="tlaGNC">          16 :       case GTT_STAND:</span></span>
<span id="L1945"><span class="lineNum">    1945</span> <span class="tlaGNC">          16 :         res = gst_tensor_transform_stand (filter, in_info, out_info,</span></span>
<span id="L1946"><span class="lineNum">    1946</span>              :             inptr, outptr);</span>
<span id="L1947"><span class="lineNum">    1947</span> <span class="tlaGNC">          16 :         break;</span></span>
<span id="L1948"><span class="lineNum">    1948</span> <span class="tlaGNC">          16 :       case GTT_CLAMP:</span></span>
<span id="L1949"><span class="lineNum">    1949</span> <span class="tlaGNC">          16 :         res = gst_tensor_transform_clamp (filter, in_info, out_info,</span></span>
<span id="L1950"><span class="lineNum">    1950</span>              :             inptr, outptr);</span>
<span id="L1951"><span class="lineNum">    1951</span> <span class="tlaGNC">          16 :         break;</span></span>
<span id="L1952"><span class="lineNum">    1952</span> <span class="tlaGNC">           6 :       case GTT_PADDING:</span></span>
<span id="L1953"><span class="lineNum">    1953</span> <span class="tlaGNC">           6 :         res = gst_tensor_transform_padding (filter, in_info, out_info,</span></span>
<span id="L1954"><span class="lineNum">    1954</span>              :             inptr, outptr);</span>
<span id="L1955"><span class="lineNum">    1955</span> <span class="tlaGNC">           6 :         break;</span></span>
<span id="L1956"><span class="lineNum">    1956</span> <span class="tlaUNC tlaBgUNC">           0 :       default:</span></span>
<span id="L1957"><span class="lineNum">    1957</span> <span class="tlaUNC">           0 :         ml_loge (&quot;Not supported tensor transform mode&quot;);</span></span>
<span id="L1958"><span class="lineNum">    1958</span> <span class="tlaUNC">           0 :         res = GST_FLOW_NOT_SUPPORTED;</span></span>
<span id="L1959"><span class="lineNum">    1959</span> <span class="tlaUNC">           0 :         goto done;</span></span>
<span id="L1960"><span class="lineNum">    1960</span>              :     }</span>
<span id="L1961"><span class="lineNum">    1961</span>              :   }</span>
<span id="L1962"><span class="lineNum">    1962</span>              : </span>
<span id="L1963"><span class="lineNum">    1963</span> <span class="tlaGNC tlaBgGNC">       22151 : done:</span></span>
<span id="L1964"><span class="lineNum">    1964</span> <span class="tlaGNC">       44388 :   for (i = 0; i &lt; num_tensors; i++) {</span></span>
<span id="L1965"><span class="lineNum">    1965</span> <span class="tlaGNC">       22237 :     if (in_mem[i]) {</span></span>
<span id="L1966"><span class="lineNum">    1966</span> <span class="tlaGNC">       22222 :       gst_memory_unmap (in_mem[i], &amp;in_map[i]);</span></span>
<span id="L1967"><span class="lineNum">    1967</span> <span class="tlaGNC">       22222 :       gst_memory_unref (in_mem[i]);</span></span>
<span id="L1968"><span class="lineNum">    1968</span>              :     }</span>
<span id="L1969"><span class="lineNum">    1969</span> <span class="tlaGNC">       22237 :     if (out_mem[i])</span></span>
<span id="L1970"><span class="lineNum">    1970</span> <span class="tlaGNC">       22222 :       gst_memory_unmap (out_mem[i], &amp;out_map[i]);</span></span>
<span id="L1971"><span class="lineNum">    1971</span>              :   }</span>
<span id="L1972"><span class="lineNum">    1972</span>              : </span>
<span id="L1973"><span class="lineNum">    1973</span> <span class="tlaGNC">       22151 :   return res;</span></span>
<span id="L1974"><span class="lineNum">    1974</span>              : }</span>
<span id="L1975"><span class="lineNum">    1975</span>              : </span>
<span id="L1976"><span class="lineNum">    1976</span>              : /**</span>
<span id="L1977"><span class="lineNum">    1977</span>              :  * @brief Dimension conversion calculation</span>
<span id="L1978"><span class="lineNum">    1978</span>              :  * @param[in] filter &quot;this&quot; pointer</span>
<span id="L1979"><span class="lineNum">    1979</span>              :  * @param[in] direction GST_PAD_SINK if input-&gt;output conv</span>
<span id="L1980"><span class="lineNum">    1980</span>              :  * @param[in] idx index of the input tensors</span>
<span id="L1981"><span class="lineNum">    1981</span>              :  * @param[in] in_info tensor info structure of source tensor (input if direction is SINK)</span>
<span id="L1982"><span class="lineNum">    1982</span>              :  * @param[out] out_info tensor info structure of destination tensor (output if direction is SINK)</span>
<span id="L1983"><span class="lineNum">    1983</span>              :  * @return TRUE if success</span>
<span id="L1984"><span class="lineNum">    1984</span>              :  */</span>
<span id="L1985"><span class="lineNum">    1985</span>              : static gboolean</span>
<span id="L1986"><span class="lineNum">    1986</span> <span class="tlaGNC">        3774 : gst_tensor_transform_convert_dimension (GstTensorTransform * filter,</span></span>
<span id="L1987"><span class="lineNum">    1987</span>              :     GstPadDirection direction, guint idx, const GstTensorInfo * in_info,</span>
<span id="L1988"><span class="lineNum">    1988</span>              :     GstTensorInfo * out_info)</span>
<span id="L1989"><span class="lineNum">    1989</span>              : {</span>
<span id="L1990"><span class="lineNum">    1990</span>              :   guint i;</span>
<span id="L1991"><span class="lineNum">    1991</span>              : </span>
<span id="L1992"><span class="lineNum">    1992</span>              :   /* copy input info first, then update output info */</span>
<span id="L1993"><span class="lineNum">    1993</span> <span class="tlaGNC">        3774 :   gst_tensor_info_copy (out_info, in_info);</span></span>
<span id="L1994"><span class="lineNum">    1994</span>              : </span>
<span id="L1995"><span class="lineNum">    1995</span> <span class="tlaGNC">        3774 :   if (filter-&gt;apply &amp;&amp; !g_list_find (filter-&gt;apply, GINT_TO_POINTER (idx)))</span></span>
<span id="L1996"><span class="lineNum">    1996</span> <span class="tlaGNC">          10 :     return TRUE;</span></span>
<span id="L1997"><span class="lineNum">    1997</span>              : </span>
<span id="L1998"><span class="lineNum">    1998</span> <span class="tlaGNC">        3764 :   switch (filter-&gt;mode) {</span></span>
<span id="L1999"><span class="lineNum">    1999</span> <span class="tlaGNC">          70 :     case GTT_DIMCHG:</span></span>
<span id="L2000"><span class="lineNum">    2000</span>              :     {</span>
<span id="L2001"><span class="lineNum">    2001</span> <span class="tlaGNC">          70 :       unsigned int from = filter-&gt;data_dimchg.from;</span></span>
<span id="L2002"><span class="lineNum">    2002</span> <span class="tlaGNC">          70 :       unsigned int to = filter-&gt;data_dimchg.to;</span></span>
<span id="L2003"><span class="lineNum">    2003</span>              : </span>
<span id="L2004"><span class="lineNum">    2004</span> <span class="tlaGNC">          70 :       if (direction == GST_PAD_SINK) {</span></span>
<span id="L2005"><span class="lineNum">    2005</span> <span class="tlaGNC">         850 :         for (i = 0; i &lt; NNS_TENSOR_RANK_LIMIT; i++) {</span></span>
<span id="L2006"><span class="lineNum">    2006</span> <span class="tlaGNC">         800 :           if ((i &lt; from &amp;&amp; i &lt; to) || (i &gt; from &amp;&amp; i &gt; to) || from == to) {</span></span>
<span id="L2007"><span class="lineNum">    2007</span> <span class="tlaGNC">         634 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i];</span></span>
<span id="L2008"><span class="lineNum">    2008</span> <span class="tlaGNC">         166 :           } else if (i == to) {</span></span>
<span id="L2009"><span class="lineNum">    2009</span> <span class="tlaGNC">          50 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[from];</span></span>
<span id="L2010"><span class="lineNum">    2010</span> <span class="tlaGNC">         116 :           } else if (from &gt; to) {</span></span>
<span id="L2011"><span class="lineNum">    2011</span> <span class="tlaUNC tlaBgUNC">           0 :             g_assert (i &gt; 0 &amp;&amp; i &gt; to);</span></span>
<span id="L2012"><span class="lineNum">    2012</span> <span class="tlaUNC">           0 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i - 1];</span></span>
<span id="L2013"><span class="lineNum">    2013</span>              :           } else {</span>
<span id="L2014"><span class="lineNum">    2014</span> <span class="tlaGNC tlaBgGNC">         116 :             g_assert (i &lt; to &amp;&amp; i &lt; (NNS_TENSOR_RANK_LIMIT - 1));</span></span>
<span id="L2015"><span class="lineNum">    2015</span> <span class="tlaGNC">         116 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i + 1];</span></span>
<span id="L2016"><span class="lineNum">    2016</span>              :           }</span>
<span id="L2017"><span class="lineNum">    2017</span>              :         }</span>
<span id="L2018"><span class="lineNum">    2018</span>              :       } else {</span>
<span id="L2019"><span class="lineNum">    2019</span> <span class="tlaGNC">         340 :         for (i = 0; i &lt; NNS_TENSOR_RANK_LIMIT; i++) {</span></span>
<span id="L2020"><span class="lineNum">    2020</span> <span class="tlaGNC">         320 :           if ((i &lt; from &amp;&amp; i &lt; to) || (i &gt; from &amp;&amp; i &gt; to) || from == to) {</span></span>
<span id="L2021"><span class="lineNum">    2021</span> <span class="tlaGNC">         252 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i];</span></span>
<span id="L2022"><span class="lineNum">    2022</span> <span class="tlaGNC">          68 :           } else if (i == from) {</span></span>
<span id="L2023"><span class="lineNum">    2023</span> <span class="tlaGNC">          20 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[to];</span></span>
<span id="L2024"><span class="lineNum">    2024</span> <span class="tlaGNC">          48 :           } else if (from &gt; to) {</span></span>
<span id="L2025"><span class="lineNum">    2025</span> <span class="tlaUNC tlaBgUNC">           0 :             g_assert (i &lt; from &amp;&amp; i &lt; (NNS_TENSOR_RANK_LIMIT - 1));</span></span>
<span id="L2026"><span class="lineNum">    2026</span> <span class="tlaUNC">           0 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i + 1];</span></span>
<span id="L2027"><span class="lineNum">    2027</span>              :           } else {</span>
<span id="L2028"><span class="lineNum">    2028</span> <span class="tlaGNC tlaBgGNC">          48 :             g_assert (i &gt; 0 &amp;&amp; i &gt; from);</span></span>
<span id="L2029"><span class="lineNum">    2029</span> <span class="tlaGNC">          48 :             out_info-&gt;dimension[i] = in_info-&gt;dimension[i - 1];</span></span>
<span id="L2030"><span class="lineNum">    2030</span>              :           }</span>
<span id="L2031"><span class="lineNum">    2031</span>              :         }</span>
<span id="L2032"><span class="lineNum">    2032</span>              :       }</span>
<span id="L2033"><span class="lineNum">    2033</span> <span class="tlaGNC">          70 :       break;</span></span>
<span id="L2034"><span class="lineNum">    2034</span>              :     }</span>
<span id="L2035"><span class="lineNum">    2035</span> <span class="tlaGNC">        2016 :     case GTT_TYPECAST:</span></span>
<span id="L2036"><span class="lineNum">    2036</span>              :       /** For both directions, dimension does not change */</span>
<span id="L2037"><span class="lineNum">    2037</span> <span class="tlaGNC">        2016 :       if (direction == GST_PAD_SINK) {</span></span>
<span id="L2038"><span class="lineNum">    2038</span>              :         /** src = SINKPAD / dest = SRCPAD */</span>
<span id="L2039"><span class="lineNum">    2039</span> <span class="tlaGNC">        1142 :         out_info-&gt;type = filter-&gt;data_typecast.to;</span></span>
<span id="L2040"><span class="lineNum">    2040</span>              :       } else {</span>
<span id="L2041"><span class="lineNum">    2041</span>              :         /* cannot get the incoming data type on sink pad */</span>
<span id="L2042"><span class="lineNum">    2042</span> <span class="tlaGNC">         874 :         out_info-&gt;type = _NNS_END;</span></span>
<span id="L2043"><span class="lineNum">    2043</span>              :       }</span>
<span id="L2044"><span class="lineNum">    2044</span> <span class="tlaGNC">        2016 :       break;</span></span>
<span id="L2045"><span class="lineNum">    2045</span>              : </span>
<span id="L2046"><span class="lineNum">    2046</span> <span class="tlaGNC">        1025 :     case GTT_ARITHMETIC:</span></span>
<span id="L2047"><span class="lineNum">    2047</span>              :       /* check arith mode option has typecast operator */</span>
<span id="L2048"><span class="lineNum">    2048</span> <span class="tlaGNC">        1025 :       if (filter-&gt;data_arithmetic.out_type != _NNS_END) {</span></span>
<span id="L2049"><span class="lineNum">    2049</span> <span class="tlaGNC">         783 :         if (direction == GST_PAD_SINK) {</span></span>
<span id="L2050"><span class="lineNum">    2050</span> <span class="tlaGNC">         414 :           out_info-&gt;type = filter-&gt;data_arithmetic.out_type;</span></span>
<span id="L2051"><span class="lineNum">    2051</span>              :         } else {</span>
<span id="L2052"><span class="lineNum">    2052</span>              :           /* cannot get the incoming data type on sink pad */</span>
<span id="L2053"><span class="lineNum">    2053</span> <span class="tlaGNC">         369 :           out_info-&gt;type = _NNS_END;</span></span>
<span id="L2054"><span class="lineNum">    2054</span>              :         }</span>
<span id="L2055"><span class="lineNum">    2055</span>              :       }</span>
<span id="L2056"><span class="lineNum">    2056</span> <span class="tlaGNC">        1025 :       break;</span></span>
<span id="L2057"><span class="lineNum">    2057</span>              : </span>
<span id="L2058"><span class="lineNum">    2058</span> <span class="tlaGNC">         281 :     case GTT_TRANSPOSE:</span></span>
<span id="L2059"><span class="lineNum">    2059</span> <span class="tlaGNC">         281 :       if (direction == GST_PAD_SINK) {</span></span>
<span id="L2060"><span class="lineNum">    2060</span> <span class="tlaGNC">         715 :         for (i = 0; i &lt; NNS_TENSOR_TRANSPOSE_RANK_LIMIT; i++) {</span></span>
<span id="L2061"><span class="lineNum">    2061</span> <span class="tlaGNC">         572 :           out_info-&gt;dimension[i] =</span></span>
<span id="L2062"><span class="lineNum">    2062</span> <span class="tlaGNC">         572 :               in_info-&gt;dimension[filter-&gt;data_transpose.trans_order[i]];</span></span>
<span id="L2063"><span class="lineNum">    2063</span>              :         }</span>
<span id="L2064"><span class="lineNum">    2064</span>              :       } else {</span>
<span id="L2065"><span class="lineNum">    2065</span> <span class="tlaGNC">         690 :         for (i = 0; i &lt; NNS_TENSOR_TRANSPOSE_RANK_LIMIT; i++) {</span></span>
<span id="L2066"><span class="lineNum">    2066</span> <span class="tlaGNC">         552 :           g_assert (filter-&gt;data_transpose.trans_order[i] &lt;</span></span>
<span id="L2067"><span class="lineNum">    2067</span>              :               NNS_TENSOR_RANK_LIMIT);</span>
<span id="L2068"><span class="lineNum">    2068</span> <span class="tlaGNC">         552 :           out_info-&gt;dimension[filter-&gt;data_transpose.trans_order[i]] =</span></span>
<span id="L2069"><span class="lineNum">    2069</span> <span class="tlaGNC">         552 :               in_info-&gt;dimension[i];</span></span>
<span id="L2070"><span class="lineNum">    2070</span>              :         }</span>
<span id="L2071"><span class="lineNum">    2071</span>              :       }</span>
<span id="L2072"><span class="lineNum">    2072</span> <span class="tlaGNC">         281 :       break;</span></span>
<span id="L2073"><span class="lineNum">    2073</span>              : </span>
<span id="L2074"><span class="lineNum">    2074</span> <span class="tlaGNC">          40 :     case GTT_STAND:</span></span>
<span id="L2075"><span class="lineNum">    2075</span>              :       /** For both directions, dimension does not change */</span>
<span id="L2076"><span class="lineNum">    2076</span> <span class="tlaGNC">          40 :       if (direction == GST_PAD_SINK) {</span></span>
<span id="L2077"><span class="lineNum">    2077</span> <span class="tlaGNC">          24 :         if (filter-&gt;data_stand.out_type != _NNS_END)</span></span>
<span id="L2078"><span class="lineNum">    2078</span> <span class="tlaGNC">          12 :           out_info-&gt;type = filter-&gt;data_stand.out_type;</span></span>
<span id="L2079"><span class="lineNum">    2079</span>              :       } else {</span>
<span id="L2080"><span class="lineNum">    2080</span>              :         /* cannot get the incoming data type on sink pad */</span>
<span id="L2081"><span class="lineNum">    2081</span> <span class="tlaGNC">          16 :         out_info-&gt;type = _NNS_END;</span></span>
<span id="L2082"><span class="lineNum">    2082</span>              :       }</span>
<span id="L2083"><span class="lineNum">    2083</span> <span class="tlaGNC">          40 :       break;</span></span>
<span id="L2084"><span class="lineNum">    2084</span>              : </span>
<span id="L2085"><span class="lineNum">    2085</span> <span class="tlaGNC">         136 :     case GTT_CLAMP:</span></span>
<span id="L2086"><span class="lineNum">    2086</span>              :       /* same tensors info, do nothing. */</span>
<span id="L2087"><span class="lineNum">    2087</span> <span class="tlaGNC">         136 :       break;</span></span>
<span id="L2088"><span class="lineNum">    2088</span>              : </span>
<span id="L2089"><span class="lineNum">    2089</span> <span class="tlaGNC">          44 :     case GTT_PADDING:</span></span>
<span id="L2090"><span class="lineNum">    2090</span> <span class="tlaGNC">          44 :       if (direction == GST_PAD_SINK) {</span></span>
<span id="L2091"><span class="lineNum">    2091</span> <span class="tlaGNC">          30 :         out_info-&gt;dimension[0] +=</span></span>
<span id="L2092"><span class="lineNum">    2092</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_LEFT] +</span></span>
<span id="L2093"><span class="lineNum">    2093</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_RIGHT];</span></span>
<span id="L2094"><span class="lineNum">    2094</span> <span class="tlaGNC">          30 :         out_info-&gt;dimension[1] +=</span></span>
<span id="L2095"><span class="lineNum">    2095</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_TOP] +</span></span>
<span id="L2096"><span class="lineNum">    2096</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_BOTTOM];</span></span>
<span id="L2097"><span class="lineNum">    2097</span> <span class="tlaGNC">          30 :         out_info-&gt;dimension[2] +=</span></span>
<span id="L2098"><span class="lineNum">    2098</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_FRONT] +</span></span>
<span id="L2099"><span class="lineNum">    2099</span> <span class="tlaGNC">          30 :             filter-&gt;data_padding.pad[PADDING_BACK];</span></span>
<span id="L2100"><span class="lineNum">    2100</span>              :       }</span>
<span id="L2101"><span class="lineNum">    2101</span> <span class="tlaGNC">          44 :       break;</span></span>
<span id="L2102"><span class="lineNum">    2102</span> <span class="tlaGNC">         152 :     default:</span></span>
<span id="L2103"><span class="lineNum">    2103</span> <span class="tlaGNC">         152 :       return FALSE;</span></span>
<span id="L2104"><span class="lineNum">    2104</span>              :   }</span>
<span id="L2105"><span class="lineNum">    2105</span>              : </span>
<span id="L2106"><span class="lineNum">    2106</span> <span class="tlaGNC">        3612 :   return TRUE;</span></span>
<span id="L2107"><span class="lineNum">    2107</span>              : }</span>
<span id="L2108"><span class="lineNum">    2108</span>              : </span>
<span id="L2109"><span class="lineNum">    2109</span>              : /**</span>
<span id="L2110"><span class="lineNum">    2110</span>              :  * @brief configure srcpad cap from &quot;proposed&quot; cap. (required vmethod for BaseTransform)</span>
<span id="L2111"><span class="lineNum">    2111</span>              :  *</span>
<span id="L2112"><span class="lineNum">    2112</span>              :  * @param trans (&quot;this&quot; pointer)</span>
<span id="L2113"><span class="lineNum">    2113</span>              :  * @param direction (why do we need this?)</span>
<span id="L2114"><span class="lineNum">    2114</span>              :  * @param caps sinkpad cap</span>
<span id="L2115"><span class="lineNum">    2115</span>              :  * @param filtercap this element's cap (don't know specifically.)</span>
<span id="L2116"><span class="lineNum">    2116</span>              :  *</span>
<span id="L2117"><span class="lineNum">    2117</span>              :  * @todo Get to know what the heck is @filtercap and use it!</span>
<span id="L2118"><span class="lineNum">    2118</span>              :  */</span>
<span id="L2119"><span class="lineNum">    2119</span>              : static GstCaps *</span>
<span id="L2120"><span class="lineNum">    2120</span> <span class="tlaGNC">        3169 : gst_tensor_transform_transform_caps (GstBaseTransform * trans,</span></span>
<span id="L2121"><span class="lineNum">    2121</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * filtercap)</span>
<span id="L2122"><span class="lineNum">    2122</span>              : {</span>
<span id="L2123"><span class="lineNum">    2123</span>              :   GstTensorTransform *filter;</span>
<span id="L2124"><span class="lineNum">    2124</span> <span class="tlaGNC">        3169 :   GstCaps *result = NULL;</span></span>
<span id="L2125"><span class="lineNum">    2125</span>              :   GstStructure *structure;</span>
<span id="L2126"><span class="lineNum">    2126</span>              :   guint i, j;</span>
<span id="L2127"><span class="lineNum">    2127</span>              : </span>
<span id="L2128"><span class="lineNum">    2128</span> <span class="tlaGNC">        3169 :   filter = GST_TENSOR_TRANSFORM_CAST (trans);</span></span>
<span id="L2129"><span class="lineNum">    2129</span>              : </span>
<span id="L2130"><span class="lineNum">    2130</span> <span class="tlaGNC">        3169 :   silent_debug (filter, &quot;Calling TransformCaps, direction = %d\n&quot;, direction);</span></span>
<span id="L2131"><span class="lineNum">    2131</span> <span class="tlaGNC">        3169 :   silent_debug_caps (filter, caps, &quot;from&quot;);</span></span>
<span id="L2132"><span class="lineNum">    2132</span> <span class="tlaGNC">        3169 :   silent_debug_caps (filter, filtercap, &quot;filter&quot;);</span></span>
<span id="L2133"><span class="lineNum">    2133</span>              : </span>
<span id="L2134"><span class="lineNum">    2134</span> <span class="tlaGNC">        3169 :   result = gst_caps_new_empty ();</span></span>
<span id="L2135"><span class="lineNum">    2135</span> <span class="tlaGNC">        9447 :   for (i = 0; i &lt; gst_caps_get_size (caps); i++) {</span></span>
<span id="L2136"><span class="lineNum">    2136</span>              :     GstTensorsConfig in_config, out_config;</span>
<span id="L2137"><span class="lineNum">    2137</span>              :     GstTensorInfo *in_info, *out_info;</span>
<span id="L2138"><span class="lineNum">    2138</span> <span class="tlaGNC">        6278 :     gboolean is_types_not_fixed = FALSE;</span></span>
<span id="L2139"><span class="lineNum">    2139</span> <span class="tlaGNC">        6278 :     GstCaps *result_aux = gst_caps_new_empty ();</span></span>
<span id="L2140"><span class="lineNum">    2140</span>              : </span>
<span id="L2141"><span class="lineNum">    2141</span> <span class="tlaGNC">        6278 :     gst_tensors_config_init (&amp;out_config);</span></span>
<span id="L2142"><span class="lineNum">    2142</span>              : </span>
<span id="L2143"><span class="lineNum">    2143</span> <span class="tlaGNC">        6278 :     structure = gst_caps_get_structure (caps, i);</span></span>
<span id="L2144"><span class="lineNum">    2144</span> <span class="tlaGNC">        6278 :     gst_tensors_config_from_structure (&amp;in_config, structure);</span></span>
<span id="L2145"><span class="lineNum">    2145</span>              : </span>
<span id="L2146"><span class="lineNum">    2146</span> <span class="tlaGNC">        6278 :     if (gst_tensors_config_is_flexible (&amp;in_config)) {</span></span>
<span id="L2147"><span class="lineNum">    2147</span>              :       /* output caps is also flexible */</span>
<span id="L2148"><span class="lineNum">    2148</span> <span class="tlaGNC">         714 :       out_config.info.format = _NNS_TENSOR_FORMAT_FLEXIBLE;</span></span>
<span id="L2149"><span class="lineNum">    2149</span>              :     } else {</span>
<span id="L2150"><span class="lineNum">    2150</span> <span class="tlaGNC">        9103 :       for (j = 0; j &lt; in_config.info.num_tensors; j++) {</span></span>
<span id="L2151"><span class="lineNum">    2151</span> <span class="tlaGNC">        3539 :         in_info = gst_tensors_info_get_nth_info (&amp;in_config.info, j);</span></span>
<span id="L2152"><span class="lineNum">    2152</span> <span class="tlaGNC">        3539 :         out_info = gst_tensors_info_get_nth_info (&amp;out_config.info, j);</span></span>
<span id="L2153"><span class="lineNum">    2153</span>              : </span>
<span id="L2154"><span class="lineNum">    2154</span> <span class="tlaGNC">        3539 :         gst_tensor_transform_convert_dimension (filter, direction,</span></span>
<span id="L2155"><span class="lineNum">    2155</span>              :             j, in_info, out_info);</span>
<span id="L2156"><span class="lineNum">    2156</span> <span class="tlaGNC">        3539 :         if (out_info-&gt;type == _NNS_END) {</span></span>
<span id="L2157"><span class="lineNum">    2157</span>              :           /* types cannot be specified */</span>
<span id="L2158"><span class="lineNum">    2158</span> <span class="tlaGNC">        1819 :           is_types_not_fixed = TRUE;</span></span>
<span id="L2159"><span class="lineNum">    2159</span>              :         }</span>
<span id="L2160"><span class="lineNum">    2160</span>              :       }</span>
<span id="L2161"><span class="lineNum">    2161</span>              :     }</span>
<span id="L2162"><span class="lineNum">    2162</span>              : </span>
<span id="L2163"><span class="lineNum">    2163</span> <span class="tlaGNC">        6278 :     out_config.rate_d = in_config.rate_d;</span></span>
<span id="L2164"><span class="lineNum">    2164</span> <span class="tlaGNC">        6278 :     out_config.rate_n = in_config.rate_n;</span></span>
<span id="L2165"><span class="lineNum">    2165</span> <span class="tlaGNC">        6278 :     out_config.info.num_tensors = in_config.info.num_tensors;</span></span>
<span id="L2166"><span class="lineNum">    2166</span>              : </span>
<span id="L2167"><span class="lineNum">    2167</span> <span class="tlaGNC">        6278 :     if (gst_structure_has_name (structure, NNS_MIMETYPE_TENSOR)) {</span></span>
<span id="L2168"><span class="lineNum">    2168</span> <span class="tlaGNC">        2957 :       gst_caps_append (result_aux, gst_tensor_caps_from_config (&amp;out_config));</span></span>
<span id="L2169"><span class="lineNum">    2169</span>              :     } else {</span>
<span id="L2170"><span class="lineNum">    2170</span> <span class="tlaGNC">        3321 :       gst_caps_append (result_aux, gst_tensors_caps_from_config (&amp;out_config));</span></span>
<span id="L2171"><span class="lineNum">    2171</span>              : </span>
<span id="L2172"><span class="lineNum">    2172</span>              :       /* remove `types` field from caps */</span>
<span id="L2173"><span class="lineNum">    2173</span> <span class="tlaGNC">        3321 :       if (is_types_not_fixed) {</span></span>
<span id="L2174"><span class="lineNum">    2174</span> <span class="tlaGNC">         154 :         GstStructure *s = gst_caps_get_structure (result_aux, 0);</span></span>
<span id="L2175"><span class="lineNum">    2175</span> <span class="tlaGNC">         154 :         gst_structure_remove_field (s, &quot;types&quot;);</span></span>
<span id="L2176"><span class="lineNum">    2176</span>              :       }</span>
<span id="L2177"><span class="lineNum">    2177</span>              :     }</span>
<span id="L2178"><span class="lineNum">    2178</span>              : </span>
<span id="L2179"><span class="lineNum">    2179</span> <span class="tlaGNC">        6278 :     gst_caps_append (result, result_aux);</span></span>
<span id="L2180"><span class="lineNum">    2180</span>              : </span>
<span id="L2181"><span class="lineNum">    2181</span> <span class="tlaGNC">        6278 :     gst_tensors_config_free (&amp;in_config);</span></span>
<span id="L2182"><span class="lineNum">    2182</span> <span class="tlaGNC">        6278 :     gst_tensors_config_free (&amp;out_config);</span></span>
<span id="L2183"><span class="lineNum">    2183</span>              :   }</span>
<span id="L2184"><span class="lineNum">    2184</span>              : </span>
<span id="L2185"><span class="lineNum">    2185</span> <span class="tlaGNC">        3169 :   if (filtercap &amp;&amp; gst_caps_get_size (filtercap) &gt; 0) {</span></span>
<span id="L2186"><span class="lineNum">    2186</span>              :     GstCaps *intersection;</span>
<span id="L2187"><span class="lineNum">    2187</span>              : </span>
<span id="L2188"><span class="lineNum">    2188</span>              :     intersection =</span>
<span id="L2189"><span class="lineNum">    2189</span> <span class="tlaGNC">         638 :         gst_caps_intersect_full (result, filtercap, GST_CAPS_INTERSECT_FIRST);</span></span>
<span id="L2190"><span class="lineNum">    2190</span>              : </span>
<span id="L2191"><span class="lineNum">    2191</span> <span class="tlaGNC">         638 :     gst_caps_unref (result);</span></span>
<span id="L2192"><span class="lineNum">    2192</span> <span class="tlaGNC">         638 :     result = intersection;</span></span>
<span id="L2193"><span class="lineNum">    2193</span>              :   }</span>
<span id="L2194"><span class="lineNum">    2194</span>              : </span>
<span id="L2195"><span class="lineNum">    2195</span> <span class="tlaGNC">        3169 :   silent_debug_caps (filter, result, &quot;to&quot;);</span></span>
<span id="L2196"><span class="lineNum">    2196</span> <span class="tlaGNC">        3169 :   return result;</span></span>
<span id="L2197"><span class="lineNum">    2197</span>              : }</span>
<span id="L2198"><span class="lineNum">    2198</span>              : </span>
<span id="L2199"><span class="lineNum">    2199</span>              : /**</span>
<span id="L2200"><span class="lineNum">    2200</span>              :  * @brief fixate caps. required vmethod of BaseTransform</span>
<span id="L2201"><span class="lineNum">    2201</span>              :  */</span>
<span id="L2202"><span class="lineNum">    2202</span>              : static GstCaps *</span>
<span id="L2203"><span class="lineNum">    2203</span> <span class="tlaGNC">         242 : gst_tensor_transform_fixate_caps (GstBaseTransform * trans,</span></span>
<span id="L2204"><span class="lineNum">    2204</span>              :     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)</span>
<span id="L2205"><span class="lineNum">    2205</span>              : {</span>
<span id="L2206"><span class="lineNum">    2206</span>              :   GstTensorTransform *filter;</span>
<span id="L2207"><span class="lineNum">    2207</span>              :   GstCaps *result;</span>
<span id="L2208"><span class="lineNum">    2208</span>              : </span>
<span id="L2209"><span class="lineNum">    2209</span> <span class="tlaGNC">         242 :   filter = GST_TENSOR_TRANSFORM_CAST (trans);</span></span>
<span id="L2210"><span class="lineNum">    2210</span>              : </span>
<span id="L2211"><span class="lineNum">    2211</span> <span class="tlaGNC">         242 :   silent_debug (filter, &quot;Calling FixateCaps, direction = %d\n&quot;, direction);</span></span>
<span id="L2212"><span class="lineNum">    2212</span> <span class="tlaGNC">         242 :   silent_debug_caps (filter, caps, &quot;caps&quot;);</span></span>
<span id="L2213"><span class="lineNum">    2213</span> <span class="tlaGNC">         242 :   silent_debug_caps (filter, othercaps, &quot;othercaps&quot;);</span></span>
<span id="L2214"><span class="lineNum">    2214</span>              : </span>
<span id="L2215"><span class="lineNum">    2215</span>              :   result =</span>
<span id="L2216"><span class="lineNum">    2216</span> <span class="tlaGNC">         242 :       gst_tensor_transform_transform_caps (trans, direction, caps, othercaps);</span></span>
<span id="L2217"><span class="lineNum">    2217</span> <span class="tlaGNC">         242 :   gst_caps_unref (othercaps);</span></span>
<span id="L2218"><span class="lineNum">    2218</span>              : </span>
<span id="L2219"><span class="lineNum">    2219</span> <span class="tlaGNC">         242 :   result = gst_caps_make_writable (result);</span></span>
<span id="L2220"><span class="lineNum">    2220</span> <span class="tlaGNC">         242 :   result = gst_caps_fixate (result);</span></span>
<span id="L2221"><span class="lineNum">    2221</span>              : </span>
<span id="L2222"><span class="lineNum">    2222</span> <span class="tlaGNC">         242 :   silent_debug_caps (filter, result, &quot;result&quot;);</span></span>
<span id="L2223"><span class="lineNum">    2223</span> <span class="tlaGNC">         242 :   return result;</span></span>
<span id="L2224"><span class="lineNum">    2224</span>              : }</span>
<span id="L2225"><span class="lineNum">    2225</span>              : </span>
<span id="L2226"><span class="lineNum">    2226</span>              : /**</span>
<span id="L2227"><span class="lineNum">    2227</span>              :  * @brief set caps. required vmethod of BaseTransform</span>
<span id="L2228"><span class="lineNum">    2228</span>              :  */</span>
<span id="L2229"><span class="lineNum">    2229</span>              : static gboolean</span>
<span id="L2230"><span class="lineNum">    2230</span> <span class="tlaGNC">         220 : gst_tensor_transform_set_caps (GstBaseTransform * trans,</span></span>
<span id="L2231"><span class="lineNum">    2231</span>              :     GstCaps * incaps, GstCaps * outcaps)</span>
<span id="L2232"><span class="lineNum">    2232</span>              : {</span>
<span id="L2233"><span class="lineNum">    2233</span>              :   GstTensorTransform *filter;</span>
<span id="L2234"><span class="lineNum">    2234</span>              :   GstTensorsConfig in_config, out_config;</span>
<span id="L2235"><span class="lineNum">    2235</span>              :   GstTensorsConfig config;</span>
<span id="L2236"><span class="lineNum">    2236</span>              :   GstTensorInfo *in_info, *out_info;</span>
<span id="L2237"><span class="lineNum">    2237</span>              :   gboolean in_flexible, out_flexible;</span>
<span id="L2238"><span class="lineNum">    2238</span> <span class="tlaGNC">         220 :   gboolean allowed = FALSE;</span></span>
<span id="L2239"><span class="lineNum">    2239</span>              :   guint i;</span>
<span id="L2240"><span class="lineNum">    2240</span>              : </span>
<span id="L2241"><span class="lineNum">    2241</span> <span class="tlaGNC">         220 :   filter = GST_TENSOR_TRANSFORM_CAST (trans);</span></span>
<span id="L2242"><span class="lineNum">    2242</span>              : </span>
<span id="L2243"><span class="lineNum">    2243</span> <span class="tlaGNC">         220 :   silent_debug (filter, &quot;Calling SetCaps\n&quot;);</span></span>
<span id="L2244"><span class="lineNum">    2244</span> <span class="tlaGNC">         220 :   silent_debug_caps (filter, incaps, &quot;incaps&quot;);</span></span>
<span id="L2245"><span class="lineNum">    2245</span> <span class="tlaGNC">         220 :   silent_debug_caps (filter, outcaps, &quot;outcaps&quot;);</span></span>
<span id="L2246"><span class="lineNum">    2246</span>              : </span>
<span id="L2247"><span class="lineNum">    2247</span> <span class="tlaGNC">         220 :   if (!gst_tensors_config_from_caps (&amp;in_config, incaps, TRUE)) {</span></span>
<span id="L2248"><span class="lineNum">    2248</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ERROR_OBJECT (filter, &quot;Cannot read cap of incaps\n&quot;);</span></span>
<span id="L2249"><span class="lineNum">    2249</span> <span class="tlaUNC">           0 :     goto error;</span></span>
<span id="L2250"><span class="lineNum">    2250</span>              :   }</span>
<span id="L2251"><span class="lineNum">    2251</span>              : </span>
<span id="L2252"><span class="lineNum">    2252</span> <span class="tlaGNC tlaBgGNC">         220 :   if (!gst_tensors_config_from_caps (&amp;out_config, outcaps, TRUE)) {</span></span>
<span id="L2253"><span class="lineNum">    2253</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ERROR_OBJECT (filter, &quot;Cannot read cap of outcaps\n&quot;);</span></span>
<span id="L2254"><span class="lineNum">    2254</span> <span class="tlaUNC">           0 :     goto error;</span></span>
<span id="L2255"><span class="lineNum">    2255</span>              :   }</span>
<span id="L2256"><span class="lineNum">    2256</span>              : </span>
<span id="L2257"><span class="lineNum">    2257</span> <span class="tlaGNC tlaBgGNC">         220 :   in_flexible = gst_tensors_config_is_flexible (&amp;in_config);</span></span>
<span id="L2258"><span class="lineNum">    2258</span> <span class="tlaGNC">         220 :   out_flexible = gst_tensors_config_is_flexible (&amp;out_config);</span></span>
<span id="L2259"><span class="lineNum">    2259</span>              : </span>
<span id="L2260"><span class="lineNum">    2260</span>              :   /* compare type and dimension */</span>
<span id="L2261"><span class="lineNum">    2261</span> <span class="tlaGNC">         220 :   gst_tensors_config_init (&amp;config);</span></span>
<span id="L2262"><span class="lineNum">    2262</span> <span class="tlaGNC">         220 :   config.info.format = out_config.info.format;</span></span>
<span id="L2263"><span class="lineNum">    2263</span>              : </span>
<span id="L2264"><span class="lineNum">    2264</span> <span class="tlaGNC">         220 :   config.rate_n = in_config.rate_n;</span></span>
<span id="L2265"><span class="lineNum">    2265</span> <span class="tlaGNC">         220 :   config.rate_d = in_config.rate_d;</span></span>
<span id="L2266"><span class="lineNum">    2266</span> <span class="tlaGNC">         220 :   config.info.num_tensors = in_config.info.num_tensors;</span></span>
<span id="L2267"><span class="lineNum">    2267</span>              : </span>
<span id="L2268"><span class="lineNum">    2268</span> <span class="tlaGNC">         220 :   if (!in_flexible) {</span></span>
<span id="L2269"><span class="lineNum">    2269</span> <span class="tlaGNC">         438 :     for (i = 0; i &lt; in_config.info.num_tensors; i++) {</span></span>
<span id="L2270"><span class="lineNum">    2270</span> <span class="tlaGNC">         227 :       in_info = gst_tensors_info_get_nth_info (&amp;in_config.info, i);</span></span>
<span id="L2271"><span class="lineNum">    2271</span> <span class="tlaGNC">         227 :       out_info = gst_tensors_info_get_nth_info (&amp;config.info, i);</span></span>
<span id="L2272"><span class="lineNum">    2272</span>              : </span>
<span id="L2273"><span class="lineNum">    2273</span> <span class="tlaGNC">         227 :       if (!gst_tensor_transform_convert_dimension (filter, GST_PAD_SINK,</span></span>
<span id="L2274"><span class="lineNum">    2274</span>              :               i, in_info, out_info)) {</span>
<span id="L2275"><span class="lineNum">    2275</span> <span class="tlaUNC tlaBgUNC">           0 :         GST_ERROR_OBJECT (filter,</span></span>
<span id="L2276"><span class="lineNum">    2276</span>              :             &quot;Tensor info is not matched with given properties.&quot;);</span>
<span id="L2277"><span class="lineNum">    2277</span> <span class="tlaUNC">           0 :         goto error;</span></span>
<span id="L2278"><span class="lineNum">    2278</span>              :       }</span>
<span id="L2279"><span class="lineNum">    2279</span>              :     }</span>
<span id="L2280"><span class="lineNum">    2280</span>              :   }</span>
<span id="L2281"><span class="lineNum">    2281</span>              : </span>
<span id="L2282"><span class="lineNum">    2282</span> <span class="tlaGNC tlaBgGNC">         220 :   if (out_flexible) {</span></span>
<span id="L2283"><span class="lineNum">    2283</span> <span class="tlaGNC">           9 :     GST_INFO_OBJECT (filter, &quot;Output tensor is flexible.&quot;);</span></span>
<span id="L2284"><span class="lineNum">    2284</span>              : </span>
<span id="L2285"><span class="lineNum">    2285</span>              :     /* set output configuration if input is static */</span>
<span id="L2286"><span class="lineNum">    2286</span> <span class="tlaGNC">           9 :     if (!in_flexible)</span></span>
<span id="L2287"><span class="lineNum">    2287</span> <span class="tlaUNC tlaBgUNC">           0 :       out_config = config;</span></span>
<span id="L2288"><span class="lineNum">    2288</span> <span class="tlaGNC tlaBgGNC">         211 :   } else if (!gst_tensors_config_is_equal (&amp;out_config, &amp;config)) {</span></span>
<span id="L2289"><span class="lineNum">    2289</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ERROR_OBJECT (filter,</span></span>
<span id="L2290"><span class="lineNum">    2290</span>              :         &quot;Tensor info is not matched with given properties.\n&quot;);</span>
<span id="L2291"><span class="lineNum">    2291</span> <span class="tlaUNC">           0 :     goto error;</span></span>
<span id="L2292"><span class="lineNum">    2292</span>              :   }</span>
<span id="L2293"><span class="lineNum">    2293</span>              : </span>
<span id="L2294"><span class="lineNum">    2294</span>              :   /* set in/out tensor info */</span>
<span id="L2295"><span class="lineNum">    2295</span> <span class="tlaGNC tlaBgGNC">         220 :   filter-&gt;in_config = in_config;</span></span>
<span id="L2296"><span class="lineNum">    2296</span> <span class="tlaGNC">         220 :   filter-&gt;out_config = out_config;</span></span>
<span id="L2297"><span class="lineNum">    2297</span> <span class="tlaGNC">         220 :   allowed = TRUE;</span></span>
<span id="L2298"><span class="lineNum">    2298</span>              : </span>
<span id="L2299"><span class="lineNum">    2299</span> <span class="tlaGNC">         220 : error:</span></span>
<span id="L2300"><span class="lineNum">    2300</span> <span class="tlaGNC">         220 :   if (!allowed)</span></span>
<span id="L2301"><span class="lineNum">    2301</span> <span class="tlaUNC tlaBgUNC">           0 :     GST_ERROR_OBJECT (filter, &quot;Set Caps Failed!\n&quot;);</span></span>
<span id="L2302"><span class="lineNum">    2302</span>              : </span>
<span id="L2303"><span class="lineNum">    2303</span> <span class="tlaGNC tlaBgGNC">         220 :   return allowed;</span></span>
<span id="L2304"><span class="lineNum">    2304</span>              : }</span>
<span id="L2305"><span class="lineNum">    2305</span>              : </span>
<span id="L2306"><span class="lineNum">    2306</span>              : /**</span>
<span id="L2307"><span class="lineNum">    2307</span>              :  * @brief Tell the framework the required size of buffer based on the info of the other side pad. Note that this is always the same with the input. optional vmethod of BaseTransform</span>
<span id="L2308"><span class="lineNum">    2308</span>              :  */</span>
<span id="L2309"><span class="lineNum">    2309</span>              : static gboolean</span>
<span id="L2310"><span class="lineNum">    2310</span> <span class="tlaGNC">       22155 : gst_tensor_transform_transform_size (GstBaseTransform * trans,</span></span>
<span id="L2311"><span class="lineNum">    2311</span>              :     GstPadDirection direction, GstCaps * caps, gsize size, GstCaps * othercaps,</span>
<span id="L2312"><span class="lineNum">    2312</span>              :     gsize * othersize)</span>
<span id="L2313"><span class="lineNum">    2313</span>              : {</span>
<span id="L2314"><span class="lineNum">    2314</span>              :   UNUSED (trans);</span>
<span id="L2315"><span class="lineNum">    2315</span>              :   UNUSED (direction);</span>
<span id="L2316"><span class="lineNum">    2316</span>              :   UNUSED (caps);</span>
<span id="L2317"><span class="lineNum">    2317</span>              :   UNUSED (size);</span>
<span id="L2318"><span class="lineNum">    2318</span>              :   UNUSED (othercaps);</span>
<span id="L2319"><span class="lineNum">    2319</span>              :   /**</span>
<span id="L2320"><span class="lineNum">    2320</span>              :    * Consider multi-tensors.</span>
<span id="L2321"><span class="lineNum">    2321</span>              :    * Set each memory block in transform()</span>
<span id="L2322"><span class="lineNum">    2322</span>              :    */</span>
<span id="L2323"><span class="lineNum">    2323</span> <span class="tlaGNC">       22155 :   *othersize = 0;</span></span>
<span id="L2324"><span class="lineNum">    2324</span>              : </span>
<span id="L2325"><span class="lineNum">    2325</span> <span class="tlaGNC">       22155 :   return TRUE;</span></span>
<span id="L2326"><span class="lineNum">    2326</span>              : }</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>

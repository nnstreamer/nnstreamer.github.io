<!DOCTYPE html>
<html lang="en">
<head>

<base href=".">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>NNStreamer C-API</title>

<link rel="stylesheet" href="assets/css/dark-frontend.css" type="text/css" title="dark">
<link rel="alternate stylesheet" href="assets/css/light-frontend.css" type="text/css" title="light">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">
<link rel="stylesheet" href="assets/js/search/enable_search.css" type="text/css">

<link rel="stylesheet" href="assets/css/extra_frontend.css" type="text/css">

<link rel="stylesheet" href="assets/css/prism-tomorrow.css" type="text/css" title="dark">

<link rel="alternate stylesheet" href="assets/css/prism.css" type="text/css" title="light">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>
<script src="assets/js/styleswitcher.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/nnstreamer_logo.png">

</head>

<body class="no-script
">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<span title="light mode switch" class="glyphicon glyphicon-sunglasses pull-right" id="lightmode-icon"></span>
			<form class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/nnstreamer_logo.png" alt="Home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
    <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        API References<span class="caret"></span>
    </a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="doc-index.html">NNStreamer doc</a>
			</li>
					<li>
				<a href="gst/nnstreamer/README.html">NNStreamer Elements</a>
			</li>
					<li>
				<a href="nnstreamer-example/index.html">NNStreamer Examples</a>
			</li>
					<li>
				<a href="API-reference.html">API reference</a>
			</li>
		</ul>
</li>

<li>
	<a href="doc-index.html">Documents</a>
</li>
<li>
	<a href="gst/nnstreamer/README.html">Elements</a>
</li>
<li>
	<a href="tutorials.html">Tutorials</a>
</li>
<li>
	<a href="API-reference.html">API reference</a>
</li>

			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
							</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="NNStreamer" data-hotdoc-ref="nnstreamer_capi.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/full-width.js"></script>
  <div id="sitenav-wrapper">
    <iframe src="hotdoc-sitemap.html" id="sitenav-frame"></iframe>
  </div>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-role="main">
        <p>** NOTICE: ML-API implementation is migrated to <a href="https://github.com/nnstreamer/api">api.git</a>.**</p>
<h1 id="machine-learning-inference">Machine Learning Inference</h1>
<p>You can easily create and efficiently execute data stream pipelines that consist of neural networks as filters in pipelines.</p>
<p>The main features of the Machine Learning Inference API include:</p>
<ul>
<li>
<p>Construction of data pipeline based on <a href="https://gstreamer.freedesktop.org/">GStreamer</a></p>
<p>You can compose the data stream pipeline through Machine Learning Inference with various elements of GStreamer and NNStreamer.</p>
</li>
<li>
<p><a href="nnstreamer_capi.html#single-api">Single</a> API and <a href="nnstreamer_capi.html#pipeline-api">Pipeline</a> API</p>
<p>There are two types of Machine Learning Inference API - Single API and Pipeline API.</p>
<p>Single API is useful for a simple usage scenario of neural network models. It allows invoking a neural network model with a single instance of input data for the model directly. It is useful if you have the input data pre-processed with the application itself and there are no complex interactions between neural network models, data processors, or data stream paths.</p>
<p>Pipeline API allows developers to construct and execute pipelines with multiple neural network models, multiple inputs and output nodes, multiple data processors, pre-and-post processors, and various data path manipulators. Besides, if the input is online data or streamed data, Pipeline API simplifies your application and improves its performance.</p>
</li>
<li>
<p>Support various neural network frameworks (NNFW)</p>
<p>TensorFlow, TensorFlow-Lite, Caffe2, and PyTorch are the supported neural network frameworks. Neural network model files trained by such frameworks can be imported as filters of pipelines directly.
Custom filters, which are neural network models implemented directly with programming languages including C/C++ and Python, maybe imported as filters of pipelines directly as well.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>The devices powered by Tizen OS can contain TensorFlow-Lite only. Ensure that the neural network frameworks that you want to use are installed.</p>
</blockquote>
</li>
</ul>
<h2 id="prerequisites">Prerequisites</h2>
<p>To enable your application to use the machine learning functionality:</p>
<ol>
<li>
<p>To use the functions and data types of the Machine Learning Inference API, include the <code>&lt;nnstreamer.h&gt;</code> header file in your application:</p>
<pre><code class="language-c">#include &lt;nnstreamer.h&gt;
</code></pre>
</li>
<li>
<p>To use the Machine Learning Inference API, include the following features in your <code>tizen-manifest.xml</code> file:</p>
<pre><code class="language-xml">&lt;feature name="http://tizen.org/feature/machine_learning"&gt;true&lt;/feature&gt;
&lt;feature name="http://tizen.org/feature/machine_learning.inference"&gt;true&lt;/feature&gt;
</code></pre>
</li>
</ol>
<h2 id="single-api">Single API</h2>
<p>This section shows how to load a model without the construction of pipelines.</p>
<ol>
<li>
<p>Open a model file:</p>
<pre><code class="language-c">#include &lt;nnstreamer-single.h&gt;

ml_single_h single;
ml_tensors_info_h in_info, out_info;

...

ml_single_open (&amp;single, "model_file_path", in_info, out_info, ML_NNFW_TYPE_TENSORFLOW_LITE, ML_NNFW_HW_ANY);
</code></pre>
<p>To load a model file, two <code>ml_tensors_info_h</code> are required. <code>in_info</code> contains the information of the input tensors, and <code>out_info</code> contains the information of the output tensors. For more information, see <a href="nnstreamer_capi.html#tensors-information">Tensors Information</a>.</p>
</li>
<li>
<p>Get the <a href="nnstreamer_capi.html#tensors-information">Tensors Information</a>.</p>
<p>After opening the model, use the following functions to bring the information of the input and output tensors:</p>
<pre><code class="language-c">ml_single_get_input_info (single, &amp;in_info);
ml_single_get_output_info (single, &amp;out_info);
</code></pre>
</li>
<li>
<p>Invoke the model with input and output <a href="nnstreamer_capi.html#tensors-data">Tensors Data</a>.</p>
<p>The model can be invoked with input and output tensors data. The result is included in the output tensors data:</p>
<pre><code class="language-c">ml_tensors_data_create (in_info, &amp;input);
ml_single_invoke (single, input, &amp;output);
</code></pre>
</li>
<li>
<p>Close the opened handle:</p>
<pre><code class="language-c">ml_single_close (single);
</code></pre>
</li>
</ol>
<h2 id="pipeline-api">Pipeline API</h2>
<p>This section shows how to create a pipeline.</p>
<h3 id="basic-usage">Basic Usage</h3>
<ol>
<li>
<p>Construct a pipeline with the GStreamer elements.</p>
<p>Different pipelines can be constructed using various GStreamer elements:</p>
<pre><code class="language-c">char pipeline[] = "videotestsrc num_buffers=2 ! videoconvert ! videoscale ! video/x-raw,format=RGBx,width=224,height=224 ! tensor_converter ! fakesink";
ml_pipeline_h handle;
int status = ml_pipeline_construct (pipeline, NULL, NULL, &amp;handle);
</code></pre>
</li>
<li>
<p>Start the pipeline and get state:</p>
<pre><code class="language-c">/* The pipeline could be started when the state is paused */
status = ml_pipeline_start (handle);
status = ml_pipeline_get_state (handle, &amp;state);
</code></pre>
</li>
<li>
<p>Stop the pipeline and get state:</p>
<pre><code class="language-c">status = ml_pipeline_stop (handle);
status = ml_pipeline_get_state (handle, &amp;state);
</code></pre>
</li>
<li>
<p>Destroy the pipeline.</p>
<p>When no longer needed, destroy the pipeline:</p>
<pre><code class="language-c">status = ml_pipeline_destroy (handle);
</code></pre>
</li>
</ol>
<h3 id="element-api">Element API</h3>
<p>You need to manipulate the input and the output data to run neural network models with Machine Learning Inference API. In addition, you can construct pipelines that can be controlled.</p>
<p>Followings are the available elements:</p>
<ul>
<li>
<p><strong>Source</strong></p>
<p>The configuration of the data source element is required to set the input tensor data:</p>
<pre><code class="language-c">char pipeline[] = "appsrc name=srcx ! other/tensor,dimension=(string)4:1:1:1,type=(string)uint8,framerate=(fraction)0/1 ! tensor_sink";
</code></pre>
<p><code>ml_pipeline_src_get_handle()</code> controls the <code>appsrc</code> element with the name <code>srcx</code>:</p>
<pre><code class="language-c">ml_pipeline_h handle;
ml_pipeline_src_h srchandle;

status = ml_pipeline_construct (pipeline, NULL, NULL, &amp;handle);
status = ml_pipeline_start (handle);
status = ml_pipeline_src_get_handle (handle, "srcx", &amp;srchandle);
</code></pre>
<p>You can check the information of input tensors using <code>srchandle</code>:</p>
<pre><code class="language-c">ml_tensors_info_h info;

status = ml_pipeline_src_get_tensors_info (srchandle, &amp;info);
</code></pre>
<p>The input tensor data can be filled according to the <code>info</code>:</p>
<pre><code class="language-c">ml_tensors_data_h data;

status = ml_tensors_data_create (info, &amp;data);

for (i = 0; i &lt; 10; i++) {
  uintarray1[i] = (uint8_t *) malloc (4);
  uintarray1[i][0] = i + 4;
  uintarray1[i][1] = i + 1;
  uintarray1[i][2] = i + 3;
  uintarray1[i][3] = i + 2;
}

status = ml_tensors_data_set_tensor_data (data, 0, uintarray1[0], 4);

/* Setting the policy of raw data pointer */
status = ml_pipeline_src_input_data (srchandle, data, ML_PIPELINE_BUF_POLICY_DO_NOT_FREE);
</code></pre>
<p>After using the data source element, release the handle:</p>
<pre><code class="language-c">status = ml_pipeline_src_release_handle (srchandle);
</code></pre>
</li>
<li>
<p><strong>Sink</strong></p>
<p>The configuration of the data sink element is required to get the output tensor data:</p>
<pre><code class="language-c">char pipeline[] = "videotestsrc num-buffers=3 ! videoconvert ! tensor_converter ! appsink name=sinkx sync=false";
</code></pre>
<p><code>appsink</code> element with the name <code>sinkx</code> becomes reachable through <code>ml_pipeline_sink_register()</code>:</p>
<pre><code class="language-c">int status;
ml_pipeline_h handle;
ml_pipeline_sink_h sinkhandle;

status = ml_pipeline_sink_register (handle, "sinkx", sink_callback, user_data, &amp;sinkhandle);
</code></pre>
<p>You can get the data from <code>sink_callback()</code>, whenever <code>appsink</code> named <code>sinkx</code> receives data:</p>
<pre><code class="language-c">typedef void (*ml_pipeline_sink_cb) (const ml_tensors_data_h data, const ml_tensors_info_h info, void *user_data);
</code></pre>
<p>Release the <code>sinkhandle</code> through <code>ml_pipeline_sink_unregister()</code>:</p>
<pre><code class="language-c">status = ml_pipeline_sink_unregister (sinkhandle);
</code></pre>
</li>
<li>
<p><strong>Valve</strong></p>
<p>This element is used to control the stream of a pipeline:</p>
<pre><code class="language-c">char pipeline[] = "videotestsrc is-live=true ! videoconvert ! videoscale ! video/x-raw,format=RGBx,width=16,height=16,framerate=10/1 ! tensor_converter ! valve name=valve1 ! fakesink";
int status = ml_pipeline_construct (pipeline, NULL, NULL, &amp;handle);
</code></pre>
<p>By default, valve named <code>valve1</code> of the pipeline is opened. You can control the valve using <code>ml_pipeline_valve_h</code>:</p>
<pre><code class="language-c">ml_pipeline_h handle;
ml_pipeline_valve_h valve1;

status = ml_pipeline_valve_get_handle (handle, "valve1", &amp;valve1);
</code></pre>
<p>After you start a pipeline, you can control the stream of the pipeline with a valve:</p>
<pre><code class="language-c">status = ml_pipeline_start (handle);

status = ml_pipeline_valve_set_open (valve1, false); /* Close */
</code></pre>
<p>You can also open the pipeline by controlling the stream of a pipeline with a valve:</p>
<pre><code class="language-c">status = ml_pipeline_valve_set_open (valve1, true); /* Open */
</code></pre>
<p>Before you destroy the pipeline, release <code>ml_pipeline_valve_h</code>:</p>
<pre><code class="language-c">status = ml_pipeline_valve_release_handle (valve1); /* Release valve handle */
</code></pre>
</li>
<li>
<p><strong>Switch</strong></p>
<p>The switch element is used when you need only one working branch from a pipeline that has multiple branches:</p>
<p><img src="Documentation/media/input-selector.png" alt="input-selector" id="inputselector"></p>
<pre><code class="language-c">char pipeline[] = "input-selector name=ins ! tensor_converter ! tensor_sink name=sinkx videotestsrc is-live=true ! videoconvert ! ins.sink_0 videotestsrc num-buffers=3 is-live=true ! videoconvert ! ins.sink_1";
</code></pre>
<p>Get <code>ml_pipeline_switch_h</code>. The name of the switch in this pipeline is <code>ins</code>:</p>
<pre><code class="language-c">ml_pipeline_h handle;
ml_pipeline_switch_h switchhandle;
ml_pipeline_switch_e type;

status = ml_pipeline_construct (pipeline, NULL, NULL, &amp;handle);
status = ml_pipeline_switch_get_handle (handle, "ins", &amp;type, &amp;switchhandle);
</code></pre>
<p>You can control the switch using the handle <code>ml_pipeline_switch_h</code>:</p>
<pre><code class="language-c">status = ml_pipeline_switch_select (switchhandle, "sink_1");
</code></pre>
<p>Before you destroy the pipeline, release <code>ml_pipeline_switch_h</code>:</p>
<pre><code class="language-c">status = ml_pipeline_switch_release_handle (switchhandle);
</code></pre>
<p>The following image shows the switch at the end of the pipeline:</p>
<p><img src="Documentation/media/output-selector.png" alt="output-selector" id="outputselector"></p>
<pre><code class="language-c">char pipeline[] = "videotestsrc is-live=true ! videoconvert ! tensor_converter ! output-selector name=outs outs.src_0 ! tensor_sink name=sink0 async=false outs.src_1 ! tensor_sink name=sink1 async=false"
</code></pre>
</li>
</ul>
<h3 id="pipeline-states">Pipeline States</h3>
<p>For more information about the pipeline states, see <a href="https://gstreamer.freedesktop.org/documentation/plugin-development/basics/states.html">GStreamer guide</a>.</p>
<h2 id="tensors-information">Tensors Information</h2>
<p><code>ml_tensors_info_h</code> contains the information of tensors. The tensor info can be managed using the following functions:</p>
<ul>
<li>
<p><strong>Create and destroy</strong></p>
<pre><code class="language-c">ml_tensors_info_h info;
status = ml_tensors_info_create (&amp;info);
status = ml_tensors_info_destroy (info);
</code></pre>
</li>
<li>
<p><strong>Set functions</strong></p>
<pre><code class="language-c">/* Set how many tensors exist */
status = ml_tensors_info_set_count (info, 1);

/* Set the type of the tensor_0 as UINT8 */
status = ml_tensors_info_set_tensor_type (info, 0, ML_TENSOR_TYPE_UINT8);

/* Set the dimension of the tensor_0 as in_dim */
status = ml_tensors_info_set_tensor_dimension (info, 0, in_dim);

/* Set the name of the tensor_0 as "tensor-name-test" */
status = ml_tensors_info_set_tensor_name (info, 0, "tensor-name-test");
</code></pre>
</li>
<li>
<p><strong>Get functions</strong></p>
<pre><code class="language-c">/* Get how many tensors exist */
status = ml_tensors_info_get_count (info, &amp;num);

/* Get the type of the tensor_0 */
status = ml_tensors_info_get_tensor_type (info, 0, &amp;out_type);

/* Get the dimension of the tensor_0 */
status = ml_tensors_info_get_tensor_dimension (info, 0, in_dim);

/* Get the name of the tensor_0 */
status = ml_tensors_info_get_tensor_name (info, 0, &amp;out_name);

/* Get the size of the tensor_0 */
status = ml_tensors_info_get_tensor_size (info, 0, &amp;data_size);
</code></pre>
</li>
</ul>
<h2 id="tensors-data">Tensors Data</h2>
<p><code>ml_tensors_data_h</code> contains the raw data of tensors. The tensor data can be managed using the following functions:</p>
<ul>
<li>
<p><strong>Create and destroy</strong></p>
<pre><code class="language-c">ml_tensors_data_h data;
ml_tensors_info_h info;

status = ml_tensors_data_create (info, &amp;data);
status = ml_tensors_data_destroy (data);
</code></pre>
</li>
<li>
<p><strong>Get and set tensor data</strong></p>
<pre><code class="language-c">/* Get tensor data */
void *data_ptr;
size_t data_size;
status = ml_tensors_data_get_tensor_data (data, 0, &amp;data_ptr, &amp;data_size);

/* Set tensor data */
uint8_t dummy[4] = {1, 1, 1, 1};
status = ml_tensors_data_set_tensor_data (data, 0, dummy, 1);
</code></pre>
</li>
</ul>
<h2 id="related-information">Related Information</h2>
<ul>
<li>Dependencies
<ul>
<li>Tizen 5.5 and Higher for Mobile</li>
<li>Tizen 5.5 and Higher for Wearable</li>
</ul>
</li>
</ul>

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    

	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>


<script src="assets/js/navbar_offset_scroller.js"></script>
</body>
</html>

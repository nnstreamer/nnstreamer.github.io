fragment_downloaded_cb({"url":"gst/nnstreamer/tensor_converter/README.html#supported-features","fragment":"Supported features\nOctet stream to static tensor: You should set input-type and input-dim to describe tensor(s) information of outgoing buffer.\nIf setting multiple tensors, converter will divide incoming buffer and set multiple memory chunks in outgoing buffer.\ne.g, converting 10 bytes of octet stream to 2 static tensors:\n... ! application/octet-stream ! tensor_converter input-dim=2:1:1:1,2:1:1:1 input-type=int32,int8 ! ...\nOctet stream to flexible tensor: With a caps filter (other/tensors,format=flexible), tensor-converter generates flexible tensor.\nIn this case, you don't need to denote input-type and input-dim in pipeline description.\nConverter sets the dimension with buffer size (size:1:1:1) and type uint8, and appends this information (tensor-meta) in the memory of outgoing buffer.\ne.g, converting octet stream to flexible tensor:\n... ! application/octet-stream ! tensor_converter ! other/tensors,format=flexible ! ...\nMedia to octet stream: If you need to convert media to octet stream, use capssetter.\nThis element can update the caps of incoming buffer using it's properties. After updating the mimetye of media stream, it can be converted to tensor stream with tensor_converter.\ne.g., converting jpeg to flexible tensor:\n... ! jpegenc ! capssetter caps=\"application/octet-stream\" replace=true join=false ! tensor_converter ! other/tensors,format=flexible ! ...\nOnly single frame. frames-per-tensor should be 1 (default value).\n\nVideo: direct conversion of video/x-raw / non-interlace(progressive) to [height][width][#Colorspace] tensor. (#Colorspace:width:height:frames-per-tensor)\n\nSupported colorspaces: RGB (3), BGRx (4), Gray8 (1)\nYou may express frames-per-tensor to have multiple image frames in a tensor like audio and text as well.\nIf frames-per-tensor is not configured, the default value is 1.\nGolden tests for such input\n\n\nAudio: direct conversion of audio/x-raw with arbitrary numbers of channels and frames per tensor to [frames-per-tensor][channels] tensor. (channels:frames-per-tensor)\n\nThe number of frames per tensor is supposed to be configured manually by stream pipeline developer with the property of frames-per-tensor.\nIf frames-per-tensor is not configured, the default value is 1.\n\n\nText: direct conversion of text/x-raw with UTF-8 to [frames-per-tensor][input-dim] tensor. (input-dim:frames-per-tensor)\n\nThe number of frames per tensor is supposed to be configured manually by stream pipeline developer with the property of frames-per-tensor.\nIf frames-per-tensor is not configured, the default value is 1.\nThe size of a text frame should be configured by developer with the property input-dim. Because the dimension of tensor is the key metadata of a tensor stream pipeline, we need to fix the value before actually looking at the actual stream data.\n\n\nOctet stream: direct conversion of application/octet-stream.\n\n\nOctet stream to static tensor: You should set input-type and input-dim to describe tensor(s) information of outgoing buffer.\nIf setting multiple tensors, converter will divide incoming buffer and set multiple memory chunks in outgoing buffer.\ne.g, converting 10 bytes of octet stream to 2 static tensors:\n... ! application/octet-stream ! tensor_converter input-dim=2:1:1:1,2:1:1:1 input-type=int32,int8 ! ...\n\n\nOctet stream to flexible tensor: With a caps filter (other/tensors,format=flexible), tensor-converter generates flexible tensor.\nIn this case, you don't need to denote input-type and input-dim in pipeline description.\nConverter sets the dimension with buffer size (size:1:1:1) and type uint8, and appends this information (tensor-meta) in the memory of outgoing buffer.\ne.g, converting octet stream to flexible tensor:\n... ! application/octet-stream ! tensor_converter ! other/tensors,format=flexible ! ...\n\n\nMedia to octet stream: If you need to convert media to octet stream, use capssetter.\nThis element can update the caps of incoming buffer using it's properties. After updating the mimetye of media stream, it can be converted to tensor stream with tensor_converter.\ne.g., converting jpeg to flexible tensor:\n... ! jpegenc ! capssetter caps=\"application/octet-stream\" replace=true join=false ! tensor_converter ! other/tensors,format=flexible ! ...\n\n\nOnly single frame. frames-per-tensor should be 1 (default value).\n\n\n\nFlexible tensor: conversion to static tensor stream.\n\nYou can convert mime type (flexible to static) if incoming tensor has fixed data format and size.\nWith input-type and input-dim, converter will set the output capability on src pad.\n\n\nSerialized data: conversion to static tensor stream.\n\nSupported serialization format: Protocol Buffers, Flatbuffers and Flexbuffers.\nThe converter gets input capability from the peer pad of the sink pad, or you can specify the capability.\nYou don't need to specify the option because the sub-plugin is registered using the capability.\n\n\n\n\nSupported colorspaces: RGB (3), BGRx (4), Gray8 (1)\nYou may express frames-per-tensor to have multiple image frames in a tensor like audio and text as well.\nIf frames-per-tensor is not configured, the default value is 1.\nGolden tests for such input\n\n\nThe number of frames per tensor is supposed to be configured manually by stream pipeline developer with the property of frames-per-tensor.\nIf frames-per-tensor is not configured, the default value is 1.\n\n\nThe number of frames per tensor is supposed to be configured manually by stream pipeline developer with the property of frames-per-tensor.\nIf frames-per-tensor is not configured, the default value is 1.\nThe size of a text frame should be configured by developer with the property input-dim. Because the dimension of tensor is the key metadata of a tensor stream pipeline, we need to fix the value before actually looking at the actual stream data.\n\n\n\nOctet stream to static tensor: You should set input-type and input-dim to describe tensor(s) information of outgoing buffer.\nIf setting multiple tensors, converter will divide incoming buffer and set multiple memory chunks in outgoing buffer.\ne.g, converting 10 bytes of octet stream to 2 static tensors:\n... ! application/octet-stream ! tensor_converter input-dim=2:1:1:1,2:1:1:1 input-type=int32,int8 ! ...\n\n\nOctet stream to flexible tensor: With a caps filter (other/tensors,format=flexible), tensor-converter generates flexible tensor.\nIn this case, you don't need to denote input-type and input-dim in pipeline description.\nConverter sets the dimension with buffer size (size:1:1:1) and type uint8, and appends this information (tensor-meta) in the memory of outgoing buffer.\ne.g, converting octet stream to flexible tensor:\n... ! application/octet-stream ! tensor_converter ! other/tensors,format=flexible ! ...\n\n\nMedia to octet stream: If you need to convert media to octet stream, use capssetter.\nThis element can update the caps of incoming buffer using it's properties. After updating the mimetye of media stream, it can be converted to tensor stream with tensor_converter.\ne.g., converting jpeg to flexible tensor:\n... ! jpegenc ! capssetter caps=\"application/octet-stream\" replace=true join=false ! tensor_converter ! other/tensors,format=flexible ! ...\n\n\nOnly single frame. frames-per-tensor should be 1 (default value).\n\n\n\nYou can convert mime type (flexible to static) if incoming tensor has fixed data format and size.\nWith input-type and input-dim, converter will set the output capability on src pad.\n\n\nSupported serialization format: Protocol Buffers, Flatbuffers and Flexbuffers.\nThe converter gets input capability from the peer pad of the sink pad, or you can specify the capability.\nYou don't need to specify the option because the sub-plugin is registered using the capability.\n\n"});
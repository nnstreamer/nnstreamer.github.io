fragment_downloaded_cb({"url":"gst/nnstreamer/tensor_if/README.html#page-description","fragment":"GstTensorIF controls its src-pad based on the values (other/tensor(s)) of its sink-pad.\nFor example, you may skip frames if there is no object detected with high confidence.\nThe input/output stream data type is either other/tensor or other/tensors.\ncompared_value: Compared Value (CV), operand 1 (from input tensor(s))\ncompared_value_option: An element of the nth tensor\nsupplied_values: Supplied Value (SV), operand 2 (from the properties)\nsupplied_values_option: Supplied Value Option\noperator: Comparison Operator\nthen: Action if it is TRUE\nthen_option: Option for TRUE Action\nelse: Action if it is FALSE\nelse_option: Option for FALSE Action\nThe format of statement with tensor-if is:\nIf (Compared_Value OPERATOR Supplied_Value(s))) then THEN else ELSE\nIf the given if-condition is simple enough (e.g., if a specific element is between a given range in a tensor frame), it can be expressed as:\nHowever, if the if-condition is complex and cannot be expressed with tensor-if expressions, you may create a corresponding custom filter with tensor-filter, whose output is other/tensors with an additional tensor that is \"1:1:1:1, uint8\", which is 1 (true) or 0 (false) as the first tensor of other/tensors and the input tensor/tensors.\nThen, you can create a pipeline as follows:\n\n\ncompared_value: Compared Value (CV), operand 1 (from input tensor(s))\n\nA_VALUE:  Decide based on a single scalar value\nTENSOR_TOTAL_VALUE: Decide based on a total (sum) value of a specific tensor\nALL_TENSORS_TOTAL_VALUE:  Decide based on a total (sum) value of tensors or a specific tensor\nTENSOR_AVERAGE_VALUE: Decide based on a average value of a specific tensor\nALL_TENSORS_AVERAGE_VALUE: Decide based on a average value of tensors or a specific tensor\n\n\n\ncompared_value_option: An element of the nth tensor\n\n[C][W][H][B],n (e.g., [0][0][0][0],0 means [0][0][0][0] value of first tensor)\nnth tensor,nth tensor,...\n\n\n\nsupplied_values: Supplied Value (SV), operand 2 (from the properties)\n\nSV\nSV1,SV2 (for RANGE operators)\n\n\n\nsupplied_values_option: Supplied Value Option\n\ntype of the supplied value (e.g., type:uint8)\n\n\n\noperator: Comparison Operator\n\nEQ: Check if CV == SV\nNEQ: Check if CV != SV\nGT: Check if CV > SV\nGE: Check if CV >= SV\nLT: Check if CV < SV\nLE: Check if CV <= SV\nRANGE_INCLUSIVE: Check if SV1 <= CV and CV <= SV2\nRANGE_EXCLUSIVE: Check if SV1 < CV and CV < SV2\nNOT_IN_RANGE_INCLUSIVE: Check if CV < SV1 or SV2 < CV\nNOT_IN_RANGE_EXCLUSIVE: Check if CV <= SV1 or SV2 <= CV\n\n\n\nthen: Action if it is TRUE\n\nPASSTHROUGH: The element will not make changes to the buffers, buffers are pushed straight through.\nSKIP: Do not generate output frame (frame skip)\nFILL_ZERO: Fill output frame with zeros\nFILL_VALUES: Fill output frame with a user given value\nFILL_WITH_FILE: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smaller, the reset is filled with 0\nFILL_WITH_FILE_RPT: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smally, the file is repeatedly used\nREPEAT_PREVIOUS_FRAME: Resend the previous output frame. If this is the first, send ZERO values.\nTENSORPICK: Choose nth tensor (or tensors) among tensors\n\n\n\n\nA_VALUE:  Decide based on a single scalar value\nTENSOR_TOTAL_VALUE: Decide based on a total (sum) value of a specific tensor\nALL_TENSORS_TOTAL_VALUE:  Decide based on a total (sum) value of tensors or a specific tensor\nTENSOR_AVERAGE_VALUE: Decide based on a average value of a specific tensor\nALL_TENSORS_AVERAGE_VALUE: Decide based on a average value of tensors or a specific tensor\n\n\n[C][W][H][B],n (e.g., [0][0][0][0],0 means [0][0][0][0] value of first tensor)\nnth tensor,nth tensor,...\n\n\nSV\nSV1,SV2 (for RANGE operators)\n\n\ntype of the supplied value (e.g., type:uint8)\n\n\nEQ: Check if CV == SV\nNEQ: Check if CV != SV\nGT: Check if CV > SV\nGE: Check if CV >= SV\nLT: Check if CV < SV\nLE: Check if CV <= SV\nRANGE_INCLUSIVE: Check if SV1 <= CV and CV <= SV2\nRANGE_EXCLUSIVE: Check if SV1 < CV and CV < SV2\nNOT_IN_RANGE_INCLUSIVE: Check if CV < SV1 or SV2 < CV\nNOT_IN_RANGE_EXCLUSIVE: Check if CV <= SV1 or SV2 <= CV\n\n\nPASSTHROUGH: The element will not make changes to the buffers, buffers are pushed straight through.\nSKIP: Do not generate output frame (frame skip)\nFILL_ZERO: Fill output frame with zeros\nFILL_VALUES: Fill output frame with a user given value\nFILL_WITH_FILE: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smaller, the reset is filled with 0\nFILL_WITH_FILE_RPT: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smally, the file is repeatedly used\nREPEAT_PREVIOUS_FRAME: Resend the previous output frame. If this is the first, send ZERO values.\nTENSORPICK: Choose nth tensor (or tensors) among tensors\n\n\n\nthen_option: Option for TRUE Action\n\nnth tensor, nth tensor, ... (for TENSORPICK option)\n${path_to_file}\n\n\n\nelse: Action if it is FALSE\n\nPASSTHROUGH: The element will not make changes to the buffers, buffers are pushed straight through.\nSKIP: Do not generate output frame (frame skip)\nFILL_ZERO: Fill output frame with zeros\nFILL_VALUES: Fill output frame with a user given value\nFILL_WITH_FILE: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smaller, the reset is filled with 0\nFILL_WITH_FILE_RPT: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smally, the file is repeatedly used\nREPEAT_PREVIOUS_FRAME: Resend the previous output frame. If this is the first, send ZERO values.\nTENSORPICK: Choose nth tensor (or tensors) among tensors\n\n\n\nelse_option: Option for FALSE Action\n\nnth tensor,nth tensor,... (for TENSORPICK option)\n${path_to_file}\n\n\n\n\nnth tensor, nth tensor, ... (for TENSORPICK option)\n${path_to_file}\n\n\nPASSTHROUGH: The element will not make changes to the buffers, buffers are pushed straight through.\nSKIP: Do not generate output frame (frame skip)\nFILL_ZERO: Fill output frame with zeros\nFILL_VALUES: Fill output frame with a user given value\nFILL_WITH_FILE: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smaller, the reset is filled with 0\nFILL_WITH_FILE_RPT: Fill output frame with a user given file (a raw data of tensor/tensors). If the filesize is smally, the file is repeatedly used\nREPEAT_PREVIOUS_FRAME: Resend the previous output frame. If this is the first, send ZERO values.\nTENSORPICK: Choose nth tensor (or tensors) among tensors\n\n\nnth tensor,nth tensor,... (for TENSORPICK option)\n${path_to_file}\n\n\nCompared_Value and Supplied_Value are the operands.\nCompared_Value is a value from input tensor(s).\nSupplied_Value is a value from tensor-if properties.\n\n"});
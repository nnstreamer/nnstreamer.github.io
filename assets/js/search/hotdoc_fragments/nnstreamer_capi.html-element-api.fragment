fragment_downloaded_cb({"url":"nnstreamer_capi.html#element-api","fragment":"Element API\nYou need to manipulate the input and the output data to run neural network models with Machine Learning Inference API. In addition, you can construct pipelines that can be controlled.\nFollowings are the available elements:\nSource\nThe configuration of the data source element is required to set the input tensor data:\nml_pipeline_src_get_handle() controls the appsrc element with the name srcx:\nYou can check the information of input tensors using srchandle:\nThe input tensor data can be filled according to the info:\nAfter using the data source element, release the handle:\nSink\nThe configuration of the data sink element is required to get the output tensor data:\nappsink element with the name sinkx becomes reachable through ml_pipeline_sink_register():\nYou can get the data from sink_callback(), whenever appsink named sinkx receives data:\nRelease the sinkhandle through ml_pipeline_sink_unregister():\nValve\nThis element is used to control the stream of a pipeline:\nBy default, valve named valve1 of the pipeline is opened. You can control the valve using ml_pipeline_valve_h:\nAfter you start a pipeline, you can control the stream of the pipeline with a valve:\nYou can also open the pipeline by controlling the stream of a pipeline with a valve:\nBefore you destroy the pipeline, release ml_pipeline_valve_h:\nSwitch\nThe switch element is used when you need only one working branch from a pipeline that has multiple branches:\n\nGet ml_pipeline_switch_h. The name of the switch in this pipeline is ins:\nYou can control the switch using the handle ml_pipeline_switch_h:\nBefore you destroy the pipeline, release ml_pipeline_switch_h:\nThe following image shows the switch at the end of the pipeline:\n\n\n\nSource\nThe configuration of the data source element is required to set the input tensor data:\nchar pipeline[] = \"appsrc name=srcx ! other/tensor,dimension=(string)4:1:1:1,type=(string)uint8,framerate=(fraction)0/1 ! tensor_sink\";\n\nml_pipeline_src_get_handle() controls the appsrc element with the name srcx:\nml_pipeline_h handle;\nml_pipeline_src_h srchandle;\n\nstatus = ml_pipeline_construct (pipeline, NULL, NULL, &handle);\nstatus = ml_pipeline_start (handle);\nstatus = ml_pipeline_src_get_handle (handle, \"srcx\", &srchandle);\n\nYou can check the information of input tensors using srchandle:\nml_tensors_info_h info;\n\nstatus = ml_pipeline_src_get_tensors_info (srchandle, &info);\n\nThe input tensor data can be filled according to the info:\nml_tensors_data_h data;\n\nstatus = ml_tensors_data_create (info, &data);\n\nfor (i = 0; i < 10; i++) {\n  uintarray1[i] = (uint8_t *) malloc (4);\n  uintarray1[i][0] = i + 4;\n  uintarray1[i][1] = i + 1;\n  uintarray1[i][2] = i + 3;\n  uintarray1[i][3] = i + 2;\n}\n\nstatus = ml_tensors_data_set_tensor_data (data, 0, uintarray1[0], 4);\n\n/* Setting the policy of raw data pointer */\nstatus = ml_pipeline_src_input_data (srchandle, data, ML_PIPELINE_BUF_POLICY_DO_NOT_FREE);\n\nAfter using the data source element, release the handle:\nstatus = ml_pipeline_src_release_handle (srchandle);\n\n\n\nSink\nThe configuration of the data sink element is required to get the output tensor data:\nchar pipeline[] = \"videotestsrc num-buffers=3 ! videoconvert ! tensor_converter ! appsink name=sinkx sync=false\";\n\nappsink element with the name sinkx becomes reachable through ml_pipeline_sink_register():\nint status;\nml_pipeline_h handle;\nml_pipeline_sink_h sinkhandle;\n\nstatus = ml_pipeline_sink_register (handle, \"sinkx\", sink_callback, user_data, &sinkhandle);\n\nYou can get the data from sink_callback(), whenever appsink named sinkx receives data:\ntypedef void (*ml_pipeline_sink_cb) (const ml_tensors_data_h data, const ml_tensors_info_h info, void *user_data);\n\nRelease the sinkhandle through ml_pipeline_sink_unregister():\nstatus = ml_pipeline_sink_unregister (sinkhandle);\n\n\n\nValve\nThis element is used to control the stream of a pipeline:\nchar pipeline[] = \"videotestsrc is-live=true ! videoconvert ! videoscale ! video/x-raw,format=RGBx,width=16,height=16,framerate=10/1 ! tensor_converter ! valve name=valve1 ! fakesink\";\nint status = ml_pipeline_construct (pipeline, NULL, NULL, &handle);\n\nBy default, valve named valve1 of the pipeline is opened. You can control the valve using ml_pipeline_valve_h:\nml_pipeline_h handle;\nml_pipeline_valve_h valve1;\n\nstatus = ml_pipeline_valve_get_handle (handle, \"valve1\", &valve1);\n\nAfter you start a pipeline, you can control the stream of the pipeline with a valve:\nstatus = ml_pipeline_start (handle);\n\nstatus = ml_pipeline_valve_set_open (valve1, false); /* Close */\n\nYou can also open the pipeline by controlling the stream of a pipeline with a valve:\nstatus = ml_pipeline_valve_set_open (valve1, true); /* Open */\n\nBefore you destroy the pipeline, release ml_pipeline_valve_h:\nstatus = ml_pipeline_valve_release_handle (valve1); /* Release valve handle */\n\n\n\nSwitch\nThe switch element is used when you need only one working branch from a pipeline that has multiple branches:\n\nchar pipeline[] = \"input-selector name=ins ! tensor_converter ! tensor_sink name=sinkx videotestsrc is-live=true ! videoconvert ! ins.sink_0 videotestsrc num-buffers=3 is-live=true ! videoconvert ! ins.sink_1\";\n\nGet ml_pipeline_switch_h. The name of the switch in this pipeline is ins:\nml_pipeline_h handle;\nml_pipeline_switch_h switchhandle;\nml_pipeline_switch_e type;\n\nstatus = ml_pipeline_construct (pipeline, NULL, NULL, &handle);\nstatus = ml_pipeline_switch_get_handle (handle, \"ins\", &type, &switchhandle);\n\nYou can control the switch using the handle ml_pipeline_switch_h:\nstatus = ml_pipeline_switch_select (switchhandle, \"sink_1\");\n\nBefore you destroy the pipeline, release ml_pipeline_switch_h:\nstatus = ml_pipeline_switch_release_handle (switchhandle);\n\nThe following image shows the switch at the end of the pipeline:\n\nchar pipeline[] = \"videotestsrc is-live=true ! videoconvert ! tensor_converter ! output-selector name=outs outs.src_0 ! tensor_sink name=sink0 async=false outs.src_1 ! tensor_sink name=sink1 async=false\"\n\n\n\n"});